"""
Provides a scalar specification URL for specifying the behavior of custom scalar types.
"""
directive @specifiedBy(
  """
  The URL should point to a human-readable specification of the data format, serialization, and coercion rules.
  """
  url: String!
) on SCALAR

type _Service {
  sdl: String!
}

"""Access request"""
type AccessRequest implements Node {
  """The unique identifier of the secret."""
  id: ID!

  """Name of a person requested access"""
  name: String!

  """Email of a person requested access"""
  email: String!

  """The date and time when request access was created"""
  createdAt: DateTime!

  """Additional information submitted by person requested access"""
  additionalInfo: String

  """Access request status"""
  status: AccessRequestStatus!
}

"""A list of access requests"""
type AccessRequestConnection {
  """Total count of access requests"""
  totalCount: Int!

  """A list of access requests"""
  nodes: [AccessRequest!]!

  """Pagination information."""
  pageInfo: BidirectionalPageInfo!
}

"""Access request status enum"""
enum AccessRequestStatus {
  """Access request is submitted and waiting for actions"""
  PENDING

  """Access request was approved"""
  APPROVED

  """Access request was rejected"""
  REJECTED
}

"""
An access token that grants to the holder the privileges of the user who created it.
"""
type AccessToken implements Node {
  """The unique ID for the access token."""
  id: ID!

  """The user whose privileges the access token grants."""
  subject: User!

  """
  The scopes that define the allowed set of operations that can be performed using this access token.
  """
  scopes: [String!]!

  """A user-supplied descriptive note for the access token."""
  note: String!

  """
  The user who created the access token. This is either the subject user (if the access token
  was created by the same user) or a site admin (who can create access tokens for any user).
  """
  creator: User!

  """The date when the access token was created."""
  createdAt: DateTime!

  """
  The date when the access token was last used to authenticate a request.
  """
  lastUsedAt: DateTime
}

"""A list of access tokens."""
type AccessTokenConnection {
  """A list of access tokens."""
  nodes: [AccessToken!]!

  """
  The total count of access tokens in the connection. This total count may be larger than the number of nodes
  in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A new external service."""
input AddExternalServiceInput {
  """The kind of the external service."""
  kind: ExternalServiceKind!

  """The display name of the external service."""
  displayName: String!

  """The JSON configuration of the external service."""
  config: String!

  """
  The namespace this external service belongs to.
  This can be used both for a user and an organization.
  """
  namespace: ID
}

"""Input object for adding insight view to dashboard."""
input AddInsightViewToDashboardInput {
  """ID of the insight view to attach to the dashboard"""
  insightViewId: ID!

  """ID of the dashboard."""
  dashboardId: ID!
}

"""Information regarding the availablity of a SearchAggregationMode"""
type AggregationGroup {
  """
  A label associated with the Aggregation for example a Repo name or Author name
  """
  label: String!

  """The number of hits for this search"""
  count: Int!

  """
  A modified search query that would filter the orginal query to just the selected group
  """
  query: String
}

"""Information regarding the availablity of a SearchAggregationMode"""
type AggregationModeAvailability {
  """The SearchAggregationMode"""
  mode: SearchAggregationMode!

  """Boolean indicating if the mode is available"""
  available: Boolean!

  """If the mode is unavailable the reason why"""
  reasonUnavailable: String
}

"""An alert message shown to the viewer."""
type Alert {
  """The type of this alert."""
  type: AlertType!

  """The message body of this alert. Markdown is supported."""
  message: String!

  """
  If set, this alert is dismissible. After being dismissed, no other alerts with the same
  isDismissibleWithKey value will be shown. If null, this alert is not dismissible.
  """
  isDismissibleWithKey: String
}

"""The possible types of alerts (Alert.type values)."""
enum AlertType {
  INFO
  WARNING
  ERROR
}

"""Analytics describes a new site statistics."""
type Analytics {
  """Search statistics."""
  search(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsSearchResult!

  """Notebooks statistics."""
  notebooks(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsNotebooksResults!

  """Users statistics."""
  users(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsUsersResult!

  """Code-intelligence statistics."""
  codeIntel(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsCodeIntelResult!

  """Code-intelligence statistics grouped by language and precision."""
  codeIntelByLanguage(dateRange: AnalyticsDateRange): [AnalyticsCodeIntelByLanguageResult!]!

  """Top repositories by code-intelligence events."""
  codeIntelTopRepositories(dateRange: AnalyticsDateRange): [AnalyticsCodeIntelRepositoryResult!]!

  """Repositories summary statistics."""
  repos: AnalyticsReposSummartResult!

  """Batch changes statistics"""
  batchChanges(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsBatchChangesResult!

  """Extensions statistics"""
  extensions(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsExtensionsResult!

  """Code insights statistics"""
  codeInsights(dateRange: AnalyticsDateRange, grouping: AnalyticsGrouping): AnalyticsCodesInsightsResult!
}

"""Batch changes analytics."""
type AnalyticsBatchChangesResult {
  """Changesets created"""
  changesetsCreated: AnalyticsStatItem!

  """Changesets merged"""
  changesetsMerged: AnalyticsStatItem!
}

"""CodeIntelByLanguage analytics."""
type AnalyticsCodeIntelByLanguageResult {
  """Language"""
  language: String!

  """Precision"""
  precision: String!

  """Count"""
  count: Float!
}

"""CodeIntelTopRepositories analytics."""
type AnalyticsCodeIntelRepositoryResult {
  """Repository name"""
  name: String!

  """Language"""
  language: String!

  """Event kind"""
  kind: String!

  """Event precision (either "search-based" or "precise")"""
  precision: String!

  """Event count"""
  events: Float!

  """Has precise"""
  hasPrecise: Boolean!
}

"""CodeIntel' analytics."""
type AnalyticsCodeIntelResult {
  """"GoToRef" click"""
  referenceClicks: AnalyticsStatItem!

  """"GoToDef" click"""
  definitionClicks: AnalyticsStatItem!

  """Code Intel events made from web"""
  inAppEvents: AnalyticsStatItem!

  """Code Intel events made from code host"""
  codeHostEvents: AnalyticsStatItem!

  """Search based events"""
  searchBasedEvents: AnalyticsStatItem!

  """Precise events"""
  preciseEvents: AnalyticsStatItem!

  """Cross-repo events"""
  crossRepoEvents: AnalyticsStatItem!
}

"""Code insights analytics."""
type AnalyticsCodesInsightsResult {
  """Insights hovers statistics."""
  insightHovers: AnalyticsStatItem!

  """Insights data point clicks statistics."""
  insightDataPointClicks: AnalyticsStatItem!
}

"""A pre-defined periods to get site analytics."""
enum AnalyticsDateRange {
  """Last 3 months date range."""
  LAST_THREE_MONTHS

  """Last month date range."""
  LAST_MONTH

  """Last week date range."""
  LAST_WEEK

  """Custom date range."""
  CUSTOM
}

"""Extentions analytics."""
type AnalyticsExtensionsResult {
  """JetBrains IDE plugin search events."""
  jetbrains: AnalyticsStatItem!

  """VSCode IDE extension search events."""
  vscode: AnalyticsStatItem!

  """
  Browser (chrome, firefox, safari) extensions code navigation events.
  This includes events like "Go to Def", "Find ref" and "Find implementation"
  """
  browser: AnalyticsStatItem!
}

"""Group site analytics by period."""
enum AnalyticsGrouping {
  """Group data by day."""
  DAILY

  """Group data by week."""
  WEEKLY
}

"""Monthly active users"""
type AnalyticsMonthlyActiveUsers {
  """year-month for which the total active users are calculated"""
  date: String!

  """total count of active users"""
  count: Float!
}

"""Notebook analytics."""
type AnalyticsNotebooksResults {
  """Notebooks creation analytics."""
  creations: AnalyticsStatItem!

  """Notebooks views analytics."""
  views: AnalyticsStatItem!

  """Notebooks block run analytics."""
  blockRuns: AnalyticsStatItem!
}

"""Repositories summary."""
type AnalyticsReposSummartResult {
  """Total number of repositories."""
  count: Float!

  """Total number of repositories with precise code-intel."""
  preciseCodeIntelCount: Float!
}

"""Search analytics."""
type AnalyticsSearchResult {
  """Searches analytics"""
  searches: AnalyticsStatItem!

  """Search result click analytics"""
  resultClicks: AnalyticsStatItem!

  """File view analytics"""
  fileViews: AnalyticsStatItem!

  """File open analytics"""
  fileOpens: AnalyticsStatItem!

  """Code copied from search results analytics"""
  codeCopied: AnalyticsStatItem!
}

"""Analytics result item."""
type AnalyticsStatItem {
  """Analytics summary."""
  summary: AnalyticsStatItemSummary!

  """Array of analytics by period."""
  nodes: [AnalyticsStatItemNode!]!
}

"""Analytics for certain date."""
type AnalyticsStatItemNode {
  """A date in ISO format"""
  date: String!

  """Total number of events."""
  count: Float!

  """
  Unique number of users who triggered event.
  This counts deleted users as well as anonymous users.
  """
  uniqueUsers: Float!

  """Unique number of currently registered users who triggered event."""
  registeredUsers: Float!
}

"""Analytics summary."""
type AnalyticsStatItemSummary {
  """Total number of events."""
  totalCount: Float!

  """
  Total unique number of users who triggered event.
  This counts deleted users as well as anonymous users.
  """
  totalUniqueUsers: Float!

  """Total unique number of currently registered users who triggered event."""
  totalRegisteredUsers: Float!
}

"""Users frequency by days used."""
type AnalyticsUsersFrequencyItem {
  """Number of days used"""
  daysUsed: Float!

  """Number of users."""
  frequency: Float!

  """Percentage of users from total frequencies."""
  percentage: Float!
}

"""Users' analytics."""
type AnalyticsUsersResult {
  """Users' activity analytics."""
  activity: AnalyticsStatItem!

  """Frequency of usage by day."""
  frequencies: [AnalyticsUsersFrequencyItem!]!

  """Monthly active users for last 3 months."""
  monthlyActiveUsers: [AnalyticsMonthlyActiveUsers!]!
}

"""Manually assigned owner."""
type AssignedOwner {
  """Descriptive title to display in the UI for the determination."""
  title: String!

  """More detailed description to display in the UI for the determination."""
  description: String!

  """
  Whether or not this rule matches a path directly, or is inherited from a parent path.
  """
  isDirectMatch: Boolean!
}

"""
AssignOwnerOrTeamInput represents the input for assigning or deleting an owner team or person.
"""
input AssignOwnerOrTeamInput {
  """ID of an assigned owner or team."""
  assignedOwnerID: ID!

  """
  ID of a repo, which (or which directory/file) is assigned for ownership.
  """
  repoID: ID!

  """
  Path of the file/directory or a root path of the repo, which is assigned for ownership.
  """
  absolutePath: String!
}

"""Represents a state transition of a single column."""
type AuditLogColumnChange {
  """The column that is changing."""
  column: String!

  """The previous value of the column."""
  old: String

  """The new value of the column"""
  new: String
}

"""Denotes the type of operation of a given log entry."""
enum AuditLogOperation {
  """Denotes this log entry represents an INSERT query."""
  CREATE

  """Denotes this log entry represents an UPDATE query."""
  MODIFY
}

"""
A provider of user authentication, such as an external single-sign-on service (e.g., using OpenID Connect or
SAML). The provider information in this type is visible to all viewers and does not contain any secret values.
"""
type AuthProvider {
  """The type of the auth provider."""
  serviceType: String!

  """An identifier for the service that the auth provider represents."""
  serviceID: String!

  """
  An identifier for the client of the service that the auth provider represents.
  """
  clientID: String!

  """The human-readable name of the provider."""
  displayName: String!

  """
  Whether this auth provider is the builtin username-password auth provider.
  """
  isBuiltin: Boolean!

  """
  A URL that, when visited, initiates the authentication process for this auth provider.
  """
  authenticationURL: String
}

"""A list of authentication providers."""
type AuthProviderConnection {
  """A list of authentication providers."""
  nodes: [AuthProvider!]!

  """
  The total count of authentication providers in the connection. This total count may be larger than the number of nodes
  in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Result user returned by invite members autocomplete search."""
type AutocompleteMemberSearchItem {
  """The unique ID for the user."""
  id: ID!

  """The user's username."""
  username: String!

  """The display name chosen by the user."""
  displayName: String

  """The URL of the user's avatar image."""
  avatarURL: String

  """If the user belongs to current Organization."""
  inOrg: Boolean
}

"""A description of an auto-indexing job inferred by the instance."""
type AutoIndexJobDescription {
  """The project root."""
  root: String!

  """The target indexer."""
  indexer: CodeIntelIndexer

  """
  A hash of the root and indexer values.
  
  This value can be used to quickly compare whether or not explicit configuration and inferred configuration
  refer to the same "project" in a given repository. See `RootWithKey.comparisonKey`.
  """
  comparisonKey: String!

  """The particular steps inferred for indexing."""
  steps: IndexSteps!
}

"""
BackfillQueueOrderBy enumerates the ways a backfill queue list can be ordered.
"""
enum BackfillQueueOrderBy {
  STATE
  QUEUE_POSITION
}

"""The status of an insights backfill"""
type BackfillStatus {
  """The current backfill queue state"""
  state: InsightQueueItemState!

  """If the item is queued the position in the queue of"""
  queuePosition: Int

  """A list of errors that have occurred during backfilling"""
  errors: [String!]

  """The estimated cost of the backfill process"""
  cost: Int

  """The percent complete of the backfill"""
  percentComplete: Int

  """The date/time when the backfill was created"""
  createdAt: DateTime

  """The date/time when the backfill started processing"""
  startedAt: DateTime

  """The date/time when the backfill completed processing"""
  completedAt: DateTime

  """The actual runtime duration spent processing the backfill"""
  runtime: String
}

"""A single background job."""
type BackgroundJob implements Node {
  """The background job ID."""
  id: ID!

  """The name of the job."""
  name: String!

  """The routines that run inside this job."""
  routines: [BackgroundRoutine!]!
}

"""A list of background jobs that are currently known in the system"""
type BackgroundJobConnection {
  """A list of outbound requests."""
  nodes: [BackgroundJob!]!

  """The total number of outbound request log items in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A routine that runs inside a background job."""
type BackgroundRoutine {
  """The name of the routine."""
  name: String!

  """
  Tells whether this is a periodic goroutine, a DB worker, or something else
  """
  type: BackgroundRoutineType!

  """Explains what the routine does."""
  description: String!

  """The interval at which the routine runs, if it's periodic."""
  intervalMs: Int

  """
  The instances of this routine that are running or ran recently. An instance means one routine on one host.
  """
  instances: [BackgroundRoutineInstance!]!

  """The recent runs of this routine."""
  recentRuns: [BackgroundRoutineRecentRun!]!

  """Some stats of the runs of this routine in the past few days."""
  stats: BackgroundRoutineStats!
}

"""One instance of the background routine, running on a host."""
type BackgroundRoutineInstance {
  """The ID of the instance."""
  hostName: String!

  """
  The time the instance was last started. (If it's unknown, this will be null.)
  """
  lastStartedAt: DateTime

  """
  The time the instance was last stopped. (If it's unknown, this will be null.)
  """
  lastStoppedAt: DateTime
}

"""
A single run of the routine. A run is not the start/stop event but the actual execution of the routine handler.
"""
type BackgroundRoutineRecentRun {
  """The time the run started."""
  at: DateTime!

  """The name of the host that ran the routine."""
  hostName: String!

  """The duration of the run."""
  durationMs: Int!

  """The error message, if any."""
  errorMessage: String
}

"""Holds statistics about a background routine."""
type BackgroundRoutineStats {
  """The start of the earliest day for which we have any runs registered."""
  since: DateTime

  """The number of times the routine ran in the period."""
  runCount: Int!

  """The number of times the routine run ended with an error."""
  errorCount: Int!

  """The minimum duration of a run, in milliseconds."""
  minDurationMs: Int!

  """The average duration of a run, in milliseconds."""
  avgDurationMs: Int!

  """The maximum duration of a run, in milliseconds."""
  maxDurationMs: Int!
}

"""Enum of the possible background routine types"""
enum BackgroundRoutineType {
  """Periodic routine"""
  PERIODIC

  """Periodic routine with metrics set up"""
  PERIODIC_WITH_METRICS

  """DB-backed worker"""
  DB_BACKED

  """Custom routine"""
  CUSTOM
}

"""
A batch change is a set of related changes to apply to code across one or more repositories.
"""
type BatchChange implements Node {
  """The unique ID for the batch change."""
  id: ID!

  """The namespace where this batch change is defined."""
  namespace: Namespace!

  """The name of the batch change."""
  name: String!

  """The description (as Markdown)."""
  description: String

  """The state of the batch change."""
  state: BatchChangeState!

  """
  The user who created the batch change, or null if the user was deleted.
  """
  creator: User

  """
  The user who last updated the batch change by applying a spec to this batch change.
  If the batch change hasn't been updated, the lastApplier is the initialApplier, or null if the user was deleted.
  """
  lastApplier: User

  """Whether the current user can edit or delete this batch change."""
  viewerCanAdminister: Boolean!

  """The URL to this batch change."""
  url: String!

  """The date and time when the batch change was created."""
  createdAt: DateTime!

  """
  The date and time when the batch change was updated. That can be by applying a spec, or by an internal process.
  For reading the time the batch change spec was changed last, see lastAppliedAt.
  """
  updatedAt: DateTime!

  """
  The date and time when the batch change was last updated with a new spec. Null, if a batch spec has never been
  applied yet.
  """
  lastAppliedAt: DateTime

  """
  The date and time when the batch change was closed. If set, applying a spec for this batch change will fail with an error.
  """
  closedAt: DateTime

  """Stats on all the changesets that are tracked in this batch change."""
  changesetsStats: ChangesetsStats!

  """
  The changesets in this batch change that already exist on the code host.
  """
  changesets(
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """Only include changesets with the given state."""
    state: ChangesetState

    """
    Query only changesets that are either open or draft. This is used on the close page to list changesets that remain open.
    When set, passing state is not allowed.
    """
    onlyClosable: Boolean

    """
    Only include changesets with the given review state.
    
    Note: The COMMENTED and DISMISSED review states are not yet implemented.
    """
    reviewState: ChangesetReviewState

    """Only include changesets with the given check state."""
    checkState: ChangesetCheckState

    """
    Only return changesets that have been published by this batch change. Imported changesets will be omitted.
    """
    onlyPublishedByThisBatchChange: Boolean

    """
    Search for changesets matching this query. Queries may include quoted
    substrings to match phrases, and words may be preceded by - to negate them.
    """
    search: String

    """Only return changesets that are archived in this batch change."""
    onlyArchived: Boolean = false

    """Only include changesets belonging to the given repository."""
    repo: ID
  ): ChangesetConnection!

  """
  The changeset counts over time, in 1-day intervals backwards from the point in time given in
  the "to" parameter.
  """
  changesetCountsOverTime(
    """
    Only include changeset counts up to this point in time (inclusive). Defaults to BatchChange.createdAt.
    """
    from: DateTime

    """
    Only include changeset counts up to this point in time (inclusive). Defaults to the
    current time.
    """
    to: DateTime

    """Include archived changesets in the calculation."""
    includeArchived: Boolean = false
  ): [ChangesetCounts!]!

  """The diff stat for all the changesets in the batch change."""
  diffStat: DiffStat!

  """
  The last batch spec applied to this batch change, or an "empty" spec if the batch
  change has never had a spec applied.
  """
  currentSpec: BatchSpec!

  """The bulk operations that have been run over this batch change."""
  bulkOperations(
    """Returns the first n entries from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """Filter by createdAt value."""
    createdAfter: DateTime
  ): BulkOperationConnection!

  """
  The batch specs that have been running on this batch change.
  
  Site-admins can see all of them, non admins can only see batch specs that they
  created.
  """
  batchSpecs(
    """Returns the first n entries from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Include locally executed (i.e. with src-cli) batch specs in the list of specs returned.
    """
    includeLocallyExecutedSpecs: Boolean

    """
    Exclude the empty batch specs that are initially created and applied to draft batch changes.
    """
    excludeEmptySpecs: Boolean
  ): BatchSpecConnection!
}

"""A list of batch changes."""
type BatchChangeConnection {
  """A list of batch changes."""
  nodes: [BatchChange!]!

  """The total number of batch changes in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A BatchChangeDescription describes a batch change."""
type BatchChangeDescription {
  """The name as parsed from the input."""
  name: String!

  """The description as parsed from the input."""
  description: String!
}

"""
A code host usable with batch changes. This service is accessible by the user it belongs to.
"""
type BatchChangesCodeHost {
  """The kind of external service."""
  externalServiceKind: ExternalServiceKind!

  """The URL of the external service."""
  externalServiceURL: String!

  """The configured credential, if any."""
  credential: BatchChangesCredential

  """
  Configuration for commit signing, if any has been set up. Always nil if the code
  host type doesn't have commit signing support yet.
  """
  commitSigningConfiguration: CommitSigningConfiguration

  """
  If true, some of the repositories on this code host require
  an SSH key to be configured.
  """
  requiresSSH: Boolean!

  """
  If true, this code host requires credentials to have a username as well as a personal access token.
  """
  requiresUsername: Boolean!

  """If true, this code host can setup commit signing."""
  supportsCommitSigning: Boolean!

  """If true, the code host has webhooks configured."""
  hasWebhooks: Boolean!
}

"""
A connection of all code hosts usable with batch changes and accessible by the user
this is requested on.
"""
type BatchChangesCodeHostConnection {
  """A list of code hosts."""
  nodes: [BatchChangesCodeHost!]!

  """The total number of configured external services in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
A user token configured for batch changes use on the specified code host.
"""
type BatchChangesCredential implements Node {
  """A globally unique identifier."""
  id: ID!

  """The kind of external service."""
  externalServiceKind: ExternalServiceKind!

  """The URL of the external service."""
  externalServiceURL: String!

  """
  The public key to use on the external service for SSH keypair authentication.
  Not set if the credential doesn't support SSH access.
  """
  sshPublicKey: String

  """The date and time this token has been created at."""
  createdAt: DateTime!

  """
  Whether the configured credential is a site credential, that is available globally.
  """
  isSiteCredential: Boolean!
}

"""The state of the batch change."""
enum BatchChangeState {
  OPEN
  CLOSED
  DRAFT
}

"""
A batch spec is an immutable description of the desired state of a batch change. To create a
batch spec, use the createBatchSpec mutation.
"""
type BatchSpec implements Node {
  """
  The unique ID for a batch spec.
  
  The ID is unguessable (i.e., long and randomly generated, not sequential).
  Consider a batch change to fix a security vulnerability: the batch change author may prefer
  to prepare the batch change, including the description in private so that the window
  between revealing the problem and merging the fixes is as short as possible.
  """
  id: ID!

  """
  Future: Flag that calls applyBatchChange automatically when this execution completes.
  Useful for integrations with code monitoring etc.
  
  TODO: Not implemented yet.
  """
  autoApplyEnabled: Boolean!

  """
  The current execution state of the batch spec. For manually created ones (src-cli workflow),
  this will always be COMPLETED. This is an accumulated state over all the associated
  workspaces for convenience.
  """
  state: BatchSpecState!

  """
  The original YAML or JSON input that was used to create this batch spec.
  """
  originalInput: String!

  """
  The parsed JSON value of the original input. If the original input was YAML, the YAML is
  converted to the equivalent JSON.
  """
  parsedInput: JSONValue!

  """The BatchChangeDescription that describes this batch change."""
  description: BatchChangeDescription!

  """
  Generates a preview showing the operations that would be performed if the
  batch spec was applied. This preview is not a guarantee, since the state
  of the changesets can change between the time the preview is generated and
  when the batch spec is applied.
  """
  applyPreview(
    """Returns the first n entries from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Search for changesets matching this query. Queries may include quoted
    substrings to match phrases, and words may be preceded by - to negate them.
    """
    search: String

    """Search for changesets that are currently in this state."""
    currentState: ChangesetState

    """Search for changesets that will have the given action performed."""
    action: ChangesetSpecOperation

    """
    If set, it will be assumed that these changeset specs will have their
    UI publication states set to the given values when the batch spec is
    applied.
    
    An error will be returned if the same changeset spec ID is included
    more than once in the array, or if a changeset spec ID returned within
    this page has a publication state set in its spec.
    
    Note: Unlike createBatchChange(), this query will not validate that all
    changeset specs in the array correspond to valid changeset specs within
    the batch spec, as they may not all be loaded on the current page.
    """
    publicationStates: [ChangesetSpecPublicationStateInput!]
  ): ChangesetApplyPreviewConnection!

  """The specs for changesets associated with this batch spec."""
  changesetSpecs(first: Int = 50, after: String): ChangesetSpecConnection!

  """
  The user who created this batch spec. Their permissions will be honored when
  executing the batch spec. Null, if the user has been deleted.
  """
  creator: User

  """
  The time when the batch spec was created at. At this time, it is also added to
  the queue for execution, if created from raw.
  """
  createdAt: DateTime!

  """
  The time when the execution started. Null, if the execution hasn't started
  yet, or if the batch spec was created in COMPLETED state.
  """
  startedAt: DateTime

  """
  The time when the execution finished. Null, if the execution hasn't finished
  yet, or if the batch spec was created in COMPLETED state.
  This value is the time of when the batch spec has been sealed.
  """
  finishedAt: DateTime

  """The namespace (either a user or organization) of the batch spec."""
  namespace: Namespace!

  """
  The date, if any, when this batch spec expires and is automatically purged. A batch spec
  never expires if it has been applied.
  """
  expiresAt: DateTime

  """
  The URL of a web page that allows applying this batch spec and
  displays a preview of which changesets will be created by applying it.
  Null, if the execution has not finished yet.
  """
  applyURL: String

  """
  When true, the viewing user can apply this spec, modify it, and run workspace
  resolution jobs.
  """
  viewerCanAdminister: Boolean!

  """
  The diff stat for all the changeset specs in the batch spec. Null if state is
  not COMPLETED.
  """
  diffStat: DiffStat

  """
  The batch change this spec will update when applied. If it's null, the
  batch change doesn't yet exist.
  """
  appliesToBatchChange: BatchChange

  """
  The newest version of this batch spec, as identified by its namespace
  and name. If this is the newest version, this field will be null.
  """
  supersedingBatchSpec: BatchSpec

  """
  The code host connections required for applying this spec. Includes the credentials of the current user.
  Only returns useful information if state is COMPLETED.
  """
  viewerBatchChangesCodeHosts(
    """Returns the first n code hosts from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only returns the code hosts for which the viewer doesn't have credentials.
    """
    onlyWithoutCredential: Boolean = false

    """Only returns code hosts that don't have webhooks configured."""
    onlyWithoutWebhooks: Boolean = false
  ): BatchChangesCodeHostConnection!

  """
  A wrapper for the workspace resolution on this batch spec. Contains access to
  all workspaces that have been resolved, as well as insight into the state of
  the resolution.
  Null, if the batch spec was created in COMPLETED state.
  """
  workspaceResolution: BatchSpecWorkspaceResolution

  """
  The set of changeset specs for importing changesets, as determined from the
  raw spec.
  Null, if not created through createBatchSpecFromRaw.
  """
  importingChangesets(first: Int = 50, after: String, search: String): ChangesetSpecConnection

  """
  Set when something about this batch spec is not right. For example, the input spec
  is invalid, or if ValidateChangesetSpecs throws an error when the last job completes.
  """
  failureMessage: String

  """
  If true, repos with a .batchignore file will still be included in the
  execution.
  
  Null, if not created through createBatchSpecFromRaw.
  """
  allowIgnored: Boolean

  """
  If true, repos on unsupported codehosts will be included in the execution.
  These cannot be published.
  
  Null, if not created through createBatchSpecFromRaw.
  """
  allowUnsupported: Boolean

  """
  If true, workspaces will not run with cached results.
  
  Null, if not created through createBatchSpecFromRaw.
  """
  noCache: Boolean

  """
  If true, viewer can retry the batch spec execution by calling
  retryBatchSpecExecution.
  """
  viewerCanRetry: Boolean!

  """
  Whether the batch spec was created from the local src-cli workflow or remotely for
  server-side execution.
  """
  source: BatchSpecSource!

  """The files that are mounted in the steps of a batch spec."""
  files(
    """Returns the first n files from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): BatchSpecWorkspaceFileConnection
}

"""A list of batch specs."""
type BatchSpecConnection {
  """The total number of batch specs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of batch specs."""
  nodes: [BatchSpec!]!
}

"""The possible sources of a batch spec."""
enum BatchSpecSource {
  """The spec was created from the local src-cli workflow."""
  LOCAL

  """
  This spec was created for remote server-side execution, e.g. from the web UI editor,
  or with src batch remote.
  """
  REMOTE
}

"""The possible states of a batch spec."""
enum BatchSpecState {
  """The spec is not yet enqueued for processing."""
  PENDING

  """This spec is being processed."""
  PROCESSING

  """This spec failed to be processed."""
  FAILED

  """This spec was processed successfully."""
  COMPLETED

  """This spec is queued to be processed."""
  QUEUED

  """The execution is being canceled."""
  CANCELING

  """The execution has been canceled."""
  CANCELED
}

"""
The common interface for a batch spec workspace. Depending on access to the repository,
either a HiddenBatchSpecWorkspace or a VisibleBatchSpecWorkspace will be serving this
interface.
"""
interface BatchSpecWorkspace {
  """The unique ID for the workspace."""
  id: ID!

  """Used for reverse querying."""
  batchSpec: BatchSpec!

  """If true, only the files within the workspace will be fetched."""
  onlyFetchWorkspace: Boolean!

  """
  If true, this workspace has been skipped, because some rule forced this.
  For now, the only one is a .batchignore file existing in the repository.
  """
  ignored: Boolean!

  """
  If true, this workspace has been skipped, because the code host on which
  the repository is hosted is not supported.
  """
  unsupported: Boolean!

  """Whether we found a task cache result."""
  cachedResultFound: Boolean!

  """How many steps had a cached result."""
  stepCacheResultCount: Int!

  """
  The time when the workspace was enqueued for processing. Null, if not yet enqueued.
  """
  queuedAt: DateTime

  """
  The time when the workspace started processing. Null, if not yet started.
  """
  startedAt: DateTime

  """
  The time when the workspace finished processing. Null, if not yet finished.
  """
  finishedAt: DateTime

  """The current state the workspace is in."""
  state: BatchSpecWorkspaceState!

  """
  The rank of this execution in the queue of the user. The value of this field is null if the
  execution has started.
  """
  placeInQueue: Int

  """
  The rank of this execution in the global queue. The value of this field is null if the
  execution has started.
  """
  placeInGlobalQueue: Int

  """
  The diff stat over all created changeset specs. Null, if not yet finished or
  failed.
  """
  diffStat: DiffStat
}

"""A list of workspaces."""
type BatchSpecWorkspaceConnection {
  """The total number of workspaces in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of workspaces."""
  nodes: [BatchSpecWorkspace!]!

  """Statistics on the workspaces in this connection."""
  stats: BatchSpecWorkspacesStats!
}

"""An enviroment variable passed to a command in a step."""
type BatchSpecWorkspaceEnvironmentVariable {
  """The variable name."""
  name: String!

  """
  The variable value.
  If null, the variable will be populated from a secret.
  """
  value: String
}

"""The metadata of a file being used in a batch spec step."""
type BatchSpecWorkspaceFile implements File2 & Node {
  """The ID of the file."""
  id: ID!

  """When the file was last touched."""
  modifiedAt: DateTime!

  """When the file is initially created at."""
  createdAt: DateTime!

  """When the file is updated at."""
  updatedAt: DateTime!

  """The full path (relative to the root) of this file."""
  path: String!

  """The base name (i.e., file name only) of this file."""
  name: String!

  """False because this is a file, not a directory."""
  isDirectory: Boolean!

  """The content of this file."""
  content(
    """
    Return file content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return file content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """The file size in bytes."""
  byteSize: Int!

  """Total line count for the Blob. Returns 0 for binary files."""
  totalLines: Int!

  """Whether or not it is binary."""
  binary: Boolean!

  """
  The file rendered as rich HTML, or an empty string if it is not a supported
  rich file type.
  This HTML string is already escaped and thus is always safe to render.
  """
  richHTML(
    """
    Return richHTML content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return richHTML content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """
  The URL to this file (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this file (using an immutable revision specifier).
  """
  canonicalURL: String!

  """The URLs to this file on external services."""
  externalURLs: [ExternalLink!]!

  """Highlight the file."""
  highlight(
    disableTimeout: Boolean!
    isLightTheme: Boolean

    """
    If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
    2000 bytes is enabled. This may produce a significant amount of HTML
    which some browsers (such as Chrome, but not Firefox) may have trouble
    rendering efficiently.
    """
    highlightLongLines: Boolean = false

    """Specifies which format/highlighting technique to use."""
    format: HighlightResponseFormat = HTML_HIGHLIGHT

    """
    Return highlight content starting at line "startLine". A value <= 0 will be the start of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    startLine: Int

    """
    Return highlight content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    endLine: Int
  ): HighlightedFile!
}

"""A list of BatchSpecMounts."""
type BatchSpecWorkspaceFileConnection {
  """The total number of files."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of workspace files in a batch spec."""
  nodes: [BatchSpecWorkspaceFile!]!
}

"""An output variable in a step."""
type BatchSpecWorkspaceOutputVariable {
  """The variable name."""
  name: String!

  """The variable value."""
  value: JSONValue!
}

"""A bag for all info around resolving workspaces."""
type BatchSpecWorkspaceResolution {
  """Error message, if the evaluation failed."""
  failureMessage: String

  """Set when evaluating workspaces begins."""
  startedAt: DateTime

  """Set when evaluating workspaces finished."""
  finishedAt: DateTime

  """State of evaluating the workspaces."""
  state: BatchSpecWorkspaceResolutionState!

  """The actual list of determined workspaces."""
  workspaces(
    first: Int = 50
    after: String

    """Not implemented."""
    orderBy: WorkspacesSortOrder

    """
    Search for workspaces matching this query. Queries may include quoted substrings
    to match phrases, and words may be preceded by - to negate them.
    Currently, this supports searching repository names only.
    Repos that are not visible to the viewer will be omitted entirely when
    this argument is passed.
    """
    search: String

    """Filter workspaces by given state."""
    state: BatchSpecWorkspaceState
  ): BatchSpecWorkspaceConnection!

  """
  Returns the workspaces where most recently a step completed that yielded a diff.
  """
  recentlyCompleted(first: Int = 50, after: String): BatchSpecWorkspaceConnection!

  """Returns the most recently failed workspace executions."""
  recentlyErrored(first: Int = 50, after: String): BatchSpecWorkspaceConnection!
}

"""State of the workspace resolution."""
enum BatchSpecWorkspaceResolutionState {
  """Not yet started resolving. Will be picked up by a worker eventually."""
  QUEUED

  """Currently resolving workspaces."""
  PROCESSING

  """
  An error occured while resolving workspaces. Will be retried eventually.
  """
  ERRORED

  """
  A fatal error occured while resolving workspaces. No retries will be made.
  """
  FAILED

  """Resolving workspaces finished successfully."""
  COMPLETED
}

"""Statistics on all workspaces in a connection."""
type BatchSpecWorkspacesStats {
  """Number of errored workspaces."""
  errored: Int!

  """Number of completed workspaces."""
  completed: Int!

  """Number of processing workspaces."""
  processing: Int!

  """Number of queued workspaces."""
  queued: Int!

  """Number of ignored workspaces."""
  ignored: Int!
}

"""
Configuration and execution summary of a batch spec execution. This is mostly
meant for internal consumption, for the timeline view.
"""
type BatchSpecWorkspaceStages {
  """Execution log entries related to setting up the workspace."""
  setup: [ExecutionLogEntry!]!

  """Execution log entries related to running the steps of the batch spec."""
  srcExec: [ExecutionLogEntry!]!

  """Execution log entries related to tearing down the workspace."""
  teardown: [ExecutionLogEntry!]!
}

"""The states a workspace can be in."""
enum BatchSpecWorkspaceState {
  """
  The workspace will not be enqueued for execution, because either the
  workspace is unsupported/ignored or has 0 steps to execute.
  """
  SKIPPED

  """The workspace is not yet enqueued for execution."""
  PENDING

  """Not yet started executing. Will be picked up by a worker eventually."""
  QUEUED

  """Currently executing on the workspace."""
  PROCESSING

  """A fatal error occured while executing. No retries will be made."""
  FAILED

  """Execution finished successfully."""
  COMPLETED

  """Execution is being canceled. This is an async process."""
  CANCELING

  """Execution has been canceled."""
  CANCELED
}

"""Description of one step in the execution of a workspace."""
type BatchSpecWorkspaceStep {
  """The number of the step."""
  number: Int!

  """The command to run."""
  run: String!

  """The docker container image to use to run this command."""
  container: String!

  """The if condition, under which the step is executed. Null, if not set."""
  ifCondition: String

  """True, if a cached result has been found."""
  cachedResultFound: Boolean!

  """
  True, when the `if` condition evaluated that this step doesn't need to run.
  """
  skipped: Boolean!

  """
  The output logs, prefixed with either "stdout " or "stderr ". Null, if the
  step has not run yet.
  """
  outputLines(
    """Return the first N lines of logs."""
    first: Int = 500

    """Return the log lines after N lines."""
    after: String
  ): BatchSpecWorkspaceStepOutputLineConnection!

  """The time when the step started processing. Null, if not yet started."""
  startedAt: DateTime

  """The time when the step finished processing. Null, if not yet finished."""
  finishedAt: DateTime

  """The exit code of the command. Null, if not yet finished."""
  exitCode: Int

  """The environment variables passed to this step."""
  environment: [BatchSpecWorkspaceEnvironmentVariable!]!

  """The output variables the step produced. Null, if not yet finished."""
  outputVariables: [BatchSpecWorkspaceOutputVariable!]

  """The diff stat of the step result. Null, if not yet finished."""
  diffStat: DiffStat

  """The generated diff from this step. Null, if not yet finished."""
  diff: PreviewRepositoryComparison
}

"""A list of Output lines from a Batch spec workspace."""
type BatchSpecWorkspaceStepOutputLineConnection {
  """The total number of output lines in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of output lines."""
  nodes: [String!]!
}

"""A set of Git behind/ahead counts for one commit relative to another."""
type BehindAheadCounts {
  """The number of commits behind the other commit."""
  behind: Int!

  """The number of commits ahead of the other commit."""
  ahead: Int!
}

"""
Pagination information for bi-directional pagination. See
https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.
"""
type BidirectionalPageInfo {
  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
}

"""An arbitrarily large integer encoded as a decimal string."""
scalar BigInt

"""Information about a single Projects permission synchronization job."""
type BitbucketProjectPermissionJob {
  """Internal ID of the job."""
  InternalJobID: Int!

  """
  State of the job (queued, processing, completed, canceled, errored, failed).
  """
  State: String!

  """Failure message in case of unsuccessful job execution."""
  FailureMessage: String

  """The time when the job was enqueued for processing."""
  QueuedAt: DateTime!

  """The time when the job started processing. Null, if not yet started."""
  StartedAt: DateTime

  """The time when the job finished processing. Null, if not yet finished."""
  FinishedAt: DateTime

  """Controls the time after which the job is visible for processing."""
  ProcessAfter: DateTime

  """The number of times when the job is moved back from failed to queued."""
  NumResets: Int!

  """The number of times when the job entered the errored state."""
  NumFailures: Int!

  """Bitbucket project key."""
  ProjectKey: String!

  """ID of external service which project is being synchronized."""
  ExternalServiceID: ID!

  """User permissions to be granted."""
  Permissions: [UserPermission!]!

  """Shows that current project is accessible by any user of the project."""
  Unrestricted: Boolean!
}

"""Information about Bitbucket Projects permission synchronization jobs."""
type BitbucketProjectPermissionJobs {
  """Number of jobs."""
  totalCount: Int!

  """Bitbucket Projects permission sync jobs."""
  nodes: [BitbucketProjectPermissionJob!]!
}

"""
A bulk operation represents a group of jobs run over a set of changesets in a batch change.
"""
type BulkOperation implements Node {
  """The unique ID for the bulk operation."""
  id: ID!

  """The type of task that is run."""
  type: BulkOperationType!

  """The current state of the bulk operation."""
  state: BulkOperationState!

  """
  The progress to completion of all executions involved in this bulk operation. Value
  ranges from 0.0 to 1.0.
  """
  progress: Float!

  """The list of all errors that occured while processing the bulk action."""
  errors: [ChangesetJobError!]!

  """The time the bulk operation was created at."""
  createdAt: DateTime!

  """
  The time the bulk operation finished. Also set, when some operations failed. Null,
  when some operations are still processing.
  """
  finishedAt: DateTime

  """The user who triggered this bulk operation."""
  initiator: User!

  """The number of changesets involved in this bulk operation."""
  changesetCount: Int!
}

"""A list of bulk operations."""
type BulkOperationConnection {
  """The total number of bulk operations in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of bulk operations."""
  nodes: [BulkOperation!]!
}

"""All valid states a bulk operation can be in."""
enum BulkOperationState {
  """The bulk operation is still processing on some changesets."""
  PROCESSING

  """
  No operations are still running and all of them finished without error.
  """
  COMPLETED

  """
  No operations are still running and at least one of them finished with an error.
  """
  FAILED
}

"""The available types of jobs that can be run over a batch change."""
enum BulkOperationType {
  """Bulk post comments over all involved changesets."""
  COMMENT

  """Bulk detach changesets from a batch change."""
  DETACH

  """Bulk reenqueue failed changesets."""
  REENQUEUE

  """Bulk merge changesets."""
  MERGE

  """Bulk close changesets."""
  CLOSE

  """Bulk publish changesets."""
  PUBLISH
}

"""A status message of a permissions sync job cancellation."""
enum CancelPermissionsSyncJobResultMessage {
  SUCCESS
  NOT_FOUND
  ERROR
}

"""A changeset on a codehost."""
interface Changeset {
  """The unique ID for the changeset."""
  id: ID!

  """The batch changes that contain this changeset."""
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!

  """The state of the changeset."""
  state: ChangesetState!

  """The date and time when the changeset was created."""
  createdAt: DateTime!

  """The date and time when the changeset was updated."""
  updatedAt: DateTime!

  """
  The date and time when the next changeset sync is scheduled, or null if none is scheduled.
  """
  nextSyncAt: DateTime
}

"""
A preview for which actions applyBatchChange would result in when called at the point of time this preview was created at.
"""
union ChangesetApplyPreview = VisibleChangesetApplyPreview | HiddenChangesetApplyPreview

"""A list of preview entries."""
type ChangesetApplyPreviewConnection {
  """The total number of entries in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of preview entries."""
  nodes: [ChangesetApplyPreview!]!

  """
  Stats on the elements in this connnection. Does not respect pagination parameters.
  """
  stats: ChangesetApplyPreviewConnectionStats!
}

"""Aggregated stats on nodes in this connection."""
type ChangesetApplyPreviewConnectionStats {
  """The amount of new commits from the batch change in this operation."""
  push: Int!

  """
  The amount of existing changeset that will be updated from the batch change in this operation.
  """
  update: Int!

  """
  The amount of changesets that will be un-drafted from the batch change in this operation.
  """
  undraft: Int!

  """
  The amount of changesets that will be pubished from the batch change in this operation.
  """
  publish: Int!

  """
  The amount of changesets that will be published as a draft from the batch change in this operation.
  """
  publishDraft: Int!

  """
  The amount of changesets that will be synced from the batch change in this operation.
  """
  sync: Int!

  """
  The amount of changesets that will be imported from the batch change in this operation.
  """
  import: Int!

  """
  The amount of changesets that will be closed from the batch change in this operation.
  """
  close: Int!

  """
  The amount of changesets that will be re-opened from the batch change in this operation.
  """
  reopen: Int!

  """Internal operation to get around slow code host updates."""
  sleep: Int!

  """
  The amount of changesets that will be removed from the batch change in this operation.
  """
  detach: Int!

  """
  The amount of changesets that will be archived from the batch change in this operation.
  """
  archive: Int!

  """
  The amount of changesets that are added to the batch change in this operation.
  """
  added: Int!

  """
  The amount of changesets that are already attached to the batch change and modified in this operation.
  """
  modified: Int!

  """
  The amount of changesets that are disassociated from the batch change in this operation.
  """
  removed: Int!

  """
  The amount of changesets that will be re-added from the batch change in this operation.
  """
  reattach: Int!
}

"""The state of checks (e.g., for continuous integration) on a changeset."""
enum ChangesetCheckState {
  PENDING
  PASSED
  FAILED
}

"""A list of changesets."""
type ChangesetConnection {
  """A list of changesets."""
  nodes: [Changeset!]!

  """The total number of changesets in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
The counts of changesets in certain states at a specific point in time.
"""
type ChangesetCounts {
  """The point in time these counts were recorded."""
  date: DateTime!

  """The total number of changesets."""
  total: Int!

  """The number of merged changesets."""
  merged: Int!

  """The number of closed changesets."""
  closed: Int!

  """The number of draft changesets (independent of review state)."""
  draft: Int!

  """The number of open changesets (independent of review state)."""
  open: Int!

  """The number of changesets that are both open and approved."""
  openApproved: Int!

  """
  The number of changesets that are both open and have requested changes.
  """
  openChangesRequested: Int!

  """The number of changesets that are both open and are pending review."""
  openPending: Int!
}

"""
All possible types of changesets that can be specified in a changeset spec.
"""
union ChangesetDescription = ExistingChangesetReference | GitBranchChangesetDescription

"""
A changeset event in a code host (e.g., a comment on a pull request on GitHub).
"""
type ChangesetEvent implements Node {
  """The unique ID for the changeset event."""
  id: ID!

  """The changeset this event belongs to."""
  changeset: ExternalChangeset!

  """The date and time when the changeset was created."""
  createdAt: DateTime!
}

"""A list of changeset events."""
type ChangesetEventConnection {
  """A list of changeset events."""
  nodes: [ChangesetEvent!]!

  """The total number of changeset events in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The state of a changeset on the code host on which it's hosted."""
enum ChangesetExternalState {
  DRAFT
  OPEN
  CLOSED
  MERGED
  READONLY
  DELETED
}

"""A reported error on a changeset in a bulk operation."""
type ChangesetJobError {
  """The changeset this error is related to."""
  changeset: Changeset!

  """
  The error message. Null, if the changeset is not accessible by the requesting
  user.
  """
  error: String
}

"""A label attached to a changeset on a code host."""
type ChangesetLabel {
  """The label's text."""
  text: String!

  """
  The label's color, as a hex color code without the . For example: "93ba13".
  """
  color: String!

  """An optional description of the label."""
  description: String
}

"""The publication state of a changeset on Sourcegraph"""
enum ChangesetPublicationState {
  """The changeset has not yet been created on the code host."""
  UNPUBLISHED

  """The changeset has been created on the code host."""
  PUBLISHED
}

"""The reconciler state of a changeset on Sourcegraph"""
enum ChangesetReconcilerState {
  """
  The changeset is scheduled, and will be enqueued when its turn comes in Sourcegraph's rollout window.
  """
  SCHEDULED

  """The changeset is enqueued for the reconciler to process it."""
  QUEUED

  """
  The changeset reconciler is currently computing the delta between the
  If a delta exists, the reconciler tries to update the state of the
  changeset on the code host and on Sourcegraph to the desired state.
  """
  PROCESSING

  """
  The changeset reconciler ran into a problem while processing the
  changeset and will retry it for a number of retries.
  """
  ERRORED

  """
  The changeset reconciler ran into a problem while processing the
  changeset that can't be fixed by retrying.
  """
  FAILED

  """The changeset is not enqueued for processing."""
  COMPLETED
}

"""The review state of a changeset."""
enum ChangesetReviewState {
  APPROVED
  CHANGES_REQUESTED
  PENDING
  COMMENTED
  DISMISSED
}

"""
A changeset spec is an immutable description of the desired state of a changeset in a batch change. To
create a changeset spec, use the createChangesetSpec mutation.
"""
interface ChangesetSpec {
  """
  The unique ID for a changeset spec.
  
  The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
  even though repository permissions also apply to viewers of changeset specs, because being
  allowed to view a repository should not entitle a person to view all not-yet-published
  changesets for that repository. Consider a batch change to fix a security vulnerability: the
  batch change author may prefer to prepare all of the changesets in private so that the window
  between revealing the problem and merging the fixes is as short as possible.
  """
  id: ID!

  """The type of changeset spec."""
  type: ChangesetSpecType!

  """
  The date, if any, when this changeset spec expires and is automatically purged. A changeset
  spec never expires (and this field is null) if its batch spec has been applied.
  """
  expiresAt: DateTime
}

"""A list of changeset specs."""
type ChangesetSpecConnection {
  """The total number of changeset specs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!

  """A list of changeset specs."""
  nodes: [ChangesetSpec!]!
}

"""
Description of the current changeset state vs the changeset spec desired state.
"""
type ChangesetSpecDelta {
  """When run, the title of the changeset will be updated."""
  titleChanged: Boolean!

  """When run, the body of the changeset will be updated."""
  bodyChanged: Boolean!

  """When run, the changeset will be taken out of draft mode."""
  undraft: Boolean!

  """When run, the target branch of the changeset will be updated."""
  baseRefChanged: Boolean!

  """When run, a new commit will be created on the branch of the changeset."""
  diffChanged: Boolean!

  """When run, a new commit will be created on the branch of the changeset."""
  commitMessageChanged: Boolean!

  """
  When run, a new commit in the name of the specified author will be created on the branch of the changeset.
  """
  authorNameChanged: Boolean!

  """
  When run, a new commit in the name of the specified author will be created on the branch of the changeset.
  """
  authorEmailChanged: Boolean!
}

"""This enum declares all operations supported by the reconciler."""
enum ChangesetSpecOperation {
  """Push a new commit to the code host."""
  PUSH

  """
  Update the existing changeset on the codehost. This is purely the changeset resource on the code host,
  not the git commit. For updates to the commit, see 'PUSH'.
  """
  UPDATE

  """Move the existing changeset out of being a draft."""
  UNDRAFT

  """Publish a changeset to the codehost."""
  PUBLISH

  """
  Publish a changeset to the codehost as a draft changeset. (Only on supported code hosts).
  """
  PUBLISH_DRAFT

  """Sync the changeset with the current state on the codehost."""
  SYNC

  """
  Import an existing changeset from the code host with the ExternalID from the spec.
  """
  IMPORT

  """Close the changeset on the codehost."""
  CLOSE

  """Reopen the changeset on the codehost."""
  REOPEN

  """Internal operation to get around slow code host updates."""
  SLEEP

  """The changeset is removed from some of the associated batch changes."""
  DETACH

  """
  The changeset is kept in the batch change, but it's marked as archived.
  """
  ARCHIVE

  """The changeset is re-added to the batch change."""
  REATTACH
}

"""
A ChangesetSpecPublicationStateInput is a tuple containing a changeset spec ID
and its desired UI publication state.
"""
input ChangesetSpecPublicationStateInput {
  """The changeset spec ID."""
  changesetSpec: ID!

  """The desired publication state."""
  publicationState: PublishedValue!
}

"""The type of the changeset spec."""
enum ChangesetSpecType {
  """References an existing changeset on a code host to be imported."""
  EXISTING

  """
  References a branch and a patch to be applied to create the changeset from.
  """
  BRANCH
}

"""Used in the batch change page for the overview component."""
type ChangesetsStats {
  """The count of unpublished changesets."""
  unpublished: Int!

  """The count of draft changesets."""
  draft: Int!

  """The count of open changesets."""
  open: Int!

  """The count of merged changesets."""
  merged: Int!

  """The count of closed changesets."""
  closed: Int!

  """The count of deleted changesets."""
  deleted: Int!

  """The count of changesets in retrying state."""
  retrying: Int!

  """The count of changesets in failed state."""
  failed: Int!

  """The count of changesets in the scheduled state."""
  scheduled: Int!

  """
  The count of changesets that are currently processing or enqueued to be.
  """
  processing: Int!

  """The count of archived changesets."""
  archived: Int!

  """The count of all changesets."""
  total: Int!

  """
  If true, then all changesets are either merged or closed. This indicates that the batch change is completed.
  """
  isCompleted: Boolean!

  """
  The count of changesets that are complete (i.e in a merged or closed state) and not archived or deleted.
  """
  percentComplete: Int!
}

"""The visual state a changeset is currently in."""
enum ChangesetState {
  """The changeset has not been marked as to be published."""
  UNPUBLISHED

  """
  The changeset reconciler ran into a problem while processing the
  changeset that can't be fixed by retrying.
  """
  FAILED

  """
  The changeset reconciler ran into a problem while processing the
  changeset and will retry it for a number of retries.
  """
  RETRYING

  """
  The changeset is scheduled, and will be enqueued when its turn comes in Sourcegraph's rollout window.
  """
  SCHEDULED

  """
  The changeset reconciler is currently computing the delta between the
  If a delta exists, the reconciler tries to update the state of the
  changeset on the code host and on Sourcegraph to the desired state.
  """
  PROCESSING

  """
  The changeset is published, not being reconciled and open on the code host.
  """
  OPEN

  """
  The changeset is published, not being reconciled and in draft state on the code host.
  """
  DRAFT

  """
  The changeset is published, not being reconciled and closed on the code host.
  """
  CLOSED

  """
  The changeset is published, not being reconciled and merged on the code host.
  """
  MERGED

  """
  The changeset is published, and is now read-only, most likely due to the
  repository being archived.
  """
  READONLY

  """
  The changeset is published, not being reconciled and has been deleted on the code host.
  """
  DELETED
}

"""The result for Mutation.checkMirrorRepositoryConnection."""
type CheckMirrorRepositoryConnectionResult {
  """
  The error message encountered during the update operation, if any. If null, then
  the connection check succeeded.
  """
  error: String
}

"""A set of matched ranges contained in a chunk of contiguous lines."""
type ChunkMatch {
  """The contiguous set of full lines which contain the matches in ranges."""
  content: String!

  """The location of the beginning of content."""
  contentStart: Position!

  """The set of ranges within the content that matched the search query."""
  ranges: [Range!]!
}

"""
Configuration details for the browser extension, editor extensions, etc.
"""
type ClientConfigurationDetails {
  """
  The list of phabricator/gitlab/bitbucket/etc instance URLs that specifies
  which pages the content script will be injected into.
  """
  contentScriptUrls: [String!]!

  """Returns details about the parent Sourcegraph instance."""
  parentSourcegraph: ParentSourcegraphDetails!
}

"""The clone status of a repository."""
enum CloneStatus {
  NOT_CLONED
  CLONING
  CLONED
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories are being
cloned
"""
type CloningProgress {
  """The message of this status message"""
  message: String!
}

"""
Describes the state of a provider (code host) during a permission sync job.
"""
type CodeHostState {
  """ID of a permissions provider (code host)."""
  providerID: String!

  """Permissions provider (code host) type."""
  providerType: String!

  """Status of permission sync of a given provider."""
  status: CodeHostStatus!

  """Status message."""
  message: String!
}

"""
Describes the status of a permissions sync for a given provider (code host).
"""
enum CodeHostStatus {
  SUCCESS
  ERROR
}

"""A Code Intel Commit."""
type CodeIntelCommit {
  """The globally addressable ID for this commit."""
  id: ID!

  """This commit's Git object ID (OID), a 40-character SHA-1 hash."""
  oid: GitObjectID!

  """The abbreviated form of this commit's OID."""
  abbreviatedOID: String!

  """
  The URL to this commit (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """The repository that contains this commit."""
  repository: CodeIntelRepository!
}

"""
A repository on an external service (such as GitHub, GitLab, Phabricator, etc.).
"""
type CodeIntelExternalRepository {
  """
  The type of external service where this repository resides.
  Example: "github", "gitlab", etc.
  """
  serviceType: String!

  """
  The particular instance of the external service where this repository resides. Its value is
  opaque but typically consists of the canonical base URL to the service.
  Example: For GitHub.com, this is "https://github.com/".
  """
  serviceID: String!
}

"""A gitblob resolver specific to code intel."""
type CodeIntelGitBlob {
  """The full path (relative to the root) of this tree."""
  path: String!

  """The base name (i.e., last path component only) of this tree."""
  name: String!

  """The Git commit containing this tree."""
  commit: CodeIntelCommit!

  """
  The URL to this tree (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """The repository containing this tree."""
  repository: CodeIntelRepository!

  """The content of this blob."""
  content(
    """
    Return file content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return file content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!
}

"""
A git object that matches a git object type and glob pattern. This type is used by
the UI to preview what names match a code intelligence policy in a given repository.
"""
type CodeIntelGitObject {
  """The relevant branch or tag name."""
  name: String!

  """The full 40-char revhash."""
  rev: String!

  """The time that the underlying commit was created."""
  committedAt: DateTime!
}

"""A Code Intel Git Tree."""
type CodeIntelGitTree {
  """The full path (relative to the root) of this tree."""
  path: String!

  """The base name (i.e., last path component only) of this tree."""
  name: String!

  """The Git commit containing this tree."""
  commit: CodeIntelCommit!

  """
  The URL to this tree (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """The repository containing this tree."""
  repository: CodeIntelRepository!

  """The content of this blob."""
  content(
    """
    Return file content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return file content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!
}

"""Describes a precise code-intel indexer."""
type CodeIntelIndexer {
  """The language ecosystem that this indexer supports."""
  key: String!

  """Name of the precise code-intel indexer."""
  name: String!

  """
  URL to the source of the indexer e.g. https://github.com/sourcegraph/lsif-go
  """
  url: String!

  """
  A Docker image name used to distribute the indexer to the executor for via auto-indexing.
  """
  imageName: String
}

"""
Information and status related to the commit graph of this repository calculated
for use by code intelligence features.
"""
type CodeIntelligenceCommitGraph {
  """Whether or not the commit graph needs to be updated."""
  stale: Boolean!

  """When, if ever, the commit graph was last refreshed."""
  updatedAt: DateTime
}

"""
A configuration policy that applies to a set of Git objects matching an associated
pattern. Each policy has optional data retention and auto-indexing schedule configuration
attached. A policy can be applied globally or on a per-repository basis.
"""
type CodeIntelligenceConfigurationPolicy implements Node {
  """The ID."""
  id: ID!

  """A description of the configuration policy."""
  name: String!

  """The repository to which this configuration policy applies."""
  repository: CodeIntelRepository

  """
  The set of name patterns matching repositories to which this configuration policy applies.
  """
  repositoryPatterns: [String!]

  """The type of Git object described by the configuration policy."""
  type: GitObjectType!

  """A pattern matching the name of the matching Git object."""
  pattern: String!

  """Protected policies may not be deleted (or created directly by users)."""
  protected: Boolean!

  """Whether or not this configuration policy affects data retention rules."""
  retentionEnabled: Boolean!

  """The max age of data retained by this configuration policy."""
  retentionDurationHours: Int

  """
  If the matching Git object is a branch, setting this value to true will also
  retain all data used to resolve queries for any commit on the matching branches.
  Setting this value to false will only consider the tip of the branch.
  """
  retainIntermediateCommits: Boolean!

  """
  Whether or not this configuration policy affects auto-indexing schedules.
  """
  indexingEnabled: Boolean!

  """The max age of commits indexed by this configuration policy."""
  indexCommitMaxAgeHours: Int

  """
  If the matching Git object is a branch, setting this value to true will also
  index all commits on the matching branches. Setting this value to false will
  only consider the tip of the branch.
  """
  indexIntermediateCommits: Boolean!

  """Whether or not this configuration policy affects embeddings."""
  embeddingsEnabled: Boolean!
}

"""A list of code intelligence configuration policies."""
type CodeIntelligenceConfigurationPolicyConnection {
  """A list of code intelligence configuration policies."""
  nodes: [CodeIntelligenceConfigurationPolicy!]!

  """The total number of policies in this result set."""
  totalCount: Int

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Aggregate code intelligence for a particular range within a document."""
type CodeIntelligenceRange {
  """The range this code intelligence applies to."""
  range: Range!

  """A list of definitions of the symbol occurring within the range."""
  definitions: LocationConnection!

  """A list of references of the symbol occurring within the range."""
  references: LocationConnection!

  """A list of implementations of the symbol occurring within the range."""
  implementations: LocationConnection!

  """The hover result of the symbol occurring within the range."""
  hover: Hover
}

"""
Aggregate local code intelligence for all ranges that fall between a window of lines in a document.
"""
type CodeIntelligenceRangeConnection {
  """Aggregate local code intelligence grouped by range."""
  nodes: [CodeIntelligenceRange!]!
}

"""A retention policy match candidate."""
type CodeIntelligenceRetentionPolicyMatch {
  """The actual retention policy."""
  configurationPolicy: CodeIntelligenceConfigurationPolicy

  """
  Whether the retention policy matches the upload or not. False values may be returned
  if non-matching policies are requested for inclusion.
  """
  matches: Boolean!

  """
  A list of commits that are visible to this upload for which this retention policy applies.
  It is empty if the policy applies directly to the commit associated with the upload.
  """
  protectingCommits: [String!]
}

"""A list of code intelligence retention policy match candidates."""
type CodeIntelligenceRetentionPolicyMatchesConnection {
  """A list of code intelligence retention policies matches."""
  nodes: [CodeIntelligenceRetentionPolicyMatch!]!

  """The total number of policies in this result set."""
  totalCount: Int

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
A codeintel repository is a Git source control repository that is mirrored from
some origin code host and it is specific to code intel.
"""
type CodeIntelRepository {
  """The globally addressable ID for this commit."""
  id: ID!

  """
  The repository's name, as a path with one or more components. It conventionally consists of
  the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
  Examples:
  - github.com/foo/bar
  - my-code-host.example.com/myrepo
  - myrepo
  """
  name: String!

  """The URL to this repository."""
  url: String!

  """
  Information about this repository from the external service that it originates from (such as GitHub, GitLab,
  Phabricator, etc.). Only populated when used as part of repository list previews for configuration policies.
  """
  externalRepository: CodeIntelExternalRepository
}

"""A summary of the most recent upload and index status."""
type CodeIntelRepositorySummary {
  """
  A list of recent precise indexes for a specific repository. This list contains processing,
  recently queued, and the most recently processed precise indexes for each distinct indexer
  and root.
  """
  recentActivity: [PreciseIndex!]!

  """
  The last time uploads of this repository were checked against data retention policies.
  """
  lastUploadRetentionScan: DateTime

  """
  The last time this repository was considered for auto-indexing job scheduling.
  """
  lastIndexScan: DateTime

  """
  The additionally available indexers that could be indexed but haven't been indexed.
  """
  availableIndexers: [InferredAvailableIndexers!]!

  """
  If inference of the repository contents hit a limit its error description will available here.
  """
  limitError: String
}

"""
A repository paired with a list of precise indexers (used by CodeIntelSummary).
"""
type CodeIntelRepositoryWithConfiguration {
  """The repository."""
  repository: CodeIntelRepository!

  """The precise indexers available for the repository."""
  indexers: [IndexerWithCount!]!
}

"""
A list of repositories paired with a list of precise indexers (used by CodeIntelSummary).
"""
type CodeIntelRepositoryWithConfigurationConnection {
  """The repository and indexer count."""
  nodes: [CodeIntelRepositoryWithConfiguration!]!

  """The total number of results (over all pages) in this list."""
  totalCount: Int

  """Metadata about the current page of results."""
  pageInfo: PageInfo!
}

"""
A repository paired with a count of precise indexing errors (used by CodeIntelSummary).
"""
type CodeIntelRepositoryWithError {
  """The repository."""
  repository: CodeIntelRepository!

  """The number of precise indexing errors in the repository."""
  count: Int!
}

"""
A list of repositories paired with a count of precise indexing errors (used by CodeIntelSummary).
"""
type CodeIntelRepositoryWithErrorConnection {
  """The repository and error count."""
  nodes: [CodeIntelRepositoryWithError!]!

  """The total number of results (over all pages) in this list."""
  totalCount: Int

  """Metadata about the current page of results."""
  pageInfo: PageInfo!
}

"""A summary of code intelligence on the instance."""
type CodeIntelSummary {
  """The number of repositories with precise index records."""
  numRepositoriesWithCodeIntelligence: Int!

  """A list of repositories with precise index errors."""
  repositoriesWithErrors(
    """
    When specified, indicates that this request should be paginated and
    the first N results (relative to the cursor) should be returned. i.e.
    how many results to return per page.
    """
    first: Int

    """
    When specified, indicates that this request should be paginated and
    to fetch results starting at this cursor.
    
    A future request can be made for more results by passing in the
    'CodeIntelRepositoryWithErrorConnection.pageInfo.endCursor'
    that is returned.
    """
    after: String
  ): CodeIntelRepositoryWithErrorConnection!

  """A list of repositories with configurable auto-indexing jobs."""
  repositoriesWithConfiguration(
    """
    When specified, indicates that this request should be paginated and
    the first N results (relative to the cursor) should be returned. i.e.
    how many results to return per page.
    """
    first: Int

    """
    When specified, indicates that this request should be paginated and
    to fetch results starting at this cursor.
    
    A future request can be made for more results by passing in the
    'CodeIntelRepositoryWithErrorConnection.pageInfo.endCursor'
    that is returned.
    """
    after: String
  ): CodeIntelRepositoryWithConfigurationConnection
}

"""
The entity is an owner because they were manually assigned as an owner.
"""
type CodeownersFileEntry {
  """Descriptive title to display in the UI for the determination."""
  title: String!

  """More detailed description to display in the UI for the determination."""
  description: String!

  """
  Either GitBlob or VirtualFile. This points to the CODEOWNERS file that yielded the
  determination.
  """
  codeownersFile: File2!

  """The line in the CODEOWNERS file that matched for this determination."""
  ruleLineMatch: Int!
}

"""
CodeownersFileInput represents the input for ingesting codeowners files
"""
input CodeownersFileInput {
  """fileContents is the text of the codeowners file"""
  fileContents: String!

  """The repo ID to ingest the file for. Cannot be set with repositoryName."""
  repoID: ID

  """The repo name to ingest the file for. Cannot be set with repositoryID."""
  repoName: String
}

"""CodeownersIngestedFile represents a manually ingested Codeowners file."""
type CodeownersIngestedFile implements Node {
  """A graphql ID for this file."""
  id: ID!

  """The string contents of the codeowners file."""
  contents: String!

  """The repository this codeowners file has been manually ingested for."""
  repository: Repository!

  """The creation date of this codeowners file."""
  createdAt: DateTime!

  """The last updated date of this codeowners file."""
  updatedAt: DateTime!
}

"""A list of CodeownersIngestedFiles."""
type CodeownersIngestedFileConnection {
  """The total count of items in the connection."""
  totalCount: Int!

  """The pagination info for the connection."""
  pageInfo: PageInfo!

  """The current page of codeowners files in this connection."""
  nodes: [CodeownersIngestedFile!]!
}

"""
EXPERIMENTAL: A single piece of context. It's defined as a union so we can
return other types of context in the future (think code intel definition
or wiki page).
"""
union CodyContextResult = FileChunkContext

"""
Cody Gateway access granted to a subscription.
FOR INTERNAL USE ONLY.
"""
type CodyGatewayAccess {
  """Whether or not a subscription has Cody Gateway access."""
  enabled: Boolean!

  """Rate limit for chat completions access, or null if not enabled."""
  chatCompletionsRateLimit: CodyGatewayRateLimit

  """Rate limit for code completions access, or null if not enabled."""
  codeCompletionsRateLimit: CodyGatewayRateLimit

  """Rate limit for embedding text chunks, or null if not enabled."""
  embeddingsRateLimit: CodyGatewayRateLimit
}

"""
A dotcom user allowed to access the Cody Gateway
FOR INTERNAL USE ONLY.
"""
type CodyGatewayDotcomUser {
  """The user name of the user"""
  username: String!

  """
  Cody Gateway access granted to this user. Properties may be inferred from
  dotcom site config, or be defined in overrides on the user.
  """
  codyGatewayAccess: CodyGatewayAccess!
}

"""
Cody Gateway access rate limits for a subscription.
FOR INTERNAL USE ONLY.
"""
type CodyGatewayRateLimit {
  """The source of the rate limit configuration."""
  source: CodyGatewayRateLimitSource!

  """
  The models that are allowed for this rate limit bucket.
  Usually, customers will have two separate rate limits, one
  for chat completions and one for code completions. A usual
  config could include:
  
      chatCompletionsRateLimit: {
          allowedModels: [anthropic/claude-v1, anthropic/claude-v1.3]
      },
      codeCompletionsRateLimit: {
          allowedModels: [anthropic/claude-instant-v1]
      }
  
  In general, the model names are of the format "$PROVIDER/$MODEL_NAME".
  """
  allowedModels: [String!]!

  """Requests per time interval."""
  limit: BigInt!

  """Interval for rate limiting."""
  intervalSeconds: Int!

  """Recent usage data of Cody Gateway for the subscription."""
  usage: [CodyGatewayUsageDatapoint!]!
}

"""
The source of the rate limit returned.
FOR INTERNAL USE ONLY.
"""
enum CodyGatewayRateLimitSource {
  """Indicates that a custom override for the rate limit has been stored."""
  OVERRIDE

  """
  Indicates that the rate limit is inferred by the subscriptions active plan.
  """
  PLAN
}

"""A usage data point of Cody Gateway usage of a subscription."""
type CodyGatewayUsageDatapoint {
  """The day the usage occurred."""
  date: DateTime!

  """The number of requests made."""
  count: BigInt!

  """The model that was used."""
  model: String!
}

"""A search result that is a Git commit."""
type CommitSearchResult implements GenericSearchResultInterface {
  """A markdown string that is rendered prominently."""
  label: Markdown!

  """The URL of the result."""
  url: String!

  """A markdown string of that is rendered less prominently."""
  detail: Markdown!

  """The result previews of the result."""
  matches: [SearchResultMatch!]!

  """The commit that matched the search query."""
  commit: GitCommit!

  """The ref names of the commit."""
  refs: [GitRef!]!

  """The refs by which this commit was reached."""
  sourceRefs: [GitRef!]!

  """The matching portion of the commit message, if any."""
  messagePreview: HighlightedString

  """The matching portion of the diff, if any."""
  diffPreview: HighlightedString
}

"""
Commit signing configuration for a code host, e.g. GitHubApp or SSHKey. Today, the
only supported form of commit signing is via a GitHub App.
"""
union CommitSigningConfiguration = GitHubApp

"""Input wrapper for completions"""
input CompletionsInput {
  """List of conversation messages"""
  messages: [Message!]!

  """Temperature for sampling - higher means more random completions"""
  temperature: Float!

  """Maximum number of tokens to sample"""
  maxTokensToSample: Int!

  """Number of highest probability completions to return"""
  topK: Int!

  """Probability threshold for inclusion in results"""
  topP: Int!
}

"""
An entry in match environment is a variable with a value spanning a range. Variable names correspond to
a variable names in a pattern metasyntax. For regular expression patterns, named capture groups will use the variable
specified. For unnamed capture groups, variable names correspond to capture '1', '2', etc.
"""
type ComputeEnvironmentEntry {
  """The variable name."""
  variable: String!

  """The value associated with this variable."""
  value: String!

  """The absolute range spanned by this value in the input."""
  range: Range!
}

"""
Represents a value matched within file content, and an environment of submatches
within this value corresponding to an input pattern (e.g., regular expression
capture groups).
"""
type ComputeMatch {
  """The string value"""
  value: String!

  """The range of this value within the file."""
  range: Range!

  """The environment of submatches within value."""
  environment: [ComputeEnvironmentEntry]!
}

"""
The result of matching data that satisfy a search pattern, including an environment of submatches.
"""
type ComputeMatchContext {
  """The repository."""
  repository: Repository!

  """The commit."""
  commit: String!

  """The file path."""
  path: String!

  """Computed match results"""
  matches: [ComputeMatch]!
}

"""A compute operation result."""
union ComputeResult = ComputeMatchContext | ComputeText

"""
A general computed result for arbitrary textual data. A result optionally
specifies a related repository, commit, file path, or the kind of textual data.
"""
type ComputeText {
  """The repository."""
  repository: Repository

  """The commit."""
  commit: String

  """The file path."""
  path: String

  """
  An arbitrary label communicating the kind of data the value represents.
  """
  kind: String

  """The computed value."""
  value: String!
}

"""
DEPRECATED: Use the contents field on the parent type instead. This type will be removed in a future release.
"""
type Configuration {
  """
  DEPRECATED: This field will be removed in a future release.
  The raw JSON contents, encoded as a string.
  """
  contents: JSONCString! @deprecated(reason: "use the contents field on the parent type instead")

  """
  DEPRECATED: This field is always empty. It will be removed in a future release.
  """
  messages: [String!]! @deprecated(reason: "use client-side JSON Schema validation instead")
}

"""DEPRECATED: Renamed to SettingsCascade."""
type ConfigurationCascade {
  """DEPRECATED"""
  subjects: [SettingsSubject!]! @deprecated(reason: "use SettingsCascade.subjects instead")

  """DEPRECATED"""
  merged: Configuration! @deprecated(reason: "use SettingsCascade.final instead")
}

"""
DEPRECATED: This type was renamed to SettingsEdit.
NOTE: GraphQL does not support @deprecated directives on INPUT_FIELD_DEFINITION (input fields).
"""
input ConfigurationEdit {
  """DEPRECATED"""
  keyPath: [KeyPathSegment!]!

  """DEPRECATED"""
  value: JSONValue

  """DEPRECATED"""
  valueIsJSONCEncodedString: Boolean = false
}

"""An object with totalCount and PageInfo."""
interface Connection {
  """The total count of items in the connection."""
  totalCount: Int!

  """The pagination info for the connection."""
  pageInfo: ConnectionPageInfo!
}

"""Pagination information."""
type ConnectionPageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backward, the cursor to continue."""
  startCursor: String

  """When paginating backward, are there more items?"""
  hasPreviousPage: Boolean!
}

"""The result for Mutation.createAccessToken."""
type CreateAccessTokenResult {
  """The ID of the newly created access token."""
  id: ID!

  """
  The secret token value that is used to authenticate API clients. The caller is responsible for storing this
  value.
  """
  token: String!
}

"""
CreateFileBlockInput contains the information necessary to create a file block.
"""
input CreateFileBlockInput {
  """Name of the repository, e.g. "github.com/sourcegraph/sourcegraph"."""
  repositoryName: String!

  """Path within the repository, e.g. "client/web/file.tsx"."""
  filePath: String!

  """
  An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
  If omitted, we use the latest revision (HEAD).
  """
  revision: String

  """An optional line range. If omitted, we display the entire file."""
  lineRange: CreateFileBlockLineRangeInput
}

"""Input to create a line range for a file block."""
input CreateFileBlockLineRangeInput {
  """The first line to fetch (0-indexed, inclusive)."""
  startLine: Int!

  """The last line to fetch (0-indexed, exclusive)."""
  endLine: Int!
}

"""Input object for creating a new dashboard."""
input CreateInsightsDashboardInput {
  """Dashboard title."""
  title: String!

  """Permissions to grant to the dashboard."""
  grants: InsightsPermissionGrantsInput!
}

"""
GraphQL does not accept union types as inputs, so we have to use
all possible optional inputs with an enum to select the actual block input we want to use.
"""
input CreateNotebookBlockInput {
  """ID of the block."""
  id: String!

  """Block type."""
  type: NotebookBlockType!

  """Markdown input."""
  markdownInput: String

  """Query input."""
  queryInput: String

  """File input."""
  fileInput: CreateFileBlockInput

  """Symbol input."""
  symbolInput: CreateSymbolBlockInput
}

"""
CreateSymbolBlockInput contains the information necessary to create a symbol block.
"""
input CreateSymbolBlockInput {
  """Name of the repository, e.g. "github.com/sourcegraph/sourcegraph"."""
  repositoryName: String!

  """Path within the repository, e.g. "client/web/file.tsx"."""
  filePath: String!

  """
  An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
  If omitted, we use the latest revision (HEAD).
  """
  revision: String

  """Number of lines to show before and after the matched symbol line."""
  lineContext: Int!

  """The symbol name."""
  symbolName: String!

  """Name of the symbol container."""
  symbolContainerName: String!

  """The symbol kind."""
  symbolKind: SymbolKind!
}

"""The result for Mutation.createUser."""
type CreateUserResult {
  """The new user."""
  user: User!

  """
  The reset password URL that the new user must visit to sign into their account. If the builtin
  username-password authentication provider is not enabled, this field's value is null.
  
  If email sending (SMTP) is configured on this instance and an email was provided, an email
  containing this URL will also be sent to the primary email address associated with the user.
  """
  resetPasswordURL: String
}

"""
An RFC 3339-encoded UTC date string, such as 1973-11-29T21:33:09Z. This value can be parsed into a
JavaScript Date using Date.parse. To produce this value from a JavaScript Date instance, use
Date#toISOString.
"""
scalar DateTime

"""
The default settings for the Sourcegraph instance. This is hardcoded in
Sourcegraph, but may change from release to release.
"""
type DefaultSettings implements SettingsSubject {
  """The opaque GraphQL ID."""
  id: ID!

  """The latest default settings (this never changes)."""
  latestSettings: Settings

  """
  The URL to the default settings. This URL does not exist because you
  cannot edit or directly view default settings.
  """
  settingsURL: String

  """
  Whether the viewer can modify the subject's settings. Always false for
  default settings.
  """
  viewerCanAdminister: Boolean!

  """
  The default settings, and the final merged settings.
  All viewers can access this field.
  """
  settingsCascade: SettingsCascade!

  """DEPRECATED"""
  configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
}

"""
A repository to pass to the deleteCodeownersFiles mutation. Either repoID or repoName
must be provided.
"""
input DeleteCodeownersFilesInput {
  """The repo ID to ingest the file for. Cannot be set with repositoryName."""
  repoID: ID

  """The repo name to ingest the file for. Cannot be set with repositoryID."""
  repoName: String
}

"""Represents a diagnostic, such as a compiler error or warning."""
type Diagnostic {
  """The location at which the message applies."""
  location: Location!

  """The diagnostic's severity."""
  severity: DiagnosticSeverity

  """The diagnostic's code as provided by the tool."""
  code: String

  """
  A human-readable string describing the source of this
  diagnostic, e.g. "typescript" or "super lint".
  """
  source: String

  """The diagnostic's message."""
  message: String
}

"""A list of diagnostics."""
type DiagnosticConnection {
  """A list of diagnostics."""
  nodes: [Diagnostic!]!

  """
  The total count of diagnostics (which may be larger than nodes.length if the connection is paginated).
  """
  totalCount: Int

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Represents the severity level of a diagnostic."""
enum DiagnosticSeverity {
  ERROR
  WARNING
  INFORMATION
  HINT
}

"""A diff between two diffable Git objects."""
type Diff {
  """The diff's repository."""
  repository: Repository!

  """The revision range of the diff."""
  range: GitRevisionRange!
}

"""The type of content in a hunk line."""
enum DiffHunkLineType {
  """Added line."""
  ADDED

  """Unchanged line."""
  UNCHANGED

  """Deleted line."""
  DELETED
}

"""Statistics about a diff."""
type DiffStat {
  """Number of lines added."""
  added: Int!

  """Number of lines deleted."""
  deleted: Int!
}

"""
Mutations that are only used on Sourcegraph.com.
FOR INTERNAL USE ONLY.
"""
type DotcomMutation {
  """
  Creates new product subscription for an account.
  Only Sourcegraph.com site admins may perform this mutation.
  FOR INTERNAL USE ONLY.
  """
  createProductSubscription(
    """
    The ID of the user (i.e., customer) to whom this product subscription is assigned.
    """
    accountID: ID!
  ): ProductSubscription!

  """
  Generates and signs a new product license and associates it with an existing product subscription. The
  product license key is signed with Sourcegraph.com's private key and is verifiable with the corresponding
  public key.
  Only Sourcegraph.com site admins may perform this mutation.
  FOR INTERNAL USE ONLY.
  """
  generateProductLicenseForSubscription(
    """The product subscription to associate with the license."""
    productSubscriptionID: ID!

    """The license to generate."""
    license: ProductLicenseInput!
  ): ProductLicense!

  """Revokes an existing product license, rendering it invalid."""
  revokeLicense(
    """The UUID of the license to revoke"""
    id: ID!

    """Reason for revoking of the license"""
    reason: String!
  ): EmptyResponse!

  """
  Applies a partial update to a product subscription.
  
  Only Sourcegraph.com site admins may perform this mutation.
  FOR INTERNAL USE ONLY.
  """
  updateProductSubscription(
    """The product subscription ID to update."""
    id: ID!

    """Partial update to apply."""
    update: UpdateProductSubscriptionInput!
  ): EmptyResponse!

  """
  Archives an existing product subscription.
  Only Sourcegraph.com site admins may perform this mutation.
  FOR INTERNAL USE ONLY.
  """
  archiveProductSubscription(
    """The product subscription to archive."""
    id: ID!
  ): EmptyResponse!
}

"""
Mutations that are only used on Sourcegraph.com.
FOR INTERNAL USE ONLY.
"""
type DotcomQuery {
  """
  The product subscription with the given UUID. An error is returned if no such product
  subscription exists.
  Only Sourcegraph.com site admins and the account owners of the product subscription may
  perform this query.
  FOR INTERNAL USE ONLY.
  """
  productSubscription(uuid: String!): ProductSubscription!

  """
  The access available to the product subscription with the given access token.
  The returned ProductSubscription may be archived or not associated with an active license.
  
  Only Sourcegraph.com site admins, the account owners of the product subscription, and
  specific service accounts may perform this query.
  FOR INTERNAL USE ONLY.
  """
  productSubscriptionByAccessToken(accessToken: String!): ProductSubscription!

  """
  A list of product subscriptions.
  FOR INTERNAL USE ONLY.
  """
  productSubscriptions(
    """Returns the first n product subscriptions from the list."""
    first: Int

    """
    Returns only product subscriptions for the given account.
    Only Sourcegraph.com site admins may perform this query with account == null.
    """
    account: ID

    """
    Returns product subscriptions from users with usernames or email addresses that match the query.
    """
    query: String
  ): ProductSubscriptionConnection!

  """
  A list of product licenses.
  Only Sourcegraph.com site admins may perform this query.
  FOR INTERNAL USE ONLY.
  """
  productLicenses(
    """Returns the first n product subscriptions from the list."""
    first: Int

    """
    Returns only product subscriptions whose license key contains this substring.
    """
    licenseKeySubstring: String

    """Returns only product licenses associated with the given subscription"""
    productSubscriptionID: ID
  ): ProductLicenseConnection!

  """
  A dotcom user for purposes of connecting to the Cody Gateway.
  Only Sourcegraph.com site admins or service accounts may perform this query.
  Token is a Cody Gateway token, not a Sourcegraph instance access token.
  FOR INTERNAL USE ONLY.
  """
  codyGatewayDotcomUserByToken(token: String!): CodyGatewayDotcomUser
}

"""A single embeddings search result."""
type EmbeddingsSearchResult {
  """The name of the repository containing the search result."""
  repoName: String!

  """The commitID of the repository containing the search result."""
  revision: String!

  """The search result file name."""
  fileName: String!

  """The start line of the content (inclusive)."""
  startLine: Int!

  """The end line of the content (exclusive)."""
  endLine: Int!

  """The content of the file from start line to end line."""
  content: String!
}

"""
Embeddings search results. Contains a list of code results and a list of text results.
"""
type EmbeddingsSearchResults {
  """A list of code file results."""
  codeResults: [EmbeddingsSearchResult!]!

  """A list of text file results."""
  textResults: [EmbeddingsSearchResult!]!
}

"""Represents a null return value."""
type EmptyResponse {
  """A dummy null value."""
  alwaysNil: String
}

"""
This type is not returned by any resolver, but serves to document what an error
response will look like.
"""
type Error {
  """A string giving more context about the error that occurred."""
  message: String!

  """
  The GraphQL path to where the error happened. For an error in the query
  query {
      user {
          externalID # This is a nullable field that failed computing.
      }
  }
  the path would be ["user", "externalID"].
  """
  path: [String!]!

  """Optional additional context on the error."""
  extensions: ErrorExtensions
}

"""
Optional additional context on an error returned from a resolver.
It may also contain more properties, which aren't strictly typed here.
"""
type ErrorExtensions {
  """
  An error code, which can be asserted on.
  Possible error codes are communicated in the doc string of the field.
  """
  code: String
}

"""
An evaluated feature flag is any feature flag (static or random) that has been evaluated to
a concrete value for a given viewer.
"""
type EvaluatedFeatureFlag {
  """The name of the feature flag"""
  name: String!

  """The concrete evaluated value of the feature flag"""
  value: Boolean!
}

"""A description of a user event."""
input Event {
  """The name of the event."""
  event: String!

  """The randomly generated unique user ID stored in a browser cookie."""
  userCookieID: String!

  """
  The first sourcegraph URL visited by the user, stored in a browser cookie.
  """
  firstSourceURL: String

  """
  The last sourcegraph URL visited by the user, stored in a browser cookie.
  """
  lastSourceURL: String

  """The URL when the event was logged."""
  url: String!

  """The source of the event."""
  source: EventSource!

  """
  An optional cohort ID to identify the user as part of a specific A/B test.
  The cohort ID is expected to be a date in the form YYYY-MM-DD
  """
  cohortID: String

  """
  An optional referrer parameter for the user's current session.
  Only captured and stored on Sourcegraph Cloud.
  """
  referrer: String

  """The original referrer for a user"""
  originalReferrer: String

  """The session referrer for a user"""
  sessionReferrer: String

  """The sessions first url for a user"""
  sessionFirstURL: String

  """Device session ID to identify the user's session for analytics."""
  deviceSessionID: String

  """The additional argument information."""
  argument: String

  """
  Public argument information. PRIVACY: Do NOT include any potentially private information in this field.
  These properties get sent to our analytics tools for Cloud, so must not include private information,
  such as search queries or repository names.
  """
  publicArgument: String

  """
  Device ID used for Amplitude analytics. Used on Sourcegraph Cloud only.
  """
  deviceID: String

  """
  Event ID used to deduplicate events that occur simultaneously in Amplitude analytics.
  See https://developers.amplitude.com/docs/http-api-v2#optional-keys. Used on Sourcegraph Cloud only.
  """
  eventID: Int

  """
  Insert ID used to deduplicate events that re-occur in the event of retries or
  backfills in Amplitude analytics. See https://developers.amplitude.com/docs/http-api-v2#optional-keys.
  Used on Sourcegraph Cloud only.
  """
  insertID: String
}

"""A single user event that has been logged."""
type EventLog {
  """The name of the event."""
  name: String!

  """The user who executed the event, if one exists."""
  user: User

  """The randomly generated unique user ID stored in a browser cookie."""
  anonymousUserID: String!

  """The URL when the event was logged."""
  url: String!

  """The source of the event."""
  source: EventSource!

  """The additional argument information."""
  argument: String

  """The Sourcegraph version when the event was logged."""
  version: String!

  """The timestamp when the event was logged."""
  timestamp: DateTime!
}

"""A list of event logs."""
type EventLogsConnection {
  """A list of event logs."""
  nodes: [EventLog!]!

  """
  The total count of event logs in the connection. This total count may be larger than the number of nodes
  in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The product sources where events can come from."""
enum EventSource {
  WEB
  CODEHOSTINTEGRATION
  BACKEND
  STATICWEB
  IDEEXTENSION
  CODY
}

"""Supported status of monitor events."""
enum EventStatus {
  PENDING
  SUCCESS
  ERROR
}

"""
A description of a command run inside the executor to during processing of the parent record.
"""
type ExecutionLogEntry {
  """An internal tag used to correlate this log entry with other records."""
  key: String!

  """The arguments of the command run inside the executor."""
  command: [String!]!

  """The date when this command started."""
  startTime: DateTime!

  """
  The exit code of the command. Null, if the command has not finished yet.
  """
  exitCode: Int

  """The combined stdout and stderr logs of the command."""
  out: String!

  """
  The duration in milliseconds of the command. Null, if the command has not finished yet.
  """
  durationMilliseconds: Int
}

"""An active executor compute instance."""
type Executor implements Node {
  """The unique identifier of this executor."""
  id: ID!

  """The hostname of the executor instance."""
  hostname: String!

  """The queue name that the executor polls for work."""
  queueName: String

  """The queue name that the executor polls for work."""
  queueNames: [String!]

  """
  Active is true, if a heartbeat from the executor has been received at most three heartbeat intervals ago.
  """
  active: Boolean!

  """The operating system running the executor."""
  os: String!

  """The machine architecture running the executor."""
  architecture: String!

  """The version of Git used by the executor."""
  dockerVersion: String!

  """The version of the executor."""
  executorVersion: String!

  """The version of Docker used by the executor."""
  gitVersion: String!

  """The version of Ignite used by the executor."""
  igniteVersion: String!

  """The version of src-cli used by the executor."""
  srcCliVersion: String!

  """
  The first time the executor sent a heartbeat to the Sourcegraph instance.
  """
  firstSeenAt: DateTime!

  """
  The last time the executor sent a heartbeat to the Sourcegraph instance.
  """
  lastSeenAt: DateTime!

  """
  The compatibility of the executor with respect to the Sourcegraph instance.
  If outdated, please make sure that the executor and the Sourcegraph backend
  are of compatible versions. This means they should match in major and minor
  version, but they may be 1 minor version apart.
  If too new, please update the Sourcegraph instance to match the version of the executor or downgrade the executor.
  
  Compatibility can be null if the executor or Sourcegraph instance runs in dev mode or there's a version mismatch.
  """
  compatibility: ExecutorCompatibility
}

"""The compatibility of the executor with the sourcegraph instance."""
enum ExecutorCompatibility {
  """
  Executor version is more than one version behind the Sourcegraph instance.
  """
  OUTDATED

  """Executor is up-to-date with the Sourcegraph instance."""
  UP_TO_DATE

  """
  Executor version is more than one version ahead of the Sourcegraph instance.
  """
  VERSION_AHEAD
}

"""A list of active executors compute instances."""
type ExecutorConnection {
  """A list of executors."""
  nodes: [Executor!]!

  """The total number of executors in this result set."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A secret to be used in executor jobs."""
type ExecutorSecret implements Node {
  """The unique identifier of the secret."""
  id: ID!

  """
  The key under which the secret is available. Secrets are usually exposed
  as environment variables named using this key.
  Recommended format: uppercase letters, numbers and underscores.
  """
  key: String!

  """
  The scope of this secret. The secret will only be usable for jobs in this
  particular scope.
  """
  scope: ExecutorSecretScope!

  """
  If true, this secret is defined in a namespace and a secret with the same key
  is also defined in the global namespace, which this secret overwrites.
  """
  overwritesGlobalSecret: Boolean!

  """
  The namespace this secret belongs to. Null, if a global secret.
  Global secrets are available to every execution.
  """
  namespace: Namespace

  """The creator of the secret. Null, if the creator has been deleted."""
  creator: User

  """The date and time this secret has been created."""
  createdAt: DateTime!

  """The date and time this secret has been last updated."""
  updatedAt: DateTime!

  """
  The list of access events to this secret. Every time the secret value is
  decoded and used, one of these entries is created.
  """
  accessLogs(
    """Only return N records."""
    first: Int = 50

    """Opaque cursor for pagination."""
    after: String
  ): ExecutorSecretAccessLogConnection!
}

"""
An access log entry for an executor secret.
These are created every time the secret value is decoded.
"""
type ExecutorSecretAccessLog implements Node {
  """The unique identifier of the log entry."""
  id: ID!

  """The secret that this log entry belongs to."""
  executorSecret: ExecutorSecret!

  """
  The user in which name the secret has been used.
  This is null when the access was not by a user account, or
  when the user account was deleted.
  """
  user: User

  """True when the secret was accessed by an internal procedure."""
  machineUser: String!

  """The date and time when the secret has been used."""
  createdAt: DateTime!
}

"""A list of executor secret access logs."""
type ExecutorSecretAccessLogConnection {
  """A list of access logs."""
  nodes: [ExecutorSecretAccessLog!]!

  """The total number of records in this result set."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A list of executor secrets."""
type ExecutorSecretConnection {
  """A list of executor secrets."""
  nodes: [ExecutorSecret!]!

  """The total number of records in this result set."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Enum of the possible scopes for executor secrets."""
enum ExecutorSecretScope {
  """The secret is meant to be used with Batch Changes execution."""
  BATCHES

  """The secret is meant to be used with Auto-indexing."""
  CODEINTEL
}

"""Information regarding the results of an exhaustive search aggregation"""
type ExhaustiveSearchAggregationResult {
  """A list of the first [LIMIT] aggregation groups in decreasing order"""
  groups: [AggregationGroup!]!

  """
  Boolean indicating if the search query supports being persisted as an insight on a dashboard
  """
  supportsPersistence: Boolean

  """
  A count to capture the number of results that are not included in the list of groups returned.
  This includes result counts for groups that were excluded due to the requested limit
  """
  otherResultCount: Int

  """
  A count to represent the number of aggregation groups that were not returned due to the requested LIMIT
  """
  otherGroupCount: Int

  """The SearchAggregationMode the results relate to"""
  mode: SearchAggregationMode!
}

"""
A reference to a changeset that already exists on a code host (and was not created by the
batch change).
"""
type ExistingChangesetReference {
  """The repository that contains the existing changeset on the code host."""
  baseRepository: Repository!

  """
  The ID that uniquely identifies the existing changeset on the code host.
  
  For GitHub and Bitbucket Server, this is the pull request number (as a string) in the
  base repository. For example, "1234" for PR 1234.
  """
  externalID: String!
}

"""An external account associated with a user."""
type ExternalAccount implements Node {
  """The unique ID for the external account."""
  id: ID!

  """The user on Sourcegraph."""
  user: User!

  """The type of the external service where the external account resides."""
  serviceType: String!

  """
  An identifier for the external service where the external account resides.
  """
  serviceID: String!

  """
  An identifier for the client of the external service where the external account resides. This distinguishes
  among multiple authentication providers that access the same service with different parameters.
  """
  clientID: String!

  """
  An identifier for the external account (typically equal to or derived from the ID on the external service).
  """
  accountID: String!

  """The creation date of this external account on Sourcegraph."""
  createdAt: DateTime!

  """The last-updated date of this external account on Sourcegraph."""
  updatedAt: DateTime!

  """A URL that, when visited, re-initiates the authentication process."""
  refreshURL: String

  """
  Provider-specific data about the external account.
  Only site admins may query this field.
  """
  accountData: JSONValue

  """
  Public provider-specific data about the external account.
  Only users that are linked to the external account and site admins
  may query this field.
  """
  publicAccountData: PublicExternalAccountData
}

"""A list of external accounts."""
type ExternalAccountConnection {
  """A list of external accounts."""
  nodes: [ExternalAccount!]!

  """
  The total count of external accounts in the connection. This total count may be larger than the number of nodes
  in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A changeset on a code host (e.g., a pull request on GitHub)."""
type ExternalChangeset implements Node & Changeset {
  """The unique ID for the changeset."""
  id: ID!

  """
  The external ID that uniquely identifies this ExternalChangeset on the
  code host. For example, on GitHub this is the pull request number. This is
  only set once the changeset is published on the code host.
  """
  externalID: String

  """The repository changed by this changeset."""
  repository: Repository!

  """The batch changes that contain this changeset."""
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!

  """
  The batch change that "owns" this changeset: If this is null, it is imported/tracked by a batch change.
  """
  ownedByBatchChange: ID

  """The events belonging to this changeset."""
  events(first: Int = 50, after: String): ChangesetEventConnection!

  """The date and time when the changeset was created."""
  createdAt: DateTime!

  """The date and time when the changeset was updated."""
  updatedAt: DateTime!

  """
  The date and time when the next changeset sync is scheduled, or null if none
  is scheduled or when the initial sync hasn't happened.
  """
  nextSyncAt: DateTime

  """
  The time the changeset is expected to be enqueued at. This is an estimate, and
  may change depending on other code host and Batch Changes activity.
  
  Null if the changeset is not currently scheduled.
  """
  scheduleEstimateAt: DateTime

  """
  The title of the changeset, or null if the data hasn't been synced from the code host yet.
  """
  title: String

  """
  The body of the changeset, or null if the data hasn't been synced from the code host yet.
  """
  body: String

  """
  The author of the changeset, or null if the data is unavailable or hasn't been synced
  from the code host yet.
  
  Note that author is not fully supported by some code host APIs:
  * GitHub - only author.name
  * GitLab - only author.name
  * Bitbucket Server - author is not always available
  * Bitbucket Cloud - author is never available
  * Azure DevOps - author is always available
  """
  author: Person

  """The state of the changeset."""
  state: ChangesetState!

  """The labels attached to the changeset on the code host."""
  labels: [ChangesetLabel!]!

  """
  The external URL of the changeset on the code host. Not set when changeset
  state is UNPUBLISHED, externalState is DELETED, or the changeset's data hasn't
  been synced yet.
  """
  externalURL: ExternalLink

  """
  If the changeset was opened from a fork, this is the namespace of the fork
  (which will generally correspond to a user or organisation name on the code
  host).
  """
  forkNamespace: String

  """
  If the changeset was opened from a fork, this is the name of the fork repository.
  """
  forkName: String

  """
  The review state of this changeset. This is only set once the changeset is published on the code host.
  
  Note: The COMMENTED and DISMISSED review states are not yet implemented.
  """
  reviewState: ChangesetReviewState

  """
  The diff of this changeset, or null if the changeset is closed (without merging) or is already merged.
  """
  diff: RepositoryComparisonInterface

  """
  The diffstat of this changeset, or null if the changeset is closed
  (without merging) or is already merged. This data is also available
  indirectly through the diff field above, but if only the diffStat is
  required, this field is cheaper to access.
  """
  diffStat: DiffStat

  """
  The state of the checks (e.g., for continuous integration) on this changeset, or null if no
  checks have been configured.
  """
  checkState: ChangesetCheckState

  """
  An error that has occurred when publishing or updating the changeset. This is
  only set when the changeset state is ERRORED and the viewer can administer
  this changeset.
  """
  error: String

  """
  An error that has occured during the last sync of the changeset. Null, if was successful.
  """
  syncerError: String

  """
  The current changeset spec for this changeset. Use this to get access to the
  workspace execution that generated this changeset.
  
  Null if the changeset was only imported.
  """
  currentSpec: VisibleChangesetSpec
}

"""
A URL to a resource on an external service, such as the URL to a repository on its external (origin) code host.
"""
type ExternalLink {
  """The URL to the resource."""
  url: String!

  """
  The kind of external service, such as "GITHUB", or null if unknown/unrecognized. This is used solely for
  displaying an icon that represents the service.
  """
  serviceKind: ExternalServiceKind

  """
  The type of external service, such as "github", or null if unknown/unrecognized. This is used solely for
  displaying an icon that represents the service.
  """
  serviceType: String @deprecated(reason: "use name serviceKind instead")
}

"""
A repository on an external service (such as GitHub, GitLab, Phabricator, etc.).
"""
type ExternalRepository {
  """
  The repository's ID on the external service.
  Example: For GitHub, this is the GitHub GraphQL API's node ID for the repository.
  """
  id: String!

  """
  The type of external service where this repository resides.
  Example: "github", "gitlab", etc.
  """
  serviceType: String!

  """
  The particular instance of the external service where this repository resides. Its value is
  opaque but typically consists of the canonical base URL to the service.
  Example: For GitHub.com, this is "https://github.com/".
  """
  serviceID: String!
}

"""A configured external service."""
type ExternalService implements Node {
  """The external service's unique ID."""
  id: ID!

  """The kind of external service."""
  kind: ExternalServiceKind!

  """The display name of the external service."""
  displayName: String!

  """The JSON configuration of the external service."""
  config: JSONCString!

  """When the external service was created."""
  createdAt: DateTime!

  """When the external service was last updated."""
  updatedAt: DateTime!

  """The number of repos synced by the external service."""
  repoCount: Int!

  """
  An optional URL that will be populated when webhooks have been configured for the external service.
  """
  webhookURL: String

  """
  This is an optional field that's populated when we ran into errors on the
  backend side when trying to create/update an ExternalService, but the
  create/update still succeeded.
  It is a field on ExternalService instead of a separate thing in order to
  not break the API and stay backwards compatible.
  """
  warning: String

  """
  External services are synced with code hosts in the background. This optional field
  will contain any errors that occurred during the most recent completed sync.
  """
  lastSyncError: String

  """
  LastSyncAt is the time the last sync job was run for this code host. Null if it
  has never been synced so far.
  """
  lastSyncAt: DateTime

  """
  The timestamp of the next sync job. Null if not scheduled for a re-sync.
  """
  nextSyncAt: DateTime

  """
  Returns recently received webhooks on this external service.
  
  Only site admins may access this field.
  
  DEPRECATED: Webhook logs linked directly to an external service will be removed. See
  https://docs.sourcegraph.com/admin/config/webhooks/incoming#deprecation-notice
  """
  webhookLogs(
    """Returns the first n webhook logs."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Only include webhook logs that resulted in errors."""
    onlyErrors: Boolean

    """Only include webhook logs on or after this time."""
    since: DateTime

    """Only include webhook logs on or before this time."""
    until: DateTime
  ): WebhookLogConnection! @deprecated(reason: "Webhook logs linked directly to an external service will be removed. See https://docs.sourcegraph.com/admin/config/webhooks/incoming#deprecation-notice")

  """The list of recent sync jobs for this external service."""
  syncJobs(first: Int): ExternalServiceSyncJobConnection!

  """Checks the availability of the external service."""
  checkConnection: ExternalServiceAvailability!

  """
  True if this external service can perform availability check by running checkConnection.
  
  If this is false, then checkConnection responds with ExternalServiceAvailabilityUnknown.
  """
  hasConnectionCheck: Boolean!

  """
  True if this external service configuration supports `exclude` parameter.
  """
  supportsRepoExclusion: Boolean!
}

"""
Availability status of an external service for diagnostic purposes.

This is so that the UI can surface whether the external service
can serve requests, and if not, why is the reason for that.
"""
union ExternalServiceAvailability = ExternalServiceAvailable | ExternalServiceUnavailable | ExternalServiceAvailabilityUnknown

"""
Availability for some external services may not be determined, or only partially
supported. In that case unknown variant of ExternalServiceAvailability is returned.
"""
type ExternalServiceAvailabilityUnknown {
  """
  User-friendly textual description of the implementation status of availability.
  This is expected to be tied to specific kinds of external services.
  """
  implementationNote: String!
}

"""
Indicator that the external service was recently found to be available.
"""
type ExternalServiceAvailable {
  """
  The timestamp of the last successful availability check that was performed.
  """
  lastCheckedAt: DateTime!
}

"""A list of external services."""
type ExternalServiceConnection {
  """A list of external services."""
  nodes: [ExternalService!]!

  """The total number of external services in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A specific kind of external service."""
enum ExternalServiceKind {
  AWSCODECOMMIT
  AZUREDEVOPS
  BITBUCKETCLOUD
  BITBUCKETSERVER
  GERRIT
  GITHUB
  GITLAB
  GITOLITE
  GOMODULES
  JVMPACKAGES
  NPMPACKAGES
  OTHER
  LOCALGIT
  PAGURE
  PERFORCE
  PHABRICATOR
  PYTHONPACKAGES
  RUSTPACKAGES
  RUBYPACKAGES
}

"""
A namespace sourced from a defined external service (such as GitHub, GitLab, Phabricator, etc.) that can be discovered
before any sync or mirror operations.
"""
type ExternalServiceNamespace {
  """The unique identifier of the external service namespace."""
  id: ID!

  """The name of the external service namespace."""
  name: String!

  """
  The Namespace's ID on the external service.
  Example: For GitHub, this is the GitHub GraphQL API's node ID for the organization.
  """
  externalID: String!
}

"""A list of namespaces available to an external service configuration."""
type ExternalServiceNamespaceConnection {
  """
  A list of namespaces available on the source.
  Namespaces are used to organize which members and users can access repositories
  and are defined by external service kind (e.g. Github organizations, Bitbucket projects, etc.)
  """
  nodes: [ExternalServiceNamespace!]!

  """The total number of source repos in the connection."""
  totalCount: Int!
}

"""
A repository sourced from a defined external service (such as GitHub, GitLab, Phabricator, etc.) that can be discovered
before any sync or mirror operations.
"""
type ExternalServiceRepository {
  """The unique identifier of the external service repository."""
  id: ID!

  """The name of the external service repository."""
  name: String!

  """
  The repository's ID on the external service.
  Example: For GitHub, this is the GitHub GraphQL API's node ID for the repository.
  """
  externalID: String!
}

"""A list of repositories available to an external service configuration."""
type ExternalServiceRepositoryConnection {
  """A list of repositories available on the source."""
  nodes: [ExternalServiceRepository!]!
}

"""
External services count information includes a count of services for remote code host connections and a count of services
for local code host connections (local is only supported for Sourcegraph App).
"""
type ExternalServicesCounts {
  """
  The count of external services configured for remote code host connections.
  """
  remoteExternalServicesCount: Int!

  """
  The count of external services configured for local code host connections.
  """
  localExternalServicesCount: Int!
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories could not
be synced from an external service
"""
type ExternalServiceSyncError {
  """The message of this status message"""
  message: String!

  """The external service that failed to sync"""
  externalService: ExternalService!
}

"""
An external service sync job represents one sync with the code host. It's a background
job that will eventually be run by the repo syncer.
"""
type ExternalServiceSyncJob implements Node {
  """The unique identifier of the sync job."""
  id: ID!

  """The current state of the sync job."""
  state: ExternalServiceSyncJobState!

  """When the sync job was added to the queue."""
  queuedAt: DateTime!

  """Set when sync begins."""
  startedAt: DateTime

  """Set when sync finished."""
  finishedAt: DateTime

  """Error message, if the sync failed."""
  failureMessage: String

  """The number of repos synced during this sync job."""
  reposSynced: Int!

  """
  The number of times an error occurred syncing a repo during this sync job.
  """
  repoSyncErrors: Int!

  """The number of new repos discovered during this sync job."""
  reposAdded: Int!

  """The number of repos deleted as a result of this sync job."""
  reposDeleted: Int!

  """
  The number of existing repos whose metadata has changed during this sync job.
  """
  reposModified: Int!

  """
  The number of existing repos whose metadata did not change during this sync job.
  """
  reposUnmodified: Int!
}

"""A list of external service sync jobs."""
type ExternalServiceSyncJobConnection {
  """A list of sync jobs."""
  nodes: [ExternalServiceSyncJob!]!

  """The total number of jobs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The possible states of an external service sync job."""
enum ExternalServiceSyncJobState {
  """Not yet started. Will be picked up by a worker eventually."""
  QUEUED

  """Currently syncing."""
  PROCESSING

  """An error occurred while syncing. Will be retried eventually."""
  ERRORED

  """A fatal error occurred while syncing. No retries will be made."""
  FAILED

  """Sync finished successfully."""
  COMPLETED

  """Sync job is being canceled."""
  CANCELING

  """Sync job has been canceled."""
  CANCELED
}

"""Indicator that the external service was recently not found available."""
type ExternalServiceUnavailable {
  """
  User-friendly textual description of supposed reason why the service is not available.
  """
  suspectedReason: String!
}

"""
A feature flag is either a static boolean feature flag or a rollout feature flag
"""
union FeatureFlag = FeatureFlagBoolean | FeatureFlagRollout

"""A feature flag that has a statically configured value"""
type FeatureFlagBoolean {
  """The name of the feature flag"""
  name: String!

  """The static value of the feature flag"""
  value: Boolean!

  """Overrides that apply to the feature flag"""
  overrides: [FeatureFlagOverride!]!

  """When the feature flag was created."""
  createdAt: DateTime!

  """When the feature flag was last updated."""
  updatedAt: DateTime!
}

"""
A feature flag override is an override of a feature flag's value for a specific org or user
"""
type FeatureFlagOverride {
  """A unique ID for this feature flag override"""
  id: ID!

  """The namespace for this override. Will always be a user or org."""
  namespace: Namespace!

  """The name of the feature flag being overridden"""
  targetFlag: FeatureFlag!

  """The overridden value of the feature flag"""
  value: Boolean!
}

"""
A feature flag that is randomly evaluated to a boolean based on the rollout parameter
"""
type FeatureFlagRollout {
  """The name of the feature flag"""
  name: String!

  """
  The ratio of users that will be assigned this this feature flag, expressed in
  basis points (0.01%).
  """
  rolloutBasisPoints: Int!

  """Overrides that apply to the feature flag"""
  overrides: [FeatureFlagOverride!]!

  """When the feature flag was created."""
  createdAt: DateTime!

  """When the feature flag was last updated."""
  updatedAt: DateTime!
}

"""Additional options when performing a permissions sync."""
input FetchPermissionsOptions {
  """
  Indicate that any caches added for optimization encountered during this permissions
  sync should be invalidated.
  """
  invalidateCaches: Boolean
}

"""
File is temporarily preserved for backcompat with browser extension search API client code.
"""
type File {
  """The full path (relative to the repository root) of this file."""
  path: String!

  """The base name (i.e., file name only) of this file's path."""
  name: String!

  """Whether this is a directory."""
  isDirectory: Boolean!

  """The URL to this file on Sourcegraph."""
  url: String!

  """The repository that contains this file."""
  repository: Repository!
}

"""
A file.
In a future version of Sourcegraph, a repository's files may be distinct from a repository's blobs
(for example, to support searching/browsing generated files that aren't committed and don't exist
as Git blobs). Clients should generally use the GitBlob concrete type and GitCommit.blobs (not
GitCommit.files), unless they explicitly want to opt-in to different behavior in the future.
INTERNAL: This is temporarily named File2 during a migration. Do not refer to the name File2 in
any API clients as the name will change soon.
"""
interface File2 {
  """The full path (relative to the root) of this file."""
  path: String!

  """The base name (i.e., file name only) of this file."""
  name: String!

  """False because this is a file, not a directory."""
  isDirectory: Boolean!

  """The content of this file."""
  content(
    """
    Return file content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return file content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """The file size in bytes."""
  byteSize: Int!

  """Total line count for the file. Returns 0 for binary files."""
  totalLines: Int!

  """Whether or not it is binary."""
  binary: Boolean!

  """
  The file rendered as rich HTML, or an empty string if it is not a supported
  rich file type.
  This HTML string is already escaped and thus is always safe to render.
  """
  richHTML(
    """
    Return richHTML content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return richHTML content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """
  The URL to this file (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this file (using an immutable revision specifier).
  """
  canonicalURL: String!

  """The URLs to this file on external services."""
  externalURLs: [ExternalLink!]!

  """Highlight the file."""
  highlight(
    disableTimeout: Boolean!
    isLightTheme: Boolean

    """
    If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
    2000 bytes is enabled. This may produce a significant amount of HTML
    which some browsers (such as Chrome, but not Firefox) may have trouble
    rendering efficiently.
    """
    highlightLongLines: Boolean = false

    """Specifies which format/highlighting technique to use."""
    format: HighlightResponseFormat = HTML_HIGHLIGHT

    """
    Return highlight content starting at line "startLine". A value <= 0 will be the start of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    startLine: Int

    """
    Return blob highlight ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    endLine: Int
  ): HighlightedFile!
}

"""
FileBlock specifies a file (or part of a file) to display within the block.
"""
type FileBlock {
  """ID of the block."""
  id: String!

  """File block input."""
  fileInput: FileBlockInput!
}

"""FileBlockInput contains the information necessary to fetch the file."""
type FileBlockInput {
  """Name of the repository, e.g. "github.com/sourcegraph/sourcegraph"."""
  repositoryName: String!

  """Path within the repository, e.g. "client/web/file.tsx"."""
  filePath: String!

  """
  An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
  If omitted, we use the latest revision (HEAD).
  """
  revision: String

  """An optional line range. If omitted, we display the entire file."""
  lineRange: FileBlockLineRange
}

"""A line range inside a file."""
type FileBlockLineRange {
  """The first line to fetch (0-indexed, inclusive)."""
  startLine: Int!

  """The last line to fetch (0-indexed, exclusive)."""
  endLine: Int!
}

"""
A piece of context that represents a chunk of a file in a git repository
"""
type FileChunkContext {
  """The git blob this file is associated with"""
  blob: GitBlob!

  """The start line of the relevant chunk (inclusive)."""
  startLine: Int!

  """The end line of the relevant chunk (exclusive)."""
  endLine: Int!

  """The relevant content of the file from start line to end line."""
  chunkContent: String!
}

"""A diff for a single file."""
type FileDiff {
  """The old (original) path of the file, or null if the file was added."""
  oldPath: String

  """
  The old file, or null if the file was created (oldFile.path == oldPath).
  """
  oldFile: File2

  """The new (changed) path of the file, or null if the file was deleted."""
  newPath: String

  """
  The new file, or null if the file was deleted (newFile.path == newPath).
  """
  newFile: File2

  """
  The old file (if the file was deleted) and otherwise the new file. This file field is typically used by
  clients that want to show a "View" link to the file.
  """
  mostRelevantFile: File2!

  """Hunks that were changed from old to new."""
  hunks: [FileDiffHunk!]!

  """The diff stat for the whole file."""
  stat: DiffStat!

  """
  FOR INTERNAL USE ONLY.
  An identifier for the file diff that is unique among all other file diffs in the list that
  contains it.
  """
  internalID: String!
}

"""A list of file diffs."""
type FileDiffConnection {
  """A list of file diffs."""
  nodes: [FileDiff!]!

  """
  The total count of file diffs in the connection, if available. This total count may be larger than the number
  of nodes in this object when the result is paginated.
  """
  totalCount: Int

  """Pagination information."""
  pageInfo: PageInfo!

  """
  The diff stat for the file diffs in this object, which may be a subset of the entire diff if the result is
  paginated.
  """
  diffStat: DiffStat!

  """
  The raw diff for the file diffs in this object, which may be a subset of the entire diff if the result is
  paginated.
  """
  rawDiff: String!
}

"""A changed region ("hunk") in a file diff."""
type FileDiffHunk {
  """The range of the old file that the hunk applies to."""
  oldRange: FileDiffHunkRange!

  """Whether the old file had a trailing newline."""
  oldNoNewlineAt: Boolean!

  """The range of the new file that the hunk applies to."""
  newRange: FileDiffHunkRange!

  """The diff hunk section heading, if any."""
  section: String

  """The hunk body, with lines prefixed with '-', '+', or ' '."""
  body: String!

  """Highlight the hunk."""
  highlight(
    disableTimeout: Boolean!
    isLightTheme: Boolean

    """
    If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
    2000 bytes is enabled. This may produce a significant amount of HTML
    which some browsers (such as Chrome, but not Firefox) may have trouble
    rendering efficiently.
    """
    highlightLongLines: Boolean = false

    """Specifies which format/highlighting technique to use."""
    format: HighlightResponseFormat = HTML_HIGHLIGHT
  ): HighlightedDiffHunkBody!
}

"""A hunk range in one side (old/new) of a diff."""
type FileDiffHunkRange {
  """The first line that the hunk applies to."""
  startLine: Int!

  """The number of lines that the hunk applies to."""
  lines: Int!
}

"""A file match."""
type FileMatch {
  """
  The file containing the match.
  KNOWN ISSUE: This file's "commit" field contains incomplete data.
  KNOWN ISSUE: This field's type should be File! not GitBlob!.
  """
  file: GitBlob!

  """The repository containing the file match."""
  repository: Repository!

  """
  The revspec of the revision that contains this match. If no revspec was given (such as when no
  repository filter or revspec is specified in the search query), it is null.
  """
  revSpec: GitRevSpec

  """The symbols found in this file that match the query."""
  symbols: [Symbol!]!

  """The line matches."""
  lineMatches: [LineMatch!]!

  """
  EXPERIMENTAL: This field is experimental and may be unstable.
  The chunk matches.
  """
  chunkMatches: [ChunkMatch!]!

  """Whether or not the limit was hit."""
  limitHit: Boolean!
}

"""
The target repository that a changeset will be pushed to, if it's not the origin
repository.
"""
type ForkTarget {
  """
  True if the remote target is a fork in the user namespace associated with
  the credential used to push the changeset.
  """
  pushUser: Boolean!

  """The specific named fork that the changeset will be pushed to."""
  namespace: String
}

"""
Represents a terminally incomplete data point at a specific time. Only returns
alerts that do not satisfy a specific implementation.
"""
type GenericIncompleteDatapointAlert implements IncompleteDatapointAlert {
  """The data point that is incomplete."""
  time: DateTime!

  """A message describing why the datapoint was marked incomplete."""
  reason: String!
}

"""
A search result. Every type of search result, except FileMatch, must implement this interface.
"""
interface GenericSearchResultInterface {
  """A markdown string that is rendered prominently."""
  label: Markdown!

  """The URL of the result."""
  url: String!

  """A markdown string that is rendered less prominently."""
  detail: Markdown!

  """A list of matches in this search result."""
  matches: [SearchResultMatch!]!
}

"""A Git blob in a repository."""
type GitBlob implements TreeEntry & File2 & Ownable {
  """The full path (relative to the repository root) of this blob."""
  path: String!

  """The base name (i.e., file name only) of this blob's path."""
  name: String!

  """False because this is a blob (file), not a directory."""
  isDirectory: Boolean!

  """The content of this blob."""
  content(
    """
    Return blob content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return blob content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """The file size in bytes."""
  byteSize: Int!

  """Total line count for the Blob. Returns 0 for binary files."""
  totalLines: Int!

  """Whether or not it is binary."""
  binary: Boolean!

  """
  The blob contents rendered as rich HTML, or an empty string if it is not a supported
  rich file type.
  This HTML string is already escaped and thus is always safe to render.
  """
  richHTML(
    """
    Return richHTML content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return richHTML content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """The Git commit containing this blob."""
  commit: GitCommit!

  """The repository containing this Git blob."""
  repository: Repository!

  """
  The URL to this blob (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this blob (using an immutable revision specifier).
  """
  canonicalURL: String!

  """The URLs to this blob on its repository's external services."""
  externalURLs: [ExternalLink!]!

  """Blame the blob."""
  blame(startLine: Int!, endLine: Int!): [Hunk!]!

  """Highlight the blob contents."""
  highlight(
    disableTimeout: Boolean!
    isLightTheme: Boolean

    """
    If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
    2000 bytes is enabled. This may produce a significant amount of HTML
    which some browsers (such as Chrome, but not Firefox) may have trouble
    rendering efficiently.
    """
    highlightLongLines: Boolean = false

    """Specifies which format/highlighting technique to use."""
    format: HighlightResponseFormat = HTML_HIGHLIGHT

    """
    Return highlight content starting at line "startLine". A value <= 0 will be the start of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    startLine: Int

    """
    Return highlight content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    endLine: Int
  ): HighlightedFile!

  """Submodule metadata if this tree points to a submodule"""
  submodule: Submodule

  """Symbols defined in this blob."""
  symbols(
    """Returns the first n symbols from the list."""
    first: Int

    """Return symbols matching the query."""
    query: String
  ): SymbolConnection!

  """
  EXPERIMENTAL: Symbol defined in this blob at the specific line number and character offset.
  """
  symbol(
    """The line number (0-based)."""
    line: Int!

    """
    The character offset (0-based). The offset is measured in characters, not bytes.
    """
    character: Int!
  ): Symbol

  """Always false, since a blob is a file, not directory."""
  isSingleChild(
    """Returns the first n files in the tree."""
    first: Int

    """Recurse into sub-trees."""
    recursive: Boolean = false

    """Recurse into sub-trees of single-child directories"""
    recursiveSingleChild: Boolean = false
  ): Boolean!

  """LFS is set if the GitBlob is a pointer to a file stored in LFS."""
  lfs: LFS

  """
  A wrapper around LSIF query methods. If no LSIF upload can be used to answer code
  intelligence queries for this path-at-revision, this resolves to null.
  """
  lsif(
    """
    An optional filter for the name of the tool that produced the upload data.
    """
    toolName: String
  ): GitBlobLSIFData

  """
  Provides code intelligence within the file.
  
  Experimental: This API is likely to change in the future.
  """
  localCodeIntel: JSONValue

  """
  A wrapper around syntactic hover and definition query methods.
  
  Experimental: This API is likely to change in the future.
  """
  symbolInfo(line: Int!, character: Int!): SymbolInfo

  """Ownership summary for this file."""
  ownership(
    """Returns the first n ownership records from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Return only ownership for the given reasons."""
    reasons: [OwnershipReasonType!]
  ): OwnershipConnection!
}

"""
A wrapper object around LSIF query methods for a particular git-blob-at-revision. When this node is
null, no LSIF data is available for the git blob in question.
"""
type GitBlobLSIFData implements TreeEntryLSIFData {
  """
  Return a flat list of all ranges in the document that have code intelligence.
  """
  stencil: [Range!]!

  """
  Get aggregated local code intelligence for all ranges that fall in the window
  indicated by the given zero-based start (inclusive) and end (exclusive) lines.
  The associated data for each range is "local", in that the locations and hover
  must also be defined in the same index as the source range. To get cross-repository
  and cross-bundle results, you must query the definitions, references, and hovers
  of that range explicitly.
  """
  ranges(startLine: Int!, endLine: Int!): CodeIntelligenceRangeConnection

  """A list of definitions of the symbol under the given document position."""
  definitions(
    """The line on which the symbol occurs (zero-based, inclusive)."""
    line: Int!

    """
    The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
    """
    character: Int!

    """When specified, it filters references by filename."""
    filter: String
  ): LocationConnection!

  """A list of references of the symbol under the given document position."""
  references(
    """The line on which the symbol occurs (zero-based, inclusive)."""
    line: Int!

    """
    The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
    """
    character: Int!

    """
    When specified, indicates that this request should be paginated and
    to fetch results starting at this cursor.
    A future request can be made for more results by passing in the
    'LocationConnection.pageInfo.endCursor' that is returned.
    """
    after: String

    """
    When specified, indicates that this request should be paginated and
    the first N results (relative to the cursor) should be returned. i.e.
    how many results to return per page.
    """
    first: Int

    """When specified, it filters references by filename."""
    filter: String
  ): LocationConnection!

  """
  A list of implementations of the symbol under the given document position.
  """
  implementations(
    """The line on which the symbol occurs (zero-based, inclusive)."""
    line: Int!

    """
    The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
    """
    character: Int!

    """
    When specified, indicates that this request should be paginated and
    to fetch results starting at this cursor.
    A future request can be made for more results by passing in the
    'LocationConnection.pageInfo.endCursor' that is returned.
    """
    after: String

    """
    When specified, indicates that this request should be paginated and
    the first N results (relative to the cursor) should be returned. i.e.
    how many results to return per page.
    """
    first: Int

    """When specified, it filters implementation by filename."""
    filter: String
  ): LocationConnection!

  """A list of prototypes of the symbol under the given document position."""
  prototypes(
    """The line on which the symbol occurs (zero-based, inclusive)."""
    line: Int!

    """
    The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
    """
    character: Int!

    """
    When specified, indicates that this request should be paginated and
    to fetch results starting at this cursor.
    A future request can be made for more results by passing in the
    'LocationConnection.pageInfo.endCursor' that is returned.
    """
    after: String

    """
    When specified, indicates that this request should be paginated and
    the first N results (relative to the cursor) should be returned. i.e.
    how many results to return per page.
    """
    first: Int

    """When specified, it filters prototypes by filename."""
    filter: String
  ): LocationConnection!

  """The hover result of the symbol under the given document position."""
  hover(
    """The line on which the symbol occurs (zero-based, inclusive)."""
    line: Int!

    """
    The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
    """
    character: Int!
  ): Hover

  """Code diagnostics provided through LSIF."""
  diagnostics(first: Int): DiagnosticConnection!

  """
  The indexes that could provide precise code intelligence for the current blob.
  """
  visibleIndexes: [PreciseIndex!]

  """
  SCIP snapshot data (similar to the additional information from the `scip snapshot` command) for each SCIP Occurrence.
  """
  snapshot(indexID: ID!): [SnapshotData!]
}

"""
A description of a changeset that represents the proposal to merge one branch into another.
This is used to describe a pull request (on GitHub and Bitbucket Server).
"""
type GitBranchChangesetDescription {
  """The repository that this changeset spec is proposing to change."""
  baseRepository: Repository!

  """
  The full name of the Git ref in the base repository that this changeset is based on (and is
  proposing to be merged into). This ref must exist on the base repository. For example,
  "refs/heads/master" or "refs/heads/main".
  """
  baseRef: String!

  """
  The base revision this changeset is based on. It is the latest commit in
  baseRef at the time when the changeset spec was created.
  For example: "4095572721c6234cd72013fd49dff4fb48f0f8a4"
  """
  baseRev: String!

  """
  The full name of the Git ref that holds the changes proposed by this changeset. This ref will
  be created or updated with the commits. For example, "refs/heads/fix-foo" (for
  the Git branch "fix-foo").
  """
  headRef: String!

  """
  The title of the changeset on the code host.
  
  On Bitbucket Server or GitHub this is the title of the pull request.
  """
  title: String!

  """
  The body of the changeset on the code host.
  
  On Bitbucket Server or GitHub this is the body/description of the pull request.
  """
  body: String!

  """
  The Git commits with the proposed changes. These commits are pushed to the head ref.
  
  Only 1 commit is supported.
  """
  commits: [GitCommitDescription!]!

  """The total diff of the changeset diff."""
  diff: PreviewRepositoryComparison!

  """
  The diffstat of this changeset spec. This data is also available
  indirectly through the diff field above, but if only the diffStat is
  required, this field is cheaper to access.
  """
  diffStat: DiffStat!

  """
  Whether or not the changeset described here should be created right after
  applying the ChangesetSpec this description belongs to.
  
  If this is false, the changeset will only be created on Sourcegraph and
  can be previewed.
  
  Another ChangesetSpec with the same description, but "published: true",
  can later be applied to publish the changeset.
  """
  published: PublishedValue
}

"""A Git commit."""
type GitCommit implements Node {
  """The globally addressable ID for this commit."""
  id: ID!

  """The repository that contains this commit."""
  repository: Repository!

  """This commit's Git object ID (OID), a 40-character SHA-1 hash."""
  oid: GitObjectID!

  """The abbreviated form of this commit's OID."""
  abbreviatedOID: String!

  """
  EXPERIMENTAL: The perforce changelist ID if this git commit was originally converted from a perforce depot.
  """
  perforceChangelist: PerforceChangelist

  """This commit's author."""
  author: Signature!

  """This commit's committer, if any."""
  committer: Signature

  """The full commit message."""
  message: String!

  """The first line of the commit message."""
  subject: String!

  """The contents of the commit message after the first line."""
  body: String

  """Parent commits of this commit."""
  parents: [GitCommit!]!

  """
  The URL to this commit (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this commit (using an immutable revision specifier).
  """
  canonicalURL: String!

  """The URLs to this commit on its repository's external services."""
  externalURLs: [ExternalLink!]!

  """The Git tree or blob in this commit at the given path."""
  path(
    """The path of the tree or blob."""
    path: String = ""
  ): GitTreeOrBlob

  """The Git tree in this commit at the given path."""
  tree(
    """The path of the tree."""
    path: String = ""

    """
    Whether to recurse into sub-trees. If true, it overrides the value of the "recursive" parameter on all of
    GitTree's fields.
    DEPRECATED: Use the "recursive" parameter on GitTree's fields instead.
    """
    recursive: Boolean = false
  ): GitTree

  """A list of file names in this repository."""
  fileNames: [String!]!

  """The Git blob in this commit at the given path."""
  blob(path: String!): GitBlob

  """
  The file at the given path for this commit.
  See "File" documentation for the difference between this field and the "blob" field.
  """
  file(path: String!): File2

  """Lists the programming languages present in the tree at this commit."""
  languages: [String!]!

  """List statistics for each language present in the repository."""
  languageStatistics: [LanguageStatistics!]!

  """The log of commits consisting of this commit and its ancestors."""
  ancestors(
    """Returns the first n commits from the list."""
    first: Int

    """Return commits that match the query."""
    query: String

    """Return commits that affect the path."""
    path: String

    """Follow history beyond renames (only works for a single file)."""
    follow: Boolean = false

    """Return commits more recent than the specified date."""
    after: String

    """
    Skip the first N commits of the repo before returning the number of commits as set in the field "first".
    """
    afterCursor: String

    """Return commits older than the specified date."""
    before: String
  ): GitCommitConnection!

  """
  Returns the number of commits that this commit is behind and ahead of revspec.
  """
  behindAhead(revspec: String!): BehindAheadCounts!

  """
  Symbols defined as of this commit. (All symbols, not just symbols that were newly defined in this commit.)
  """
  symbols(
    """Returns the first n symbols from the list."""
    first: Int

    """Return symbols matching the query."""
    query: String

    """
    A list of regular expressions, all of which must match all
    file paths returned in the list.
    """
    includePatterns: [String!]
  ): SymbolConnection!

  """Returns the comparison with another revision."""
  diff(
    """The base commit to compare to. Defaults to the commit's first parent."""
    base: String
  ): RepositoryComparison!

  """Owners of the repository at this commit."""
  ownership(
    """Returns the first n ownership records from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String
  ): OwnershipConnection!
}

"""A list of Git commits."""
type GitCommitConnection {
  """A list of Git commits."""
  nodes: [GitCommit!]!

  """
  The total number of Git commits in the connection. If the GitCommitConnection is paginated
  (e.g., because a "first" parameter was provided to the field that produced it), this field is
  null to avoid it taking unexpectedly long to compute the total count. Remove the pagination
  parameters to obtain a non-null value for this field.
  """
  totalCount: Int

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A description of a Git commit."""
type GitCommitDescription {
  """The full commit message."""
  message: String!

  """The first line of the commit message."""
  subject: String!

  """The contents of the commit message after the first line."""
  body: String

  """The Git commit author."""
  author: Person!

  """
  The commit diff (in unified diff format).
  
  The filenames must not be prefixed (e.g., with 'a/' and 'b/'). Tip: use 'git diff --no-prefix'
  to omit the prefix.
  """
  diff: String!
}

"""Represents a GitHub account on which the App was installed."""
type GitHubAccount {
  """The login username of the account."""
  login: String!

  """The avatar URL of the account."""
  avatarURL: String!

  """A link to the account on GitHub."""
  url: String!

  """The account type."""
  type: String!
}

"""A GitHub App configuration."""
type GitHubApp implements Node {
  """Unique ID of the GitHub App"""
  id: ID!

  """The GitHub App ID"""
  appID: Int!

  """The name of the GitHub App"""
  name: String!

  """The domain of the GitHub App (e.g. "repos" or "batches")"""
  domain: String!

  """The slug of the GitHub App"""
  slug: String!

  """The base URL of the GitHub App"""
  baseURL: String!

  """The URL of the GitHub App page"""
  appURL: String!

  """The client ID of the GitHub App"""
  clientID: String!

  """The client secret of the GitHub App"""
  clientSecret: String!

  """The logo URL of the GitHub App"""
  logo: String!

  """The created at timestamp of the GitHub App in our database"""
  createdAt: DateTime!

  """The updated at timestamp of the GitHub App in our database"""
  updatedAt: DateTime!

  """Fetches a list of installation IDs for this GitHub App."""
  installations: [Installation!]!

  """Fetches the webhook associated with this GitHub App."""
  webhook: Webhook
}

"""A list of GitHub Apps."""
type GitHubAppConnection {
  """A list of GitHub Apps."""
  nodes: [GitHubApp!]!

  """The total count of GitHub Apps in the connection."""
  totalCount: Int!
}

"""
GitHubAppDomain enumerates the domains in which GitHub Apps can be used.
"""
enum GitHubAppDomain {
  """GitHub Apps that are configured for repository syncing."""
  REPOS

  """GitHub Apps that are configured for batch changes commit signing."""
  BATCHES
}

"""A Git object."""
type GitObject {
  """This object's OID."""
  oid: GitObjectID!

  """The abbreviated form of this object's OID."""
  abbreviatedOID: String!

  """The commit object, if it is a commit and it exists; otherwise null."""
  commit: GitCommit

  """The Git object's type."""
  type: GitObjectType!
}

"""
A decorated connection of Git objects resulting from 'previewGitObjectFilter'.
"""
type GitObjectFilterPreview {
  """A list of Git objects composing the current page."""
  nodes: [CodeIntelGitObject!]!

  """The total number of Git objects in this result set."""
  totalCount: Int!

  """
  When countObjectsYoungerThanHours is supplied, this holds the total number of Git
  objects in the result set that have an associated commit date younger than the
  supplied threshold.
  """
  totalCountYoungerThanThreshold: Int
}

"""A Git object ID (SHA-1 hash, 40 hexadecimal characters)."""
scalar GitObjectID

"""All possible types of Git objects."""
enum GitObjectType {
  """A Git commit object."""
  GIT_COMMIT

  """A Git tag object."""
  GIT_TAG

  """A Git tree object."""
  GIT_TREE

  """A Git blob object."""
  GIT_BLOB

  """A Git object of unknown type."""
  GIT_UNKNOWN
}

"""A Git ref."""
type GitRef implements Node {
  """The globally addressable ID for the Git ref."""
  id: ID!

  """The full ref name (e.g., "refs/heads/mybranch" or "refs/tags/mytag")."""
  name: String!

  """An unambiguous short name for the ref."""
  abbrevName: String!

  """
  The display name of the ref. For branches ("refs/heads/foo"), this is the branch
  name ("foo").
  As a special case, for GitHub pull request refs of the form refs/pull/NUMBER/head,
  this is "NUMBER".
  """
  displayName: String!

  """
  The prefix of the ref, either "", "refs/", "refs/heads/", "refs/pull/", or
  "refs/tags/". This prefix is always a prefix of the ref's name.
  """
  prefix: String!

  """The type of this Git ref."""
  type: GitRefType!

  """The object that the ref points to."""
  target: GitObject!

  """The associated repository."""
  repository: Repository!

  """The URL to this Git ref."""
  url: String!
}

"""A list of Git refs."""
type GitRefConnection {
  """A list of Git refs."""
  nodes: [GitRef!]!

  """
  The total count of Git refs in the connection. This total count may be larger
  than the number of nodes in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Ordering options for Git refs."""
enum GitRefOrder {
  """By the authored or committed at date, whichever is more recent."""
  AUTHORED_OR_COMMITTED_AT
}

"""All possible types of Git refs."""
enum GitRefType {
  """A Git branch (in refs/heads/)."""
  GIT_BRANCH

  """A Git tag (in refs/tags/)."""
  GIT_TAG

  """A Git ref that is neither a branch nor tag."""
  GIT_REF_OTHER
}

"""
A Git revision range of the form "base..head" or "base...head". Other revision
range formats are not supported.
"""
type GitRevisionRange {
  """
  The Git revision range expression of the form "base..head" or "base...head".
  """
  expr: String!

  """The base (left-hand side) of the range."""
  base: GitRevSpec!

  """The base's revspec as an expression."""
  baseRevSpec: GitRevSpecExpr!

  """The head (right-hand side) of the range."""
  head: GitRevSpec!

  """The head's revspec as an expression."""
  headRevSpec: GitRevSpecExpr!

  """
  The merge-base of the base and head revisions, if this is a "base...head"
  revision range. If this is a "base..head" revision range, then this field is null.
  """
  mergeBase: GitObject
}

"""A Git revspec."""
union GitRevSpec = GitRef | GitRevSpecExpr | GitObject

"""A Git revspec expression that (possibly) resolves to a Git revision."""
type GitRevSpecExpr {
  """The original Git revspec expression."""
  expr: String!

  """The Git object that the revspec resolves to, or null otherwise."""
  object: GitObject
}

"""A Git tree in a repository."""
type GitTree implements TreeEntry {
  """The full path (relative to the root) of this tree."""
  path: String!

  """Whether this tree is the root (top-level) tree."""
  isRoot: Boolean!

  """The base name (i.e., last path component only) of this tree."""
  name: String!

  """
  True because this is a directory. (The value differs for other TreeEntry interface implementations, such as
  File.)
  """
  isDirectory: Boolean!

  """The Git commit containing this tree."""
  commit: GitCommit!

  """The repository containing this tree."""
  repository: Repository!

  """
  The URL to this tree (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this tree (using an immutable revision specifier).
  """
  canonicalURL: String!

  """The URLs to this tree on external services."""
  externalURLs: [ExternalLink!]!

  """The URL to this entry's raw contents as a Zip archive."""
  rawZipArchiveURL: String!

  """Submodule metadata if this tree points to a submodule"""
  submodule: Submodule

  """A list of directories in this tree."""
  directories(
    """Returns the first n files in the tree."""
    first: Int

    """Recurse into sub-trees."""
    recursive: Boolean = false
  ): [GitTree!]!

  """A list of files in this tree."""
  files(
    """Returns the first n files in the tree."""
    first: Int

    """Recurse into sub-trees."""
    recursive: Boolean = false
  ): [File!]!

  """A list of entries in this tree."""
  entries(
    """Returns the first n files in the tree."""
    first: Int

    """Recurse into sub-trees. If true, implies recursiveSingleChild."""
    recursive: Boolean = false

    """
    Recurse into sub-trees of single-child directories. If true, we return a flat list of
    every directory that is a single child, and any directories or files that are
    nested in a single child.
    """
    recursiveSingleChild: Boolean = false

    """
    Includes all parent directories and their entries. For example, if the path is
    `/client/web/something`, it will return the following entries in this order:
    
      - `/*`
      - `/client/*`
      - `/client/web/*`
      - `/client/web/something/*`
    
    This is useful for rendering a collapsed tree view for the entry.
    """
    ancestors: Boolean = false
  ): [TreeEntry!]!

  """Symbols defined in this tree."""
  symbols(
    """Returns the first n symbols from the list."""
    first: Int

    """Return symbols matching the query."""
    query: String
  ): SymbolConnection!

  """Whether this tree entry is a single child"""
  isSingleChild(
    """Returns the first n files in the tree."""
    first: Int

    """Recurse into sub-trees."""
    recursive: Boolean = false

    """Recurse into sub-trees of single-child directories"""
    recursiveSingleChild: Boolean = false
  ): Boolean!

  """LSIF data for this tree entry."""
  lsif(
    """
    An optional filter for the name of the tool that produced the upload data.
    """
    toolName: String
  ): GitTreeLSIFData

  """Owners of the directory at revision."""
  ownership(
    """Returns the first n ownership records from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String
  ): OwnershipConnection!

  """
  Ownership statistics for all the files (deeply) contained in this tree.
  """
  ownershipStats: OwnershipStats!
}

"""
A wrapper object around LSIF query methods for a particular git-tree-at-revision. When this node is
null, no LSIF data is available for the git tree in question.
"""
type GitTreeLSIFData implements TreeEntryLSIFData {
  """Code diagnostics provided through LSIF."""
  diagnostics(first: Int): DiagnosticConnection!
}

"""Either a git tree or blob."""
union GitTreeOrBlob = GitTree | GitBlob

"""
FOR INTERNAL USE ONLY: A status message produced when disableAutoGitUpdates is
set to true in the site configuration
"""
type GitUpdatesDisabled {
  """The message of this status message"""
  message: String!
}

"""Stats on all the changesets across the instance."""
type GlobalChangesetsStats {
  """The count of unpublished changesets."""
  unpublished: Int!

  """The count of draft changesets."""
  draft: Int!

  """The count of open changesets."""
  open: Int!

  """The count of merged changesets."""
  merged: Int!

  """The count of closed changesets."""
  closed: Int!

  """The count of all changesets."""
  total: Int!
}

"""THe progress of current and historic precise ranking jobs."""
type GlobalRankingSummary {
  """Precise ranking job summaries ordered reverse-chronologically."""
  rankingSummary: [RankingSummary!]!

  """The key of the current ranking summary."""
  derivativeGraphKey: String

  """The time that the next ranking job is configured to begin."""
  nextJobStartsAt: DateTime

  """
  The current number of SCIP indexes that are visible to the ranking calculation.
  """
  numExportedIndexes: Int!

  """
  The target number of SCIP indexes that are visible to the ranking calculation.
  """
  numTargetIndexes: Int!

  """
  The number of repositories which have ranks but haven't been indexed since the
  ranking scores became available.
  """
  numRepositoriesWithoutCurrentRanks: Int!
}

"""Fields that can be grouped on for compute powered insights."""
enum GroupByField {
  REPO
  LANG
  PATH
  AUTHOR
  DATE
}

"""Input for a happiness feedback submission."""
input HappinessFeedbackSubmissionInput {
  """The feedback text from the user."""
  feedback: String

  """The path that the happiness feedback will be submitted from."""
  currentPath: String
}

"""A preview entry to a repository to which the user has no access."""
union HiddenApplyPreviewTargets = HiddenApplyPreviewTargetsAttach | HiddenApplyPreviewTargetsUpdate | HiddenApplyPreviewTargetsDetach

"""
A preview entry where no changeset existed before matching the changeset spec.
"""
type HiddenApplyPreviewTargetsAttach {
  """The changeset spec from this entry."""
  changesetSpec: HiddenChangesetSpec!
}

"""
A preview entry where no changeset spec exists for the changeset currently in
the target batch change.
"""
type HiddenApplyPreviewTargetsDetach {
  """The changeset from this entry."""
  changeset: HiddenExternalChangeset!
}

"""A preview entry where a changeset matches the changeset spec."""
type HiddenApplyPreviewTargetsUpdate {
  """The changeset spec from this entry."""
  changesetSpec: HiddenChangesetSpec!

  """The changeset from this entry."""
  changeset: HiddenExternalChangeset!
}

"""A workspace to which the requesting user does not have access."""
type HiddenBatchSpecWorkspace implements BatchSpecWorkspace & Node {
  """The unique ID for the workspace."""
  id: ID!

  """Used for reverse querying."""
  batchSpec: BatchSpec!

  """If true, only the files within the workspace will be fetched."""
  onlyFetchWorkspace: Boolean!

  """
  If true, this workspace has been skipped, because some rule forced this.
  For now, the only one is a .batchignore file existing in the repository.
  """
  ignored: Boolean!

  """
  If true, this workspace has been skipped, because the code host on which
  the repository is hosted is not supported.
  """
  unsupported: Boolean!

  """Whether we found a task cache result."""
  cachedResultFound: Boolean!

  """How many steps had a cached result."""
  stepCacheResultCount: Int!

  """
  The time when the workspace was enqueued for processing. Null, if not yet enqueued.
  """
  queuedAt: DateTime

  """
  The time when the workspace started processing. Null, if not yet started.
  """
  startedAt: DateTime

  """
  The time when the workspace finished processing. Null, if not yet finished.
  """
  finishedAt: DateTime

  """The current state the workspace is in."""
  state: BatchSpecWorkspaceState!

  """
  The rank of this execution in the queue of the user. The value of this field is null if the
  execution has started.
  """
  placeInQueue: Int

  """
  The rank of this execution in the global queue. The value of this field is null if the
  execution has started.
  """
  placeInGlobalQueue: Int

  """
  The diff stat over all created changeset specs. Null, if not yet finished or
  failed.
  """
  diffStat: DiffStat
}

"""
One preview entry in the list of all previews against a batch spec. Each mapping
between changeset specs and current changesets yields one of these. It describes
which operations are taken against which changeset spec and changeset to ensure the
desired state is met.
"""
type HiddenChangesetApplyPreview {
  """The operations to take to achieve the desired state."""
  operations: [ChangesetSpecOperation!]!

  """
  The delta between the current changeset state and what the new changeset spec
  envisions the changeset to look like.
  """
  delta: ChangesetSpecDelta!

  """The target entities in this preview entry."""
  targets: HiddenApplyPreviewTargets!
}

"""
A changeset spec is an immutable description of the desired state of a changeset in a batch change. To
create a changeset spec, use the createChangesetSpec mutation.
"""
type HiddenChangesetSpec implements ChangesetSpec & Node {
  """
  The unique ID for a changeset spec.
  
  The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
  even though repository permissions also apply to viewers of changeset specs, because being
  allowed to view a repository should not entitle a person to view all not-yet-published
  changesets for that repository. Consider a batch change to fix a security vulnerability: the
  batch change author may prefer to prepare all of the changesets in private so that the window
  between revealing the problem and merging the fixes is as short as possible.
  """
  id: ID!

  """The type of changeset spec."""
  type: ChangesetSpecType!

  """
  The date, if any, when this changeset spec expires and is automatically purged. A changeset
  spec never expires (and this field is null) if its batch spec has been applied.
  """
  expiresAt: DateTime
}

"""A changeset on a code host that the user does not have access to."""
type HiddenExternalChangeset implements Node & Changeset {
  """The unique ID for the changeset."""
  id: ID!

  """The batch changes that contain this changeset."""
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!

  """The state of the changeset."""
  state: ChangesetState!

  """The date and time when the changeset was created."""
  createdAt: DateTime!

  """The date and time when the changeset was updated."""
  updatedAt: DateTime!

  """
  The date and time when the next changeset sync is scheduled, or null if none is scheduled.
  """
  nextSyncAt: DateTime
}

"""A highlighted region in a string (e.g., matched by a query)."""
type Highlight {
  """The 1-indexed line number."""
  line: Int!

  """The 1-indexed character on the line."""
  character: Int!

  """The length of the highlight, in characters (on the same line)."""
  length: Int!
}

"""A highlighted hunk, consisting of all its lines."""
type HighlightedDiffHunkBody {
  """Whether highlighting was aborted."""
  aborted: Boolean!

  """The highlighted lines."""
  lines: [HighlightedDiffHunkLine!]!
}

"""A single highlighted line, including the kind of line."""
type HighlightedDiffHunkLine {
  """The HTML containing the syntax-highlighted line of code."""
  html: String!

  """
  The operation that happened on this line, in patches it is prefixed with '+', '-', ' '.
  Can be either add, delete, or no change.
  """
  kind: DiffHunkLineType!
}

"""A highlighted file."""
type HighlightedFile {
  """Whether or not it was aborted."""
  aborted: Boolean!

  """The HTML table that can be used to display the highlighted file."""
  html: String!

  """
  Base64 encoded JSON payload of LSIF Typed with syntax highlighting data.
  """
  lsif: String!

  """
  A list of the desired line ranges. Each list is a list of lines, where each element is an HTML
  table row '<tr>...</tr>' string. This is useful if you only need to display specific subsets of
  the file.
  """
  lineRanges(ranges: [HighlightLineRange!]!): [[String!]!]!
}

"""A string that has highlights (e.g, query matches)."""
type HighlightedString {
  """The full contents of the string."""
  value: String!

  """Highlighted matches of the query in the preview string."""
  highlights: [Highlight!]!
}

"""A specific highlighted line range to fetch."""
input HighlightLineRange {
  """
  The first line to fetch (0-indexed, inclusive). Values outside the bounds of the file will
  automatically be clamped within the valid range.
  """
  startLine: Int!

  """
  The last line to fetch (0-indexed, inclusive). Values outside the bounds of the file will
  automatically be clamped within the valid range.
  """
  endLine: Int!
}

"""
The format and highlighting to use when requesting highlighting information for a file.
"""
enum HighlightResponseFormat {
  """HTML formatted file content without syntax highlighting."""
  HTML_PLAINTEXT

  """HTML formatted file content with syntax highlighting."""
  HTML_HIGHLIGHT

  """SCIP highlighting information as JSON."""
  JSON_SCIP
}

"""Hover range and markdown content."""
type Hover {
  """A markdown string containing the contents of the hover."""
  markdown: Markdown!

  """The range to highlight."""
  range: Range!
}

"""A key-value pair"""
type HTTPHeader {
  """The header name"""
  name: String!

  """Can be multiple values"""
  values: [String!]!
}

"""A hunk."""
type Hunk {
  """The startLine."""
  startLine: Int!

  """The endLine."""
  endLine: Int!

  """The startByte."""
  startByte: Int!

  """The endByte."""
  endByte: Int!

  """The rev."""
  rev: String!

  """The author."""
  author: Signature!

  """The message."""
  message: String!

  """The commit that contains the hunk."""
  commit: GitCommit!

  """
  The original filename at the commit. Use this filename if you're reading the
  text contents of the file at the `commit` field of this hunk. The file may
  have been renamed after the commit so name of file where this hunk got computed
  may not exist.
  """
  filename: String!
}

"""
Represents a terminally incomplete data point at a specific time, and optionally for a specific repository.
"""
interface IncompleteDatapointAlert {
  """The data point that is incomplete."""
  time: DateTime!
}

"""Explicit configuration for indexing a repository."""
type IndexConfiguration {
  """The raw JSON-encoded index configuration."""
  configuration: String

  """The parsed index configuration (decoded from the raw JSON version)."""
  parsedConfiguration: [AutoIndexJobDescription!]

  """
  The raw JSON-encoded index configuration as inferred by the auto-indexer.
  """
  inferredConfiguration: InferredConfiguration
}

"""
A precise indexer paired with a count of indexable projects in the repository (used by CodeIntelSummary).
"""
type IndexerWithCount {
  """The repository."""
  indexer: CodeIntelIndexer

  """
  The count of projects that could utilize the indexer in this repository.
  """
  count: Int!
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories are being
indexed for search.
"""
type IndexingProgress {
  """The number of repositories that have not been indexed yet."""
  notIndexed: Int!

  """The number of repositories that have been indexed."""
  indexed: Int!
}

"""The configuration and execution summary of the indexer."""
type IndexStep {
  """
  Commands to run in the same image as the indexer but before the indexer is invoked.
  """
  commands: [String!]!

  """The arguments to supply to the indexer container."""
  indexerArgs: [String!]!

  """
  The path to the index file relative to the root directory (dump.lsif by default).
  """
  outfile: String

  """
  A list of environment variables (VAR=VAL) that should be made available to the indexer.
  """
  requestedEnvVars: [String!]

  """The execution summary (if completed or errored) of the index command."""
  logEntry: ExecutionLogEntry
}

"""Configuration and execution summary of an index job."""
type IndexSteps {
  """Execution log entries related to setting up the indexing workspace."""
  setup: [ExecutionLogEntry!]!

  """
  Configuration and execution summary (if completed or errored) of steps to be performed prior to indexing.
  """
  preIndex: [PreIndexStep!]!

  """
  Configuration and execution summary (if completed or errored) of the indexer.
  """
  index: IndexStep!

  """
  Execution log entry related to uploading the dump produced by the indexing step.
  This field be missing if the upload step had not been executed.
  """
  upload: ExecutionLogEntry

  """Execution log entries related to tearing down the indexing workspace."""
  teardown: [ExecutionLogEntry!]!
}

"""
The result of running the auto-index inference script over a particular repo.
"""
type InferAutoIndexJobsResult {
  """The list of inferred jobs."""
  jobs: [AutoIndexJobDescription!]!

  """The output from the inference script."""
  inferenceOutput: String!
}

"""
The additionally available indexers that have been inferred from jobs and job
hints that could be indexed but haven't been indexed.
"""
type InferredAvailableIndexers {
  """The indexer."""
  indexer: CodeIntelIndexer!

  """The list of roots that could be indexed."""
  roots: [String!]!

  """The list of roots that could be indexed."""
  rootsWithKeys: [RootWithKey!]!
}

"""A wrapper around inferred configuration and a possible limit error."""
type InferredConfiguration {
  """The raw JSON-encoded inferred index configuration."""
  configuration: String!

  """The parsed index configuration (decoded from the raw JSON version)."""
  parsedConfiguration: [AutoIndexJobDescription!]

  """
  If inference of the repository contents hit a limit its error description will available here.
  """
  limitError: String
}

"""An insight about code."""
type Insight {
  """The short title of the insight."""
  title: String!

  """The description of the insight."""
  description: String!

  """Data points over a time range (inclusive)"""
  series: [InsightsSeries!]!

  """Unique identifier for this insight."""
  id: String!
}

"""Information about an item in the insights backfill queue"""
type InsightBackfillQueueItem {
  """The ID of the Backfill item"""
  id: ID!

  """The title of the insight view"""
  insightViewTitle: String!

  """The user that originally created the insight view"""
  creator: User

  """The name of the series on the associated insight view"""
  seriesLabel: String!

  """The search query for the series"""
  seriesSearchQuery: String!

  """Information on the current backfill status"""
  backfillQueueStatus: BackfillStatus!
}

"""
Returns information regarding the insights backfill queue to admin users.
"""
type InsightBackfillQueueItemConnection implements Connection {
  """A list of insight backfill queue items."""
  nodes: [InsightBackfillQueueItem!]!

  """The total number of insight backfill queue items in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""A code insight data point."""
type InsightDataPoint {
  """The time of this data point."""
  dateTime: DateTime!

  """The value of the insight at this point in time."""
  value: Float!

  """
  A search query that will show the diff between this point and the previous point
  """
  diffQuery: String
}

"""Defines how the data series is generated."""
union InsightDataSeriesDefinition = SearchInsightDataSeriesDefinition

"""Defines a time scope using an interval of time"""
type InsightIntervalTimeScope {
  """The unit of time."""
  unit: TimeIntervalStepUnit!

  """The value of time."""
  value: Int!
}

"""Defines presentation options for the insight."""
union InsightPresentation = LineChartInsightViewPresentation | PieChartInsightViewPresentation

"""Possible queue states"""
enum InsightQueueItemState {
  NEW
  QUEUED
  COMPLETED
  PROCESSING
  FAILED
  UNKNOWN
}

"""Defines how the scope of repositories was generated"""
union InsightRepositoryDefinition = RepositorySearchScope | InsightRepositoryScope

"""
A custom repository scope for an insight. A scope with all empty fields implies a global scope.
"""
type InsightRepositoryScope {
  """The list of repositories in the scope."""
  repositories: [String!]!
}

"""A dashboard of insights."""
type InsightsDashboard implements Node {
  """The Dashboard ID."""
  id: ID!

  """The Dashboard Title."""
  title: String!

  """The list of associated insights to the dashboard."""
  views(first: Int, after: ID): InsightViewConnection

  """The permission grants assossiated with the dashboard."""
  grants: InsightsPermissionGrants!
}

"""A paginated list of dashboards."""
type InsightsDashboardConnection {
  """A list of dashboards."""
  nodes: [InsightsDashboard!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Response wrapper object for insight dashboard mutations."""
type InsightsDashboardPayload {
  """The result dashboard after mutation."""
  dashboard: InsightsDashboard!
}

"""Metadata about a specific data series for an insight."""
type InsightSeriesMetadata {
  """Unique ID for the series."""
  seriesId: String!

  """Sourcegraph query string used to generate the series."""
  query: String!

  """Current status of the series."""
  enabled: Boolean!
}

"""Wrapper payload object for insight series metadata."""
type InsightSeriesMetadataPayload {
  """The series metadata."""
  series: InsightSeriesMetadata!
}

"""Information about queue status for insight series queries."""
type InsightSeriesQueryStatus {
  """Unique ID for the series."""
  seriesId: String!

  """
  Sourcegraph query string used to generate the series. This is the base query string that was input by the user,
  and does not include each repository specific query that would be generated to backfill an entire series.
  """
  query: String!

  """The current activity status for this series."""
  enabled: Boolean!

  """
  The number of queries belonging to the series with errored status. Errored is
  a transient state representing a retryable error that has not
  yet exceeded the max retry count. This count only represents the queries that
  have yet to be pruned by the background maintenance workers.
  """
  errored: Int!

  """
  The number of queries belonging to the series that are successfully completed.
  This count only represents the queries that have yet to be pruned by the background maintenance workers.
  """
  completed: Int!

  """
  The number of queries belonging to the series that are currently processing.
  This count only represents the queries that have yet to be pruned by the background maintenance workers.
  """
  processing: Int!

  """
  The number of queries belonging to the series that are terminally failed.
  These have either been marked as non-retryable or exceeded
  the max retry limit. This count only represents the queries that have yet to
  be pruned by the background maintenance workers.
  """
  failed: Int!

  """
  The number of queries belonging to the series that are queued for processing.
  This count only represents the queries that have yet to be pruned by the background maintenance workers.
  """
  queued: Int!
}

"""Status indicators for a specific series of insight data."""
type InsightSeriesStatus {
  """
  The total number of points stored for this series, at the finest level
  (e.g. per repository, or per-repository-per-language) Has no strict relation
  to the data points shown in the web UI or returned by `points()`, because those
  are aggregated and this number _can_ report some duplicates points which get
  stored but removed at query time for the web UI.
  
  Why its useful: an insight may look like "it is doing nothing" but in reality
  this number will be increasing by e.g. several thousands of points rapidly.
  """
  totalPoints: Int!

  """
  The total number of jobs currently pending to add new data points for this series.
  
  Each job may create multiple data points (e.g. a job may create one data point per
  repo, or language, etc.) This number will go up and down over time until all work
  is completed (discovering work takes almost as long as doing the work.)
  
  Why its useful: signals "amount of work still to be done."
  """
  pendingJobs: Int!

  """
  The total number of jobs completed for this series. Note that since pendingJobs will
  go up/down over time, you CANNOT divide these two numbers to get a percentage as it
  would be nonsense ("it says 90% complete but has been like that for a really long
  time!").
  
  Does not include 'failedJobs'.
  
  Why its useful: gives an indication of "how much work has been done?"
  """
  completedJobs: Int!

  """
  The total number of jobs that were tried multiple times and outright failed. They will
  not be retried again, and indicates the series has incomplete data.
  
  Use ((failedJobs / completedJobs) * 100.0) to get an approximate percentage of how
  much data the series data may be missing (e.g. ((30 / 150)*100.0) == 20% of the series
  data is incomplete (rough approximation, not precise).
  
  Why its useful: signals if there are problems, and how severe they are.
  """
  failedJobs: Int!

  """
  The time that the insight series completed a full iteration and queued up records for processing. This can
  effectively be used as a status that the insight is still processing if returned null.
  """
  backfillQueuedAt: DateTime

  """Indicates if the series is currently loading additional data"""
  isLoadingData: Boolean

  """Data points that are flagged terminally incomplete for this series."""
  incompleteDatapoints: [IncompleteDatapointAlert!]!
}

"""
Permissions object. Note: only organizations the user has access to will be included.
"""
type InsightsPermissionGrants {
  """Specific users that have permission."""
  users: [ID!]!

  """Organizations that have permission."""
  organizations: [ID!]!

  """True if the permission is set to global."""
  global: Boolean!
}

"""Input object for permissions to grant."""
input InsightsPermissionGrantsInput {
  """Specific users to grant permissions to."""
  users: [ID!]

  """Organizations to grant permissions to."""
  organizations: [ID!]

  """Set global to true to grant global permission."""
  global: Boolean
}

"""A series of data about a code insight."""
type InsightsSeries {
  """Unique ID for the series."""
  seriesId: String!

  """The label used to describe this series of data points."""
  label: String!

  """
  Data points over a time range (inclusive)
  
  The 'from', 'to', 'includeRepoRegex' and 'excludeRepoRegex' arguments have been deprecated.
  They will have no affect on the points returned and will be removed in a future version.
  """
  points(from: DateTime, to: DateTime, includeRepoRegex: String, excludeRepoRegex: String): [InsightDataPoint!]!

  """The status of this series of data, e.g. progress collecting it."""
  status: InsightSeriesStatus!
}

"""Defines a scope of time for which the insight data is generated."""
union InsightTimeScope = InsightIntervalTimeScope

"""
An Insight View is a lens to view insight data series. In most cases this
corresponds to a visualization of an insight, containing multiple series.
"""
type InsightView implements Node {
  """The View ID."""
  id: ID!

  """
  The default filters saved on the insight. This will differ from the applied filters if they are overwritten but not saved.
  """
  defaultFilters: InsightViewFilters!

  """The filters currently applied to the insight and the data."""
  appliedFilters: InsightViewFilters!

  """The time series data for this insight."""
  dataSeries: [InsightsSeries!]!

  """Presentation options for the insight."""
  presentation: InsightPresentation!

  """Information on how each data series was generated"""
  dataSeriesDefinitions: [InsightDataSeriesDefinition!]!

  """
  The total number of dashboards on which this insight is referenced. The count is global and disregards permissions.
  """
  dashboardReferenceCount: Int!

  """
  Represents if this insight is in a frozen state or not. A frozen state is
  relevant when a license is downgraded and the number of insights exceed the
  free plan limits.
  """
  isFrozen: Boolean!

  """
  The default series display options saved on the insight. This will differ from
  the applied options if they are overwritten but not saved.
  """
  defaultSeriesDisplayOptions: SeriesDisplayOptions!

  """The series display options currently applied to the insight."""
  appliedSeriesDisplayOptions: SeriesDisplayOptions!

  """
  Dashboards this insight has been added to that the current user has permission to view
  """
  dashboards(first: Int, after: String, id: ID): InsightsDashboardConnection

  """The total number of series on this insight."""
  seriesCount: Int

  """The Repositories the dataSeries on this insight will operate over."""
  repositoryDefinition: InsightRepositoryDefinition!

  """The scope of time for which the insight data is generated."""
  timeScope: InsightTimeScope!
}

"""A dashboard of insight views."""
type InsightViewConnection {
  """A list of insights."""
  nodes: [InsightView]!

  """Pagination information."""
  pageInfo: PageInfo!

  """The total number of insights in the connection."""
  totalCount: Int
}

"""
Input for the default values for filters and aggregates for an insight.
"""
input InsightViewControlsInput {
  """Input for the default filters for an insight."""
  filters: InsightViewFiltersInput!

  """Input for series' sort order."""
  seriesDisplayOptions: SeriesDisplayOptionsInput!
}

"""Debugging information related to an InsightView"""
type InsightViewDebug {
  """A JSON dump of debug information for series on the insight view"""
  raw: [String!]!
}

"""The fields and values for which the insight is filtered."""
type InsightViewFilters {
  """A regex string for which to include repositories in a filter."""
  includeRepoRegex: String

  """A regex string for which to exclude repositories from a filter."""
  excludeRepoRegex: String

  """The names of query based search contexts that are used as a filter."""
  searchContexts: [String!]
}

"""Input for the default values by which the insight is filtered."""
input InsightViewFiltersInput {
  """A regex string for which to include repositories in a filter."""
  includeRepoRegex: String

  """A regex string for which to exclude repositories in a filter."""
  excludeRepoRegex: String

  """
  A list of query based search contexts to include in the filters for the view.
  """
  searchContexts: [String!]
}

"""Response wrapper object for insight view mutations."""
type InsightViewPayload {
  """The resulting view."""
  view: InsightView!
}

"""Represents a single GitHub App installation."""
type Installation {
  """The installation ID of the App."""
  id: Int!

  """The installation URL."""
  url: String!

  """The account on which the App was installed"""
  account: GitHubAccount!

  """The external services derived from this installation."""
  externalServices(first: Int): ExternalServiceConnection!
}

"""The result of Mutation.inviteUserToOrganization."""
type InviteUserToOrganizationResult {
  """
  Whether an invitation email was sent. If emails are not enabled on this site or if the user has no verified
  email address, an email will not be sent.
  """
  sentInvitationEmail: Boolean!

  """
  The URL that the invited user can visit to accept or reject the invitation.
  """
  invitationURL: String!
}

"""
A string that contains valid JSON, with additional support for //-style comments and trailing commas.
"""
scalar JSONCString

"""A valid JSON value."""
scalar JSONValue

"""
A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each
KeyPathSegment must be non-null.
For example, in {"a": [0, {"b": 3}]}, the value 3 is located at the key path ["a", 1, "b"].
"""
input KeyPathSegment {
  """
  The name of the property in the object at this location to descend into.
  """
  property: String

  """The index of the array at this location to descend into."""
  index: Int
}

"""A key-value pair"""
type KeyValuePair {
  """The non-nullable key."""
  key: String!

  """
  The nullable value. A null value indicates this key-value pair should be treated as a tag.
  """
  value: String
}

"""A programming language."""
type Language {
  """Name of the programming language."""
  name: String!
}

"""Statistics about a language's usage."""
type LanguageStatistics {
  """The name of the language."""
  name: String!

  """The total bytes in the language."""
  totalBytes: Float!

  """The total number of lines in the language."""
  totalLines: Int!
}

"""Information about a blob stored in Git Large File Storage (LFS)."""
type LFS {
  """
  The size of the file in LFS in bytes.
  Note: the file size in the GitBlob will be the size of the pointer not the file a
  user checks out.
  """
  byteSize: BigInt!
}

"""Options for a line chart data series"""
input LineChartDataSeriesOptionsInput {
  """The label for the data series."""
  label: String

  """The line color for the data series."""
  lineColor: String
}

"""View presentation for a single insight line chart data series"""
type LineChartDataSeriesPresentation {
  """Unique ID for the series."""
  seriesId: String!

  """The label for the series."""
  label: String!

  """The color for the series."""
  color: String!
}

"""View presentation for a line chart insight"""
type LineChartInsightViewPresentation {
  """The title for the line chart."""
  title: String!

  """The presentation options for the line chart."""
  seriesPresentation: [LineChartDataSeriesPresentation!]!
}

"""Options for a line chart"""
input LineChartOptionsInput {
  """The chart title."""
  title: String
}

"""Input for a line chart search insight data series."""
input LineChartSearchInsightDataSeriesInput {
  """Unique ID for the series. Omit this field if it's a new series."""
  seriesId: String

  """The query string."""
  query: String!

  """Options for this line chart data series."""
  options: LineChartDataSeriesOptionsInput!

  """
  The scope of repositories. The repository scope can be provided at the LineChartSearchInsightInput level.
  If scope is provided here will take priority of any other scope provide at a higher level in the input.
  """
  repositoryScope: RepositoryScopeInput

  """
  The scope of time. This time scope can also be provided at the LineChartSearchInsightInput level.
  If the scope is provided here it will take priority over any other scope provided at a higher level in the input.
  """
  timeScope: TimeScopeInput

  """
  Whether or not to generate the timeseries results from the query capture groups. Defaults to false if not provided.
  """
  generatedFromCaptureGroups: Boolean

  """
  The field to group results by. (For compute powered insights only.) This field
  is experimental and should be considered unstable in the API.
  """
  groupBy: GroupByField
}

"""Input for a line chart search insight."""
input LineChartSearchInsightInput {
  """The list of data series to create (or add) to this insight."""
  dataSeries: [LineChartSearchInsightDataSeriesInput!]!

  """
  The scope of repositories for the insight. If provided here it will apply to all series unless overwritten.
  """
  repositoryScope: RepositoryScopeInput

  """
  The scope of time for the insight view. If provided here it will apply to all series unless overwritten.
  """
  timeScope: TimeScopeInput

  """The options for this line chart."""
  options: LineChartOptionsInput!

  """The dashboard IDs to associate this insight with once created."""
  dashboards: [ID!]

  """The default values for filters and aggregates for this line chart."""
  viewControls: InsightViewControlsInput
}

"""A line match."""
type LineMatch {
  """The preview."""
  preview: String!

  """
  The line number. 0-based. The first line will have lineNumber 0. Note: A
  UI will normally display line numbers 1-based.
  """
  lineNumber: Int!

  """Tuples of [offset, length] measured in characters (not bytes)."""
  offsetAndLengths: [[Int!]!]!

  """Whether or not the limit was hit."""
  limitHit: Boolean! @deprecated(reason: "will always be false")
}

"""LineRange is a span within a line."""
type LineRange {
  """The line."""
  line: Int!

  """The character."""
  character: Int!

  """The length."""
  length: Int!
}

"""A location inside a resource (in a repository at a specific commit)."""
type Location {
  """The file that this location refers to."""
  resource: CodeIntelGitBlob!

  """The range inside the file that this location refers to."""
  range: Range

  """
  The URL to this location (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this location (using an immutable revision specifier).
  """
  canonicalURL: String!
}

"""A list of locations within a file."""
type LocationConnection {
  """A list of locations within a file."""
  nodes: [Location!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
Contains the metadata and upload data for a single state change of an upload.
"""
type LSIFUploadAuditLog {
  """The timestamp the log was emitted at."""
  logTimestamp: DateTime!

  """The timestamp when the associated upload was deleted at."""
  uploadDeletedAt: DateTime

  """The reason for this change in data."""
  reason: String

  """
  A list of changed columns in the format {"column": "<colname>", "new": "<newval>", "old": "<oldval>"}
  """
  changedColumns: [AuditLogColumnChange!]!

  """The ID of the upload."""
  uploadId: ID!

  """The original 40-character commit commit supplied at upload time."""
  inputCommit: String!

  """The original root supplied at upload time."""
  inputRoot: String!

  """The original indexer name supplied at upload time."""
  inputIndexer: String!

  """The time the upload was uploaded."""
  uploadedAt: DateTime!

  """The operation denoted by this log."""
  operation: AuditLogOperation!
}

"""An object representing a markdown string."""
type Markdown {
  """The raw markdown string."""
  text: String!

  """
  HTML for the rendered markdown string, or null if there is no HTML representation provided.
  If specified, clients should render this directly.
  """
  html: String!
}

"""Markdown block renders the Markdown formatted input string into HTML."""
type MarkdownBlock {
  """ID of the block."""
  id: String!

  """Markdown formatted input string."""
  markdownInput: String!
}

"""Describes options for rendering Markdown."""
input MarkdownOptions {
  """A dummy null value (empty input types are not allowed yet)."""
  alwaysNil: String
}

"""Message to or from the LLM"""
input Message {
  """Speaker of the message (human/assistant)"""
  speaker: SpeakerType!

  """Text content of the message"""
  text: String!
}

"""
Information and status about the mirroring of a repository. In this case, the remote source repository
is external to Sourcegraph and the mirror is maintained by the Sourcegraph site (not the other way
around).
"""
type MirrorRepositoryInfo {
  """The URL of the remote source repository."""
  remoteURL: String!

  """Whether the clone of the repository has begun but not yet completed."""
  cloneInProgress: Boolean!

  """
  A single line of text that contains progress information for the running clone command.
  The format of the progress text is not specified.
  It is intended to be displayed directly to a user.
  e.g.
  "Receiving objects:  95% (2041/2148), 292.01 KiB | 515.00 KiB/s"
  "Resolving deltas:   9% (117/1263)"
  """
  cloneProgress: String

  """Whether the repository has ever been successfully cloned."""
  cloned: Boolean!

  """Whether the repository is currently corrupt."""
  isCorrupted: Boolean!

  """
  A Log of the corruption events that have been detected on this repository. Only 10 events are kept and the events
  are ordered from most recent to least.
  """
  corruptionLogs: [RepoCorruptionLog!]!

  """
  When the repository was last successfully updated from the remote source repository.
  """
  updatedAt: DateTime

  """
  When the repository is next scheduled to be updated from the remote source repository.
  """
  nextSyncAt: DateTime

  """The state of this repository in the update schedule."""
  updateSchedule: UpdateSchedule

  """The state of this repository in the update queue."""
  updateQueue: UpdateQueue

  """
  The last error message, if any, returned when fetching or cloning the repo
  """
  lastError: String

  """The output of the most recent repo sync job"""
  lastSyncOutput: String

  """The byte size of the repo."""
  byteSize: BigInt!

  """
  The gitserver shard on which the repository is or will be cloned.
  Only site admins can access this field.
  """
  shard: String
}

"""A code monitor with one trigger and possibly many actions."""
type Monitor implements Node {
  """The code monitor's unique ID."""
  id: ID!

  """The user who created the code monitor."""
  createdBy: User!

  """The time at which the code monitor was created."""
  createdAt: DateTime!

  """A meaningful description of the code monitor."""
  description: String!

  """Owners can edit the code monitor."""
  owner: Namespace!

  """Whether the code monitor is currently enabled."""
  enabled: Boolean!

  """Triggers trigger actions. There can only be one trigger per monitor."""
  trigger: MonitorTrigger!

  """One or more actions that are triggered by the trigger."""
  actions(
    """Returns the first n actions from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorActionConnection!
}

"""Supported actions for code monitors."""
union MonitorAction = MonitorEmail | MonitorWebhook | MonitorSlackWebhook

"""A list of actions."""
type MonitorActionConnection {
  """A list of actions."""
  nodes: [MonitorAction!]!

  """The total number of actions in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A list of events."""
type MonitorActionEmailRecipientsConnection {
  """A list of recipients."""
  nodes: [Namespace!]!

  """The total number of recipients in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
An event documents the result of a trigger or an execution of an action.
"""
type MonitorActionEvent implements Node {
  """The unique id of an event."""
  id: ID!

  """The status of an event."""
  status: EventStatus!

  """A message with details regarding the status of the event."""
  message: String

  """The time and date of the event."""
  timestamp: DateTime!
}

"""A list of events."""
type MonitorActionEventConnection {
  """A list of events."""
  nodes: [MonitorActionEvent!]!

  """The total number of events in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The input required to create an action."""
input MonitorActionInput {
  """An email action."""
  email: MonitorEmailInput

  """A webhook action."""
  webhook: MonitorWebhookInput

  """A Slack webhook action."""
  slackWebhook: MonitorSlackWebhookInput
}

"""A list of code monitors"""
type MonitorConnection {
  """A list of monitors."""
  nodes: [Monitor!]!

  """The total number of monitors in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The input required to edit an action."""
input MonitorEditActionInput {
  """An email action."""
  email: MonitorEditEmailInput

  """A webhook action."""
  webhook: MonitorEditWebhookInput

  """A Slack webhook action."""
  slackWebhook: MonitorEditSlackWebhookInput
}

"""The input required to edit an email action."""
input MonitorEditEmailInput {
  """
  The id of an email action. If unset, this will
  be treated as a new email action and be created
  rather than updated.
  """
  id: ID

  """The desired state after the update."""
  update: MonitorEmailInput!
}

"""The input required to edit a code monitor."""
input MonitorEditInput {
  """The id of the monitor."""
  id: ID!

  """The desired state after the udpate."""
  update: MonitorInput!
}

"""The input required to edit a Slack webhook action."""
input MonitorEditSlackWebhookInput {
  """
  The id of a Slack webhook action. If unset, this will
  be treated as a new Slack webhook action and be created
  rather than updated.
  """
  id: ID

  """The desired state after the update."""
  update: MonitorSlackWebhookInput!
}

"""The input required to edit a trigger."""
input MonitorEditTriggerInput {
  """The id of the Trigger."""
  id: ID!

  """The desired state after the udpate."""
  update: MonitorTriggerInput!
}

"""The input required to edit a webhook action."""
input MonitorEditWebhookInput {
  """
  The id of a webhook action. If unset, this will
  be treated as a new webhook action and be created
  rather than updated.
  """
  id: ID

  """The desired state after the update."""
  update: MonitorWebhookInput!
}

"""Email is one of the supported actions of code monitors."""
type MonitorEmail implements Node {
  """The unique id of an email action."""
  id: ID!

  """Whether the email action is enabled or not."""
  enabled: Boolean!

  """Whether to include the result contents in the email message"""
  includeResults: Boolean!

  """The priority of the email action."""
  priority: MonitorEmailPriority!

  """
  Use header to automatically approve the message in a read-only or moderated mailing list.
  """
  header: String!

  """A list of recipients of the email."""
  recipients(
    """Returns the first n recipients from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorActionEmailRecipientsConnection!

  """A list of events."""
  events(
    """Returns the first n events from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorActionEventConnection!
}

"""The input required to create an email action."""
input MonitorEmailInput {
  """Whether the email action is enabled or not."""
  enabled: Boolean!

  """Whether to include the result contents in the email message"""
  includeResults: Boolean!

  """The priority of the email."""
  priority: MonitorEmailPriority!

  """A list of users or orgs which will receive the email."""
  recipients: [ID!]!

  """
  Use header to automatically approve the message in a read-only or moderated mailing list.
  """
  header: String!
}

"""The priority of an email action."""
enum MonitorEmailPriority {
  NORMAL
  CRITICAL
}

"""
A high-level monitoring alert, for details see https://docs.sourcegraph.com/admin/observability/metrics#high-level-alerting-metrics
"""
type MonitoringAlert {
  """End time of this event, which describes the past 12h of recorded data."""
  timestamp: DateTime!

  """Name of alert that the service fired."""
  name: String!

  """Name of the service that fired the alert."""
  serviceName: String!

  """Owner of the fired alert."""
  owner: String!

  """
  Average percentage of time (between [0, 1]) that the event was firing over the 12h of recorded data. e.g.
  1.0 if it was firing 100% of the time on average during that 12h window, 0.5 if it was firing 50% of the
  time on average, etc.
  """
  average: Float!
}

"""Monitoring overview."""
type MonitoringStatistics {
  """Alerts fired in this time span."""
  alerts: [MonitoringAlert!]! @deprecated(reason: "No longer supported, and will no longer return data - query will be removed after Sourcegraph 4.5")
}

"""The input required to create a code monitor."""
input MonitorInput {
  """
  The namespace represents the owner of the code monitor.
  Owners can either be users or organizations.
  """
  namespace: ID!

  """A meaningful description of the code monitor."""
  description: String!

  """Whether the code monitor is enabled or not."""
  enabled: Boolean!
}

"""A query that can serve as a trigger for code monitors."""
type MonitorQuery implements Node {
  """The unique id of a trigger query."""
  id: ID!

  """A query."""
  query: String!

  """A list of events."""
  events(
    """Returns the first n events from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorTriggerEventConnection!
}

"""SlackWebhook is one of the supported actions of code monitors."""
type MonitorSlackWebhook implements Node {
  """The unique id of an Slack webhook action."""
  id: ID!

  """Whether the Slack webhook action is enabled or not."""
  enabled: Boolean!

  """Whether to include the result contents in Slack notification message."""
  includeResults: Boolean!

  """The endpoint the Slack webhook event will be sent to"""
  url: String!

  """A list of events."""
  events(
    """Returns the first n events from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorActionEventConnection!
}

"""The input required to create a Slack webhook action."""
input MonitorSlackWebhookInput {
  """Whether the Slack webhook action is enabled or not."""
  enabled: Boolean!

  """Whether to include the result contents in Slack notification message."""
  includeResults: Boolean!

  """The URL that will receive a payload when the action is triggered."""
  url: String!
}

"""Supported triggers for code monitors."""
union MonitorTrigger = MonitorQuery

"""
A trigger event is an event together with a list of associated actions.
"""
type MonitorTriggerEvent implements Node {
  """The unique id of an event."""
  id: ID!

  """The status of an event."""
  status: EventStatus!

  """A message with details regarding the status of the event."""
  message: String

  """The time and date of the event."""
  timestamp: DateTime!

  """
  The query (with after filter) that provides an approximation of the
  set of results associated with this trigger run. Will always be empty
  while status is PENDING.
  """
  query: String

  """
  The number of results recorded for this trigger run. Will always be
  zero until status is SUCCESS.
  """
  resultCount: Int!

  """A list of actions."""
  actions(
    """Returns the first n events from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorActionConnection!
}

"""A list of trigger events."""
type MonitorTriggerEventConnection {
  """A list of events."""
  nodes: [MonitorTriggerEvent!]!

  """The total number of events in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The input required to create a trigger."""
input MonitorTriggerInput {
  """The query string."""
  query: String!
}

"""Webhook is one of the supported actions of code monitors."""
type MonitorWebhook implements Node {
  """The unique id of a webhook action."""
  id: ID!

  """Whether the webhook action is enabled or not."""
  enabled: Boolean!

  """Whether to include the result contents in webhook payload."""
  includeResults: Boolean!

  """The endpoint the webhook event will be sent to"""
  url: String!

  """A list of events."""
  events(
    """Returns the first n events from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorActionEventConnection!
}

"""The input required to create a webhook action."""
input MonitorWebhookInput {
  """Whether the webhook action is enabled or not."""
  enabled: Boolean!

  """Whether to include the result contents in webhook payload."""
  includeResults: Boolean!

  """The URL that will receive a payload when the action is triggered."""
  url: String!
}

"""A mutation."""
type Mutation {
  """
  INTERNAL ONLY: Sets the value of versions.auto_upgrade in the frontend db.
  Determines behavior of multiversion upgrades.
  
  Only site admins may perform this mutation.
  """
  setAutoUpgrade(enable: Boolean!): EmptyResponse!

  """
  Updates the user profile information for the user with the given ID.
  
  Only the user and site admins may perform this mutation.
  """
  updateUser(user: ID!, username: String, displayName: String, avatarURL: String): User!

  """
  Creates an organization. The caller is added as a member of the newly created organization.
  
  Only authenticated users may perform this mutation.
  """
  createOrganization(name: String!, displayName: String, statsID: ID): Org!

  """
  Updates an organization.
  
  Only site admins and any member of the organization may perform this mutation.
  """
  updateOrganization(id: ID!, displayName: String): Org!

  """
  Soft deletes an organization.
  
  Only site admins may perform this mutation.
  """
  deleteOrganization(organization: ID!): EmptyResponse

  """
  Creates a webhook for the specified code host. Only site admins may perform this mutation.
  """
  createWebhook(name: String!, codeHostKind: String!, codeHostURN: String!, secret: String): Webhook!

  """
  Deletes a webhook by given ID. Only site admins may perform this mutation.
  """
  deleteWebhook(id: ID!): EmptyResponse!

  """Updates a webhook with given ID. Null values aren't updated."""
  updateWebhook(id: ID!, name: String, codeHostKind: String, codeHostURN: String, secret: String): Webhook!

  """Adds a external service. Only site admins may perform this mutation."""
  addExternalService(input: AddExternalServiceInput!): ExternalService!

  """
  Updates a external service. Only site admins may perform this mutation.
  """
  updateExternalService(input: UpdateExternalServiceInput!): ExternalService!

  """
  Delete an external service. Only site admins may perform this mutation.
  """
  deleteExternalService(externalService: ID!, async: Boolean = false): EmptyResponse!

  """
  Excludes a repo from external services configs. Only site admins may perform this mutation.
  """
  excludeRepoFromExternalServices(externalServices: [ID!]!, repo: ID!): EmptyResponse!

  """
  Tests the connection to a mirror repository's original source repository. This is an
  expensive and slow operation, so it should only be used for interactive diagnostics.
  
  Only site admins may perform this mutation.
  """
  checkMirrorRepositoryConnection(
    """The ID of the existing repository whose mirror to check."""
    repository: ID

    """
    The name of a repository whose mirror to check. If the name is provided, the repository need not be added
    to the site (but the site configuration must define a code host that knows how to handle the name).
    """
    name: String
  ): CheckMirrorRepositoryConnectionResult!

  """
  Schedule the mirror repository to be updated from its original source repository. Updating
  occurs automatically, so this should not normally be needed.
  
  Only site admins may perform this mutation.
  """
  updateMirrorRepository(
    """The mirror repository to update."""
    repository: ID!
  ): EmptyResponse!

  """
  Force Zoekt to reindex the repository right now. Reindexing occurs
  automatically, so this should not normally be needed.
  """
  reindexRepository(
    """The repository to index"""
    repository: ID!
  ): EmptyResponse!

  """
  Creates a new user account.
  
  Only site admins may perform this mutation.
  """
  createUser(
    """The new user's username."""
    username: String!

    """
    The new user's optional email address. If given, it must be verified by the user.
    """
    email: String

    """
    Whether or not to mark the provided email address as verified. If unset or set to
    true, then the email address is immediately marked as verified - otherwise, the
    email may be marked as unverified if SMTP and password resets are enabled.
    """
    verifiedEmail: Boolean
  ): CreateUserResult!

  """
  Randomize a user's password so that they need to reset it before they can sign in again.
  
  Only site admins may perform this mutation.
  """
  randomizeUserPassword(user: ID!): RandomizeUserPasswordResult!

  """
  Adds an email address to the user's account. The email address will be marked as unverified until the user
  has followed the email verification process.
  
  Only the user and site admins may perform this mutation.
  """
  addUserEmail(user: ID!, email: String!): EmptyResponse!

  """
  Removes an email address from the user's account.
  
  Only the user and site admins may perform this mutation.
  """
  removeUserEmail(user: ID!, email: String!): EmptyResponse!

  """
  Set an email address as the user's primary.
  
  Only the user and site admins may perform this mutation.
  """
  setUserEmailPrimary(user: ID!, email: String!): EmptyResponse!

  """
  Manually set the verification status of a user's email, without going through the normal verification process
  (of clicking on a link in the email with a verification code).
  
  Only site admins may perform this mutation.
  """
  setUserEmailVerified(user: ID!, email: String!, verified: Boolean!): EmptyResponse!

  """
  Resend a verification email, no op if the email is already verified.
  
  Only the user and site admins may perform this mutation.
  """
  resendVerificationEmail(user: ID!, email: String!): EmptyResponse!

  """
  Deletes a user account. Only site admins may perform this mutation.
  
  If hard == true, a hard delete is performed. By default, deletes are
  'soft deletes' and could theoretically be undone with manual DB commands.
  If a hard delete is performed, the data is truly removed from the
  database and deletion can NEVER be undone.
  
  Data that is deleted as part of this operation:
  
  - All user data (access tokens, email addresses, external account info, survey responses, etc)
  - Organization membership information (which organizations the user is a part
  of, any invitations created by or targeting the user).
  - User, Organization, or Global settings authored by the user.
  """
  deleteUser(user: ID!, hard: Boolean): EmptyResponse

  """Bulk "deleteUser" action."""
  deleteUsers(users: [ID!]!, hard: Boolean): EmptyResponse

  """Bulk "recoverUser" action."""
  recoverUsers(userIDs: [ID!]!): EmptyResponse

  """
  Updates the current user's password. The oldPassword arg must match the user's current password.
  """
  updatePassword(oldPassword: String!, newPassword: String!): EmptyResponse

  """
  Creates a password for the current user. It is only permitted if the user does not have a password.
  """
  createPassword(newPassword: String!): EmptyResponse

  """
  Sets the user to accept the site's Terms of Service and Privacy Policy.
  If the ID is omitted, the current user is assumed.
  
  Only the user or site admins may perform this mutation.
  """
  setTosAccepted(userID: ID): EmptyResponse!

  """Current user opt in/out from being searchable in the users picker."""
  setSearchable(searchable: Boolean!): EmptyResponse!

  """
  Creates an access token that grants the privileges of the specified user (referred to as the access token's
  "subject" user after token creation). The result is the access token value, which the caller is responsible
  for storing (it is not accessible by Sourcegraph after creation).
  
  The supported scopes are:
  
  - "user:all": Full control of all resources accessible to the user account.
  - "site-admin:sudo": Ability to perform any action as any other user. (Only site admins may create tokens
    with this scope.)
  
  Only the user or site admins may perform this mutation.
  """
  createAccessToken(user: ID!, scopes: [String!]!, note: String!): CreateAccessTokenResult!

  """
  Deletes and immediately revokes the specified access token, specified by either its ID or by the token
  itself.
  
  Only site admins or the user who owns the token may perform this mutation.
  """
  deleteAccessToken(byID: ID, byToken: String): EmptyResponse!

  """
  Deletes the association between an external account and its Sourcegraph user. It does NOT delete the external
  account on the external service where it resides.
  
  Only site admins or the user who is associated with the external account may perform this mutation.
  """
  deleteExternalAccount(externalAccount: ID!): EmptyResponse!

  """
  Adds an external account to the authenticated user's account. The service type and service ID
  must correspond to a valid auth provider on the site. The account details must be a stringified
  JSON object that contains valid credentials for the provided service type.
  """
  addExternalAccount(serviceType: String!, serviceID: String!, accountDetails: String!): EmptyResponse!

  """
  Sends an invitation to join Sourcegraph to the given email address.
  
  Returns instantly regardless of whether or not an invitation email was actually sent. For example, the email
  may fail to send if there is a typo or it is invalid, or Sourcegraph may refuse to send it due to spam concerns
  or if the user has been invited too recently.
  """
  inviteEmailToSourcegraph(email: String!): EmptyResponse!

  """
  Invite the user with the given username to join the organization. The invited user account must already
  exist.
  
  Only site admins and any organization member may perform this mutation.
  """
  inviteUserToOrganization(organization: ID!, username: String, email: String): InviteUserToOrganizationResult!

  """
  Accept or reject an existing organization invitation.
  
  Only the recipient of the invitation may perform this mutation.
  """
  respondToOrganizationInvitation(
    """The organization invitation."""
    organizationInvitation: ID!

    """The response to the invitation."""
    responseType: OrganizationInvitationResponseType!
  ): EmptyResponse!

  """
  Resend the notification about an organization invitation to the recipient.
  
  Only site admins and any member of the organization may perform this mutation.
  """
  resendOrganizationInvitationNotification(
    """The organization invitation."""
    organizationInvitation: ID!
  ): EmptyResponse!

  """
  Revoke an existing organization invitation.
  
  If the invitation has been accepted or rejected, it may no longer be revoked. After an
  invitation is revoked, the recipient may not accept or reject it. Both cases yield an error.
  
  Only site admins and any member of the organization may perform this mutation.
  """
  revokeOrganizationInvitation(
    """The organization invitation."""
    organizationInvitation: ID!
  ): EmptyResponse!

  """
  Immediately add a user as a member to the organization, without sending an invitation email.
  
  Only site admins may perform this mutation. Organization members may use the inviteUserToOrganization
  mutation to invite users.
  """
  addUserToOrganization(organization: ID!, username: String!): EmptyResponse!

  """
  Removes a user as a member from an organization.
  
  Only site admins and any member of the organization may perform this mutation.
  """
  removeUserFromOrganization(user: ID!, organization: ID!): EmptyResponse

  """Adds a Phabricator repository to Sourcegraph."""
  addPhabricatorRepo(
    """The callsign, for example "MUX"."""
    callsign: String!

    """The name, for example "github.com/gorilla/mux"."""
    name: String

    """An alias for name. DEPRECATED: use name instead."""
    uri: String

    """
    The URL to the phabricator instance (e.g. http://phabricator.sgdev.org).
    """
    url: String!
  ): EmptyResponse

  """Resolves a revision for a given diff from Phabricator."""
  resolvePhabricatorDiff(
    """The name of the repository that the diff is based on."""
    repoName: String!

    """The ID of the diff on Phabricator."""
    diffID: ID!

    """The base revision this diff is based on."""
    baseRev: String!

    """
    The raw contents of the diff from Phabricator.
    Required if Sourcegraph doesn't have a Conduit API token.
    """
    patch: String

    """The description of the diff. This will be used as the commit message."""
    description: String

    """The name of author of the diff."""
    authorName: String

    """The author's email."""
    authorEmail: String

    """When the diff was created."""
    date: String
  ): GitCommit

  """
  Logs a user event. No longer used, only here for backwards compatibility with IDE and browser extensions.
  """
  logUserEvent(event: UserEvent!, userCookieID: String!): EmptyResponse @deprecated(reason: "use logEvent instead")

  """Logs an event."""
  logEvent(
    """The name of the event."""
    event: String!

    """The randomly generated unique user ID stored in a browser cookie."""
    userCookieID: String!

    """
    The first sourcegraph URL visited by the user, stored in a browser cookie.
    """
    firstSourceURL: String

    """
    The last sourcegraph URL visited by the user, stored in a browser cookie.
    """
    lastSourceURL: String

    """The URL when the event was logged."""
    url: String!

    """The source of the event."""
    source: EventSource!

    """
    An optional cohort ID to identify the user as part of a specific A/B test.
    The cohort ID is expected to be a date in the form YYYY-MM-DD
    """
    cohortID: String

    """
    An optional referrer parameter for the user's current session.
    Only captured and stored on Sourcegraph Cloud.
    """
    referrer: String

    """The original referrer for a user"""
    originalReferrer: String

    """The session referrer for a user"""
    sessionReferrer: String

    """The sessions first url for a user"""
    sessionFirstURL: String

    """Device session ID to identify the user's session for analytics."""
    deviceSessionID: String

    """The additional argument information."""
    argument: String

    """
    Public argument information. PRIVACY: Do NOT include any potentially private information in this field.
    These properties get sent to our analytics tools for Cloud, so must not include private information,
    such as search queries or repository names.
    """
    publicArgument: String

    """
    Device ID used for Amplitude analytics. Used on Sourcegraph Cloud only.
    """
    deviceID: String

    """
    Event ID used to deduplicate events that occur simultaneously in Amplitude analytics.
    See https://developers.amplitude.com/docs/http-api-v2#optional-keys. Used on Sourcegraph Cloud only.
    """
    eventID: Int

    """
    Insert ID used to deduplicate events that re-occur in the event of retries or
    backfills in Amplitude analytics. See https://developers.amplitude.com/docs/http-api-v2#optional-keys.
    Used on Sourcegraph Cloud only.
    """
    insertID: String
  ): EmptyResponse

  """Logs a batch of events."""
  logEvents(events: [Event!]): EmptyResponse

  """
  All mutations that update settings (global, organization, and user settings) are under this field.
  
  Only the settings subject whose settings are being mutated (and site admins) may perform this mutation.
  
  This mutation only affects global, organization, and user settings, not site configuration. For site
  configuration (which is a separate set of configuration properties from global/organization/user settings),
  use updateSiteConfiguration.
  """
  settingsMutation(input: SettingsMutationGroupInput!): SettingsMutation

  """
  DEPRECATED: Use settingsMutation instead. This field is a deprecated alias for settingsMutation and will be
  removed in a future release.
  """
  configurationMutation(input: SettingsMutationGroupInput!): SettingsMutation @deprecated(reason: "use settingsMutation instead")

  """
  Updates the site configuration. Returns whether or not a restart is required for the update to be applied.
  
  Only site admins may perform this mutation.
  """
  updateSiteConfiguration(
    """
    The last ID of the site configuration that is known by the client, to
    prevent race conditions. An error will be returned if someone else
    has already written a new update.
    """
    lastID: Int!

    """
    A JSON object containing the entire site configuration. The previous site configuration will be replaced
    with this new value.
    """
    input: String!
  ): Boolean!

  """
  Sets whether the user with the specified user ID is a site admin.
  
  Only site admins may perform this mutation.
  """
  setUserIsSiteAdmin(userID: ID!, siteAdmin: Boolean!): EmptyResponse

  """
  Invalidates all sessions belonging to a user.
  
  Only site admins may perform this mutation.
  """
  invalidateSessionsByID(userID: ID!): EmptyResponse

  """Bulk "invalidateSessionsByID" action."""
  invalidateSessionsByIDs(userIDs: [ID!]!): EmptyResponse

  """
  Reloads the site by restarting the server. This is not supported for all deployment
  types. This may cause downtime.
  
  Only site admins may perform this mutation.
  """
  reloadSite: EmptyResponse

  """Submits a user satisfaction (NPS) survey."""
  submitSurvey(input: SurveySubmissionInput!): EmptyResponse

  """Submits happiness feedback."""
  submitHappinessFeedback(input: HappinessFeedbackSubmissionInput!): EmptyResponse

  """Creates a saved search."""
  createSavedSearch(description: String!, query: String!, notifyOwner: Boolean!, notifySlack: Boolean!, orgID: ID, userID: ID): SavedSearch!

  """Updates a saved search"""
  updateSavedSearch(id: ID!, description: String!, query: String!, notifyOwner: Boolean!, notifySlack: Boolean!, orgID: ID, userID: ID): SavedSearch!

  """Deletes a saved search"""
  deleteSavedSearch(id: ID!): EmptyResponse

  """
  OBSERVABILITY
  
  Set the status of a test alert of the specified parameters - useful for validating
  'observability.alerts' configuration. Alerts may take up to a minute to fire.
  """
  triggerObservabilityTestAlert(
    """Level of alert to test - either warning or critical."""
    level: String!
  ): EmptyResponse!

  """
  Updates an out-of-band migration to run in a particular direction.
  
  Applied in the forward direction, an out-of-band migration migrates data into a format that
  is readable by newer Sourcegraph instances. This may be destructive or non-destructive process,
  depending on the nature and implementation of the migration.
  
  Applied in the reverse direction, an out-of-band migration ensures that data is moved back into
  a format that is readable by the previous Sourcegraph instance. Recently introduced migrations
  should be applied in reverse prior to downgrading the instance.
  """
  setMigrationDirection(id: ID!, applyReverse: Boolean!): EmptyResponse!

  """EXPERIMENTAL: Create a new feature flag"""
  createFeatureFlag(
    """The name of the feature flag"""
    name: String!

    """
    The value of the feature flag. Only set if the new feature flag
    will be a concrete boolean flag. Mutually exclusive with rolloutBasisPoints.
    """
    value: Boolean

    """
    The ratio of users the feature flag will apply to, expressed in basis points (0.01%).
    Only set if the new feature flag will be a rollout flag.
    Mutually exclusive with value.
    """
    rolloutBasisPoints: Int
  ): FeatureFlag!

  """EXPERIMENTAL: Delete a feature flag"""
  deleteFeatureFlag(
    """The name of the feature flag"""
    name: String!
  ): EmptyResponse!

  """EXPERIMENTAL: Update a feature flag"""
  updateFeatureFlag(
    """The name of the feature flag"""
    name: String!

    """
    The value of the feature flag. Only set if the new feature flag
    will be a concrete boolean flag. Mutually exclusive with rollout.
    """
    value: Boolean

    """
    The ratio of users the feature flag will apply to, expressed in basis points (0.01%).
    Mutually exclusive with value.
    """
    rolloutBasisPoints: Int
  ): FeatureFlag!

  """
  EXPERIMENTAL: Create a new feature flag override for the given org or user
  """
  createFeatureFlagOverride(
    """
    The namespace for this feature flag. Must be either a user ID or an org ID.
    """
    namespace: ID!

    """The name of the feature flag this override applies to"""
    flagName: String!

    """The overridden value"""
    value: Boolean!
  ): FeatureFlagOverride!

  """Delete a feature flag override"""
  deleteFeatureFlagOverride(
    """The ID of the feature flag override to delete"""
    id: ID!
  ): EmptyResponse!

  """Update a feature flag override"""
  updateFeatureFlagOverride(
    """The ID of the feature flag override to update"""
    id: ID!

    """The updated value of the feature flag override"""
    value: Boolean!
  ): FeatureFlagOverride!

  """
  Overwrites and saves the temporary settings for the current user.
  If temporary settings for the user do not exist, they are created.
  """
  overwriteTemporarySettings(
    """The new temporary settings for the current user, as a JSON string."""
    contents: String!
  ): EmptyResponse!

  """
  Merges the given settings edit with the current temporary settings for the current user.
  Keys in the given edit take priority over key in the temporary settings. The merge is
  not recursive.
  If temporary settings for the user do not exist, they are created.
  """
  editTemporarySettings(
    """
    The settings to merge with the current temporary settings for the current user, as a JSON string.
    """
    settingsToEdit: String!
  ): EmptyResponse!

  """
  Sends an email for testing Sourcegraph's email configuration.
  
  Only administrators can use this API.
  """
  sendTestEmail(to: String!): String!

  """
  Enqueues a sync for the external service. It will be picked up in the background.
  
  Site-admin or owner of the external service only.
  """
  syncExternalService(id: ID!): EmptyResponse!

  """
  Cancels an external service sync job. Must be in queued or processing state.
  
  Site-admin or owner of the external service only.
  """
  cancelExternalServiceSync(id: ID!): EmptyResponse!

  """Associate a new key-value pair with a repo."""
  addRepoKeyValuePair(repo: ID!, key: String!, value: String): EmptyResponse! @deprecated(reason: "Use addRepoMetadata instead. This field is a deprecated and will be removed in a future release.")

  """Associate a new key-value pair metadata with a repo."""
  addRepoMetadata(repo: ID!, key: String!, value: String): EmptyResponse!

  """Update a key-value pair associated with a repo."""
  updateRepoKeyValuePair(repo: ID!, key: String!, value: String): EmptyResponse! @deprecated(reason: "Use updateRepoMetadata instead. This field is a deprecated and will be removed in a future release.")

  """
  Update metadata value for a given metadata key for associated with a repo.
  """
  updateRepoMetadata(repo: ID!, key: String!, value: String): EmptyResponse!

  """Delete a key-value pair associated with a repo."""
  deleteRepoKeyValuePair(repo: ID!, key: String!): EmptyResponse! @deprecated(reason: "Use deleteRepoMetadata instead. This field is a deprecated and will be removed in a future release.")

  """Delete a key-value pair metadata associated with a repo."""
  deleteRepoMetadata(repo: ID!, key: String!): EmptyResponse!

  """
  INTERNAL ONLY: Reclone a repository from the gitserver. This involves deleting
  the file on disk, marking it as not-cloned in the database, and then initiating
  a repo clone.
  """
  recloneRepository(repo: ID!): EmptyResponse!

  """
  INTERNAL ONLY: Delete a repository from the gitserver. This involves deleting
  the file on disk, and marking it as not-cloned in the database.
  """
  deleteRepositoryFromDisk(repo: ID!): EmptyResponse!

  """Create a new package repo reference filter."""
  addPackageRepoFilter(
    """Whether the matcher should be for allowlisting or blocklisting."""
    behaviour: PackageMatchBehaviour!

    """
    The ecosystem of the package repo reference this matcher should apply to.
    Maps to the external service whos config would be updated when used in the
    set query.
    """
    kind: PackageRepoReferenceKind!

    """The package repo reference matcher to persist."""
    filter: PackageVersionOrNameFilterInput!
  ): PackageFilter!

  """Updates a package repo reference filter."""
  updatePackageRepoFilter(
    """The ID of the package repo reference filter to update."""
    id: ID!
    behaviour: PackageMatchBehaviour!

    """
    The ecosystem of the package repo reference this matcher should apply to.
    Maps to the external service whos config would be updated when used in the
    set query.
    """
    kind: PackageRepoReferenceKind!
    filter: PackageVersionOrNameFilterInput!
  ): EmptyResponse!

  """Deletes a package repo reference filter."""
  deletePackageRepoFilter(id: ID!): EmptyResponse!

  """
  Sets the completions requests quota for the user per day. Quota: Null means
  use the default quota.
  """
  setUserCompletionsQuota(user: ID!, quota: Int): User!

  """
  Sets the code completions requests quota for the user per day. Quota: Null means
  use the default quota.
  """
  setUserCodeCompletionsQuota(user: ID!, quota: Int): User!

  """Submits a post-signup user survey about intended Cody usage."""
  submitCodySurvey(isForWork: Boolean!, isForPersonal: Boolean!): EmptyResponse!

  """
  Create a new executor secret.
  See argument descriptions for more details.
  """
  createExecutorSecret(
    """The scope for which the secret is usable."""
    scope: ExecutorSecretScope!

    """
    The key under which the secret is known. For executions, this is the name
    of the environment variable this secret will be accessible under.
    It is therefore advised that key only contains uppercase letters, numbers
    and underscores.
    """
    key: String!

    """The secret value."""
    value: String!

    """
    The namespace this secret is for. If not set, a global secret is created
    that is accessible by all users.
    Creating a global secret requires site-admin permissions.
    Creating a namespaced secret requires write-access to the namespace.
    """
    namespace: ID
  ): ExecutorSecret!

  """Update the value of an existing executor secret."""
  updateExecutorSecret(
    """The scope of the secret."""
    scope: ExecutorSecretScope!

    """The identifier of the secret that shall be updated."""
    id: ID!

    """The new secret value."""
    value: String!
  ): ExecutorSecret!

  """Deletes the given executor secret."""
  deleteExecutorSecret(
    """The scope of the secret."""
    scope: ExecutorSecretScope!

    """The identifier of the secret that shall be deleted."""
    id: ID!
  ): EmptyResponse

  """
  Creates a team. The name must be unique, display name can be used to set a custom
  display value for the team inside Sourcegraph.
  
  If readonly is true, the Sourcegraph UI will show a warning banner that this team
  is managed externally, and it can only be modified by site-admins.
  This is to prevent state drift from external systems that ingest team information into Sourcegraph.
  Readonly can only be set by site-admins.
  
  Either parentTeam XOR parentTeamName can be specified to make the team a child
  team of the given parent. Only members of the parent team or site-admis can create
  a child team.
  """
  createTeam(name: String!, displayName: String, readonly: Boolean = false, parentTeam: ID, parentTeamName: String): Team!

  """
  Update an existing team. ID or Name must be specified, but not both.
  
  To unset the display name, pass an empty string. Null will make it ignore updates.
  
  Either parentTeam XOR parentTeamName XOR makeRoot can be specified to make the team a child
  team of the given parent or conversely to make a team a root team (with no parent team).
  The user has to be a team-member of both the child and parent team for that, and
  neither can be read-only. Site-admin can modify all teams without constraints.
  """
  updateTeam(id: ID, name: String, displayName: String, parentTeam: ID, parentTeamName: String, makeRoot: Boolean): Team!

  """
  Delete team deletes a team. ID or Name must be specified, but not both.
  Must be team-member to delete. If the team is marked as read-only, must be site-admin.
  """
  deleteTeam(id: ID, name: String): EmptyResponse

  """
  Add a list of team members to an existing team.
  People that already are part of the team are ignored.
  
  Either team XOR teamName can be specified to specify the team.
  Must be team member to add new team members, or site-admin.
  
  For now, members can only be the IDs of User entities in Sourcegraph.
  Later, we will expand this to allow Persons as well.
  
  If skipUnmatchedMembers is true, members that are not matched to a user are skipped.
  """
  addTeamMembers(team: ID, teamName: String, members: [TeamMemberInput!]!, skipUnmatchedMembers: Boolean = false): Team!

  """
  This is a convenience method to forcefully overwrite the full set of members
  of a team. This is handy to sync external state without diffing the current
  members vs the desired set of members.
  
  Either team XOR teamName can be specified to specify the team.
  Must be team member to modify team members, or site-admin.
  
  For now, members can only be the IDs of User entities in Sourcegraph.
  Later, we will expand this to allow Persons as well.
  
  If skipUnmatchedMembers is true, members that are not matched to a user are skipped.
  """
  setTeamMembers(team: ID, teamName: String, members: [TeamMemberInput!]!, skipUnmatchedMembers: Boolean = false): Team!

  """
  This mutation removes team membership for the given team and set of members.
  Members that weren't part of the team are ignored.
  
  Either team XOR teamName can be specified to specify the team.
  Must be team member to remove team members, or site-admin.
  
  For now, members can only be the IDs of User entities in Sourcegraph.
  Later, we will expand this to allow Persons as well.
  
  If skipUnmatchedMembers is true, members that are not matched to a user are skipped.
  """
  removeTeamMembers(team: ID, teamName: String, members: [TeamMemberInput!]!, skipUnmatchedMembers: Boolean = false): Team!

  """Marks access_request as rejected"""
  setAccessRequestStatus(id: ID!, status: AccessRequestStatus!): EmptyResponse

  """
  Creates a new outbound webhook.
  
  Only site admins have access to this mutation.
  """
  createOutboundWebhook(input: OutboundWebhookCreateInput!): OutboundWebhook!

  """
  Deletes an outbound webhook.
  
  Only site admins have access to this mutation.
  """
  deleteOutboundWebhook(id: ID!): EmptyResponse!

  """
  Updates an outbound webhook.
  
  Only site admins have access to this mutation.
  """
  updateOutboundWebhook(id: ID!, input: OutboundWebhookUpdateInput!): OutboundWebhook!

  """
  Upload a changeset spec that will be used in a future update to a batch change. The changeset spec
  is stored and can be referenced by its ID in the applyBatchChange mutation. Just uploading the
  changeset spec does not result in changes to the batch change or any of its changesets; you need
  to call applyBatchChange to use it.
  
  You can use this mutation to upload large changeset specs (e.g., containing large diffs) in
  individual HTTP requests. Then, in the eventual applyBatchChange call, you just refer to the
  changeset specs by their IDs. This lets you avoid problems when updating large batch changes where
  a large HTTP request body (e.g., with many large diffs in the changeset specs) would be
  rejected by the web server/proxy or would be very slow.
  
  The returned ChangesetSpec is immutable and expires after a certain period of time (if not
  used in a call to applyBatchChange), which can be queried on ChangesetSpec.expiresAt.
  """
  createChangesetSpec(
    """
    The raw changeset spec (as JSON). See
    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/changeset_spec.schema.json
    for the JSON Schema that describes the structure of this input.
    """
    changesetSpec: String!
  ): ChangesetSpec!

  """
  FOR INTERNAL USE ONLY.
  
  Upload multiple changeset specs that will be used in a future update to a batch change. The changeset specs
  are stored and can be referenced by their ID in the applyBatchChange mutation. Just uploading the
  changeset specs does not result in changes to the batch change or any of its changesets; you need
  to call applyBatchChange to use it.
  
  The returned ChangesetSpecs is immutable and expires after a certain period of time (if not
  used in a call to applyBatchChange), which can be queried on ChangesetSpec.expiresAt.
  """
  createChangesetSpecs(
    """
    The raw changeset specs (as JSON). See
    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/changeset_spec.schema.json
    for the JSON Schema that describes the structure of this input.
    """
    changesetSpecs: [String!]!
  ): [ChangesetSpec!]!

  """Enqueue the given changeset for high-priority syncing."""
  syncChangeset(changeset: ID!): EmptyResponse!

  """
  Re-enqueue the changeset for processing by the reconciler. The changeset must be in FAILED state.
  """
  reenqueueChangeset(changeset: ID!): Changeset!

  """
  Create a batch change from a batch spec and locally computed changeset specs. The newly created
  batch change is returned.
  If a batch change in the same namespace with the same name already exists,
  an error with the error code ErrMatchingBatchChangeExists is returned.
  """
  createBatchChange(
    """
    The batch spec that describes the desired state of the batch change.
    It must be in COMPLETED state.
    """
    batchSpec: ID!

    """
    If set, these changeset specs will have their UI publication states set
    to the given values.
    
    An error will be returned if the same changeset spec ID is included
    more than once in the array, or if a changeset spec ID is included with
    a publication state set in its spec.
    """
    publicationStates: [ChangesetSpecPublicationStateInput!]
  ): BatchChange!

  """
  Create a batch spec that will be used to create a batch change (with the createBatchChange
  mutation), or to update an existing batch change (with the applyBatchChange mutation).
  
  The returned BatchSpec is immutable and expires after a certain period of time (if not used
  in a call to applyBatchChange), which can be queried on BatchSpec.expiresAt.
  
  If batch changes are unlicensed and the number of changesetSpecIDs is higher than what's allowed in
  the free tier, an error with the error code ErrBatchChangesUnlicensed is returned.
  """
  createBatchSpec(
    """
    The namespace (either a user or organization). A batch spec can only be applied to (or
    used to create) batch changes in this namespace.
    """
    namespace: ID!

    """
    The batch spec as YAML (or the equivalent JSON). See
    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
    for the JSON Schema that describes the structure of this input.
    """
    batchSpec: String!

    """
    Changeset specs that were locally computed and then uploaded using createChangesetSpec.
    """
    changesetSpecs: [ID!]!
  ): BatchSpec!

  """
  Creates a batch change with an empty batch spec, such as for drafting a new batch
  change. The user creating the batch change must have permission to create it in the
  namespace provided. Use `createBatchSpecFromRaw` and `replaceBatchSpecInput` to update
  the input batch spec after creating.
  """
  createEmptyBatchChange(
    """
    The namespace (either a user or organization) that this batch change should belong to.
    """
    namespace: ID!

    """The (unique) name to identify the batch change by in its namespace."""
    name: String!
  ): BatchChange!

  """
  Checks if a batch change with the specified name exists, if it doesn't, it creates a batch change
  with an empty batch spec otherwise returns the existing batch change, this is useful for drafting
  server-side batch changes with the src-cli tool.
  The user creating the batch change must have permission to create it in the
  namespace provided. Use `createBatchSpecFromRaw` and `replaceBatchSpecInput` to update
  the input batch spec after creating.
  """
  upsertEmptyBatchChange(
    """
    The namespace (either a user or organization) that this batch change should belong to.
    """
    namespace: ID!

    """The (unique) name to identify the batch change by in its namespace."""
    name: String!
  ): BatchChange!

  """
  Creates a batch spec and triggers a job to evaluate the workspaces. Consumers need to
  poll the batch spec until the resolution is completed to get a full list of all
  workspaces. This might become streaming so the results will come in over time.
  
  This mutation should be used when updating an existing batch change whose previous
  batch spec was already applied. When the previous batch spec was not yet applied, you
  can use `replaceBatchSpecInput` instead.
  """
  createBatchSpecFromRaw(
    """
    The raw batch spec as YAML (or the equivalent JSON). See
    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
    for the JSON Schema that describes the structure of this input.
    """
    batchSpec: String!

    """If true, repos with a .batchignore file will still be included."""
    allowIgnored: Boolean = false

    """
    If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot
    be published.
    """
    allowUnsupported: Boolean = false

    """
    Right away set the execute flag.
    
    TODO: Not implemented yet.
    """
    execute: Boolean = false

    """Don't use cache entries."""
    noCache: Boolean = false

    """
    The namespace (either a user or organization). A batch spec can only be applied to (or
    used to create) batch changes in this namespace.
    """
    namespace: ID!

    """The batch change this batch spec is associated with."""
    batchChange: ID!
  ): BatchSpec!

  """
  Replaces the original input of the batch spec. All existing resolution jobs and
  workspaces are deleted and recreated in the background as the `on` section is
  evaluated. This mutation is used for overwriting existing resolutions on unapplied
  batch specs, so after typing in the editor, we don't create 10s of batch specs. The ID
  of the batch spec to update should NEVER be that of a batch spec that was already
  applied to a batch change, or it will be lost.
  
  For creating a new batch spec for a batch change whose previous spec was already
  applied, use `createBatchSpecFromRaw` instead.
  """
  replaceBatchSpecInput(
    """The ID of the batch spec resource to update."""
    previousSpec: ID!

    """
    The raw batch spec as YAML (or the equivalent JSON). See
    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
    for the JSON Schema that describes the structure of this input.
    """
    batchSpec: String!

    """If true, repos with a .batchignore file will still be included."""
    allowIgnored: Boolean = false

    """
    If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot
    be published.
    """
    allowUnsupported: Boolean = false

    """
    Right away set the execute flag.
    
    TODO: Not implemented yet.
    """
    execute: Boolean = false

    """Don't use cache entries."""
    noCache: Boolean = false
  ): BatchSpec!

  """
  Creates or updates a batch spec based on the given namespace and name, then
  triggers a job to evaluate the workspaces.
  
  This is essentially a wrapper for `createBatchSpecFromRaw` and
  `replaceBatchSpecInput` to facilitate src-cli, and should not be used
  otherwise.
  """
  upsertBatchSpecInput(
    """
    The raw batch spec as YAML (or the equivalent JSON). See
    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
    for the JSON Schema that describes the structure of this input.
    """
    batchSpec: String!

    """If true, repos with a .batchignore file will still be included."""
    allowIgnored: Boolean = false

    """
    If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot
    be published.
    """
    allowUnsupported: Boolean = false

    """
    Right away set the execute flag.
    
    TODO: Not implemented yet.
    """
    execute: Boolean = false

    """Don't use cache entries."""
    noCache: Boolean = false

    """
    The namespace (either a user or organization). A batch spec can only be applied to (or
    used to create) batch changes in this namespace.
    """
    namespace: ID!
  ): BatchSpec!

  """
  Deletes the batch spec. All associated jobs will be canceled, if still running.
  This is called by the client, whenever a new run is triggered, to support
  faster cleanups. We will also purge these in the background, but this'll be
  faster.
  """
  deleteBatchSpec(batchSpec: ID!): EmptyResponse!

  """
  Enqueue the workspaces that resulted from evaluation in
  `createBatchSpecFromRaw`to be executed. These will eventually be moved into
  running state. resolution is done, to support fast edits.
  Once the workspace resolution is done, workspace jobs are move to state QUEUED.
  If resolving is already done by the time this mutation is called, they are
  enqueued immediately.
  
  Must be invoked by the _same_ user that called createBatchSpecFromRaw before.
  Can only be invoked once.
  If workspace resolution fails, the running flag should be reset to false. API
  consumers can find this state by looking at BatchSpecWorkspaceResolution.failureMessage.
  
  TODO: This might be blocking with an error for now.
  """
  executeBatchSpec(
    """The ID of the batch spec."""
    batchSpec: ID!

    """
    Don't use cache entries. If set, will overwrite the current batchSpec.NoCache
    state.
    """
    noCache: Boolean

    """
    Right away set the autoApplyEnabled flag on the batch spec.
    
    TODO: Not implemented yet.
    """
    autoApply: Boolean = false
  ): BatchSpec!

  """
  Create or update a batch change from a batch spec and locally computed changeset specs. If no
  batch change exists in the namespace with the name given in the batch spec, a batch change will be
  created. Otherwise, the existing batch change will be updated. The batch change is returned.
  Closed batch changes cannot be applied to. In that case, an error with the error code ErrApplyClosedbatch change
  will be returned.
  """
  applyBatchChange(
    """
    The batch spec that describes the new desired state of the batch change.
    It must be in COMPLETED state.
    """
    batchSpec: ID!

    """
    If set, return an error if the batch change identified using the namespace and batch changeSpec
    parameters does not match the batch change with this ID. This lets callers use a stable ID
    that refers to a specific batch change during an edit session (and is not susceptible to
    conflicts if the underlying batch change is moved to a different namespace, renamed, or
    deleted). The returned error has the error code ErrEnsureBatchChangeFailed.
    """
    ensureBatchChange: ID

    """
    If set, these changeset specs will have their UI publication states set
    to the given values. This will overwrite any existing UI publication
    states on the changesets.
    
    An error will be returned if the same changeset spec ID is included
    more than once in the array, or if a changeset spec ID is included with
    a publication state set in its spec.
    """
    publicationStates: [ChangesetSpecPublicationStateInput!]
  ): BatchChange!

  """Close a batch change."""
  closeBatchChange(
    batchChange: ID!

    """
    Whether to close the changesets associated with this batch change on their respective code
    hosts. "Close" means the appropriate final state on the code host (e.g., "closed" on
    GitHub and "declined" on Bitbucket Server).
    """
    closeChangesets: Boolean = false
  ): BatchChange!

  """
  Move a batch change to a different namespace, or rename it in the current namespace.
  """
  moveBatchChange(batchChange: ID!, newName: String, newNamespace: ID): BatchChange!

  """
  Delete a batch change. A deleted batch change is completely removed and can't be un-deleted. The
  batch change's changesets are kept as-is; to close them, use the closeBatchChange mutation first.
  """
  deleteBatchChange(batchChange: ID!): EmptyResponse

  """
  Create a new credential for the given user for the given code host.
  If another token for that code host already exists, an error with the error code
  ErrDuplicateCredential is returned.
  """
  createBatchChangesCredential(
    """
    The user for which to create the credential. If null is provided, a site-wide credential is created.
    """
    user: ID

    """The kind of external service being configured."""
    externalServiceKind: ExternalServiceKind!

    """The URL of the external service being configured."""
    externalServiceURL: String!

    """
    The username associated with the credential, if required by the external
    service kind.
    """
    username: String

    """
    The credential to be stored. This can never be retrieved through the API and will be stored encrypted.
    """
    credential: String!
  ): BatchChangesCredential!

  """Hard-deletes a given credential."""
  deleteBatchChangesCredential(batchChangesCredential: ID!): EmptyResponse!

  """
  Detach archived changesets from a batch change.
  
  Experimental: This API is likely to change in the future.
  """
  detachChangesets(batchChange: ID!, changesets: [ID!]!): BulkOperation!

  """
  Comment on multiple changesets from a batch change.
  
  Experimental: This API is likely to change in the future.
  """
  createChangesetComments(batchChange: ID!, changesets: [ID!]!, body: String!): BulkOperation!

  """
  Reenqueue multiple changesets for processing.
  
  Experimental: This API is likely to change in the future.
  """
  reenqueueChangesets(batchChange: ID!, changesets: [ID!]!): BulkOperation!

  """
  Merge multiple changesets. If squash is true, the commits will be squashed
  into a single commit on code hosts that support squash-and-merge.
  
  Experimental: This API is likely to change in the future.
  """
  mergeChangesets(batchChange: ID!, changesets: [ID!]!, squash: Boolean = false): BulkOperation!

  """
  Close multiple changesets.
  
  Experimental: This API is likely to change in the future.
  """
  closeChangesets(batchChange: ID!, changesets: [ID!]!): BulkOperation!

  """
  Set the UI publication state for multiple changesets. If draft is true, the
  changesets are published as drafts, provided the code host supports it.
  
  Experimental: This API is likely to change in the future.
  """
  publishChangesets(batchChange: ID!, changesets: [ID!]!, draft: Boolean = false): BulkOperation!

  """
  Attempts to cancel the execution of the given batch spec. All workspace jobs
  that are QUEUED or PROCESSING will be cancelled. The execution must not have completed yet.
  """
  cancelBatchSpecExecution(batchSpec: ID!): BatchSpec!

  """
  Cancel a single workspace execution. Mostly useful in the "try out" UI, but
  can also be used at later stages. Must be in PROCESSING or QUEUED state.
  """
  cancelBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!

  """
  Requeue the workspaces for execution. Previous results and logs will be deleted and
  the executions are _replaced_. The workspaces must be in a final state (COMPLETED, FAILED)
  to be retryable.
  """
  retryBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!

  """
  Requeue all workspaces in the batch spec for execution. Previous results and
  logs will be deleted and the executions are _replaced_. The workspaces must be in
  a final state (COMPLETED, FAILED, CANCELED) to be retryable.
  
  If includeCompleted is set, then workspaces that successfully completed
  execution will also be retried and their changeset specs deleted.
  """
  retryBatchSpecExecution(batchSpec: ID!, includeCompleted: Boolean = false): BatchSpec!

  """
  Enqueue the workspace for execution. The workspace must not be running, and
  not be in a final state. This can be used for running single workspaces before
  running the full set.
  """
  enqueueBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!

  """
  Sets the autoApplyEnabled on the given batch spec. Must be in PROCESSING state.
  
  TODO: Not implemented yet.
  """
  toggleBatchSpecAutoApply(batchSpec: ID!, value: Boolean!): BatchSpec!

  """Deletes a precise index."""
  deletePreciseIndex(id: ID!): EmptyResponse

  """Deletes precise indexes by filter criteria."""
  deletePreciseIndexes(
    """
    An (optional) search query that filters the state, repository name, commit, root, and indexer properties.
    """
    query: String

    """The index state."""
    states: [PreciseIndexState!]

    """
    If supplied, only precise indexes created by an indexer with the given key are modified.
    """
    indexerKey: String

    """
    When specified, only deletes indexes that are latest for the given repository.
    """
    isLatestForRepo: Boolean

    """The repository."""
    repository: ID
  ): EmptyResponse

  """Marks a precise index as replaceable by auto-indexing."""
  reindexPreciseIndex(id: ID!): EmptyResponse

  """
  Marks precise indexes by filter criteria as replaceable by auto-indexing.
  """
  reindexPreciseIndexes(
    """
    An (optional) search query that filters the state, repository name, commit, root, and indexer properties.
    """
    query: String

    """The index state."""
    states: [PreciseIndexState!]

    """
    If supplied, only precise indexes created by an indexer with the given key are modified.
    """
    indexerKey: String

    """
    When specified, only modifies indexes that are latest for the given repository.
    """
    isLatestForRepo: Boolean

    """The repository."""
    repository: ID
  ): EmptyResponse

  """
  Queues the index jobs for a repository for execution. An optional resolvable revhash
  (commit, branch name, or tag name) can be specified; by default the tip of the default
  branch will be used.
  
  If a configuration is supplied, that configuration is used to determine what jobs to
  schedule. If no configuration is supplied, it will go through the regular index scheduling
  rules: first read any in-repo configuration (e.g., sourcegraph.yaml), then look for any
  existing in-database configuration, finally falling back to the automatically inferred
  configuration based on the repo contents at the target commit.
  """
  queueAutoIndexJobsForRepo(repository: ID!, rev: String, configuration: String): [PreciseIndex!]!

  """
  Updates the previously set/overrides the default global auto-indexing job inference Lua script
  with a new override.
  """
  updateCodeIntelligenceInferenceScript(script: String!): EmptyResponse

  """Updates the indexing configuration associated with a repository."""
  updateRepositoryIndexConfiguration(repository: ID!, configuration: String!): EmptyResponse

  """Creates a new configuration policy with the given attributes."""
  createCodeIntelligenceConfigurationPolicy(
    """
    If supplied, the repository to which this configuration policy applies. If not supplied,
    this configuration policy is applied to all repositories.
    """
    repository: ID

    """
    If supplied, the name patterns matching repositories to which this configuration policy
    applies. This option is mutually exclusive with an explicit repository.
    """
    repositoryPatterns: [String!]
    name: String!
    type: GitObjectType!
    pattern: String!
    retentionEnabled: Boolean!
    retentionDurationHours: Int
    retainIntermediateCommits: Boolean!
    indexingEnabled: Boolean!
    indexCommitMaxAgeHours: Int
    indexIntermediateCommits: Boolean!

    """embeddingsEnabled, if not provided, currently defaults to false."""
    embeddingsEnabled: Boolean
  ): CodeIntelligenceConfigurationPolicy!

  """Updates the attributes configuration policy with the given identifier."""
  updateCodeIntelligenceConfigurationPolicy(
    id: ID!
    repositoryPatterns: [String!]
    name: String!
    type: GitObjectType!
    pattern: String!
    retentionEnabled: Boolean!
    retentionDurationHours: Int
    retainIntermediateCommits: Boolean!
    indexingEnabled: Boolean!
    indexCommitMaxAgeHours: Int
    indexIntermediateCommits: Boolean!

    """embeddingsEnabled, if not provided, currently defaults to false."""
    embeddingsEnabled: Boolean
  ): EmptyResponse

  """Deletes the configuration policy with the given identifier."""
  deleteCodeIntelligenceConfigurationPolicy(policy: ID!): EmptyResponse

  """Effectively begins a new ranking map/reduce job."""
  bumpDerivativeGraphKey: EmptyResponse!

  """
  Deletes the ranking progress object associated with a particular graph key.
  """
  deleteRankingProgress(graphKey: String!): EmptyResponse

  """Create a new dashboard."""
  createInsightsDashboard(input: CreateInsightsDashboardInput!): InsightsDashboardPayload!

  """Edit an existing dashboard."""
  updateInsightsDashboard(id: ID!, input: UpdateInsightsDashboardInput!): InsightsDashboardPayload!

  """Delete a dashboard."""
  deleteInsightsDashboard(id: ID!): EmptyResponse!

  """Associate an existing insight view with this dashboard."""
  addInsightViewToDashboard(input: AddInsightViewToDashboardInput!): InsightsDashboardPayload!

  """Remove an insight view from a dashboard."""
  removeInsightViewFromDashboard(input: RemoveInsightViewFromDashboardInput!): InsightsDashboardPayload!

  """Update an insight series. Restricted to admins only."""
  updateInsightSeries(input: UpdateInsightSeriesInput!): InsightSeriesMetadataPayload

  """Create a line chart backed by search insights."""
  createLineChartSearchInsight(input: LineChartSearchInsightInput!): InsightViewPayload!

  """Create a pie chart backed by search insights."""
  createPieChartSearchInsight(input: PieChartSearchInsightInput!): InsightViewPayload!

  """Update a line chart backed by search insights."""
  updateLineChartSearchInsight(id: ID!, input: UpdateLineChartSearchInsightInput!): InsightViewPayload!

  """Update a pie chart backed by search insights."""
  updatePieChartSearchInsight(id: ID!, input: UpdatePieChartSearchInsightInput!): InsightViewPayload!

  """Delete an insight view given the graphql ID."""
  deleteInsightView(id: ID!): EmptyResponse!

  """Create a new insight view from an existing view."""
  saveInsightAsNewView(input: SaveInsightAsNewViewInput!): InsightViewPayload!

  """
  Retry the backfill for a failed insight series given the graphql ID of the
  InsightBackfillQueueItem. Can only be used by a site admin.
  """
  retryInsightSeriesBackfill(id: ID!): InsightBackfillQueueItem!

  """
  Updates the priority of an insight series backfill making it the highest
  priority given the graphql ID of the InsightBackfillQueueItem.
  """
  moveInsightSeriesBackfillToFrontOfQueue(id: ID!): InsightBackfillQueueItem!

  """
  Updates the priority of an insight series backfill making it the lowest
  priority given the graphql ID of the InsightBackfillQueueItem
  """
  moveInsightSeriesBackfillToBackOfQueue(id: ID!): InsightBackfillQueueItem!

  """
  Set the permissions of a repository (i.e., which users may view it on Sourcegraph). This
  operation overwrites the previous permissions for the repository.
  """
  setRepositoryPermissionsForUsers(
    """The repository whose permissions to set."""
    repository: ID!

    """
    A list of user identifiers and their repository permissions, which defines the set of
    users who may view the repository. All users not included in the list will not be
    permitted to view the repository on Sourcegraph.
    """
    userPermissions: [UserPermissionInput!]!
  ): EmptyResponse!

  """
  Set 'unrestricted' to true or false on a set of repositories. Repositories with
  'unrestricted' true will be visible to all users on the Sourcegraph instance.
  """
  setRepositoryPermissionsUnrestricted(
    """
    The repository ids we want to set unrestricted permissions on. Must not contain duplicates.
    """
    repositories: [ID!]!

    """
    true: Any user can view the repo
    false: Use existing repo permissions
    """
    unrestricted: Boolean!
  ): EmptyResponse!

  """
  Schedule a permissions sync for given repository. This queries the repository's code host for
  all users' permissions associated with the repository, so that the current permissions apply
  to all users' operations on that repository on Sourcegraph.
  """
  scheduleRepositoryPermissionsSync(repository: ID!): EmptyResponse!

  """
  Schedule a permissions sync for given user. This queries all code hosts for the user's current
  repository permissions and syncs them to Sourcegraph, so that the current permissions apply to
  the user's operations on Sourcegraph.
  """
  scheduleUserPermissionsSync(
    """User to schedule a sync for."""
    user: ID!

    """Additional options when performing a sync."""
    options: FetchPermissionsOptions
  ): EmptyResponse!

  """
  Set the sub-repo permissions of a repository (i.e., which paths are allowed or disallowed for
  a particular user). This operation overwrites the previous sub-repo permissions for the
  repository.
  """
  setSubRepositoryPermissionsForUsers(
    """The repository whose permissions to set."""
    repository: ID!

    """
    A list of user identifiers and their sub-repository permissions, which defines the set of
    paths within the repository they can access.
    """
    userPermissions: [UserSubRepoPermission!]!
  ): EmptyResponse!

  """
  Set the repository permissions for a given Bitbucket project. This mutation will apply the user
  given permissions to all the repositories that are part of the Bitbucket project as identified by the
  project key and all the users that have access to each repository.
  """
  setRepositoryPermissionsForBitbucketProject(
    """
    Bitbucket project key of which all repository permissions will be updated.
    """
    projectKey: String!

    """The bitbucket code host's GraphQL ID where this project is located."""
    codeHost: ID!

    """
    A list of user identifiers and their repository permissions, which defines the set of
    users who may view the repository. All users not included in the list will not be
    permitted to view the repository on Sourcegraph.
    """
    userPermissions: [UserPermissionInput!]!

    """
    Flag to indicate if ALL repositories under the project will allow
    unrestricted access to all users who have access to the code host.
    """
    unrestricted: Boolean
  ): EmptyResponse!

  """
  Cancel permissions sync job with given ID.
  No error is returned when the job is not in `queued` state or there is no such job
  with the given ID (latter means that most probably, the job has already been cleaned up).
  """
  cancelPermissionsSyncJob(
    """ID of the job to be canceled."""
    job: ID!

    """Optional cancellation reason."""
    reason: String
  ): CancelPermissionsSyncJobResultMessage!

  """Create a code monitor."""
  createCodeMonitor(
    """A monitor."""
    monitor: MonitorInput!

    """A trigger."""
    trigger: MonitorTriggerInput!

    """A list of actions."""
    actions: [MonitorActionInput!]!
  ): Monitor!

  """Set a code monitor to active/inactive."""
  toggleCodeMonitor(
    """The id of a code monitor."""
    id: ID!

    """Whether the code monitor should be enabled or not."""
    enabled: Boolean!
  ): Monitor!

  """Delete a code monitor."""
  deleteCodeMonitor(
    """The id of a code monitor."""
    id: ID!
  ): EmptyResponse!

  """
  Update a code monitor. We assume that the request contains a complete code monitor,
  including its trigger and all actions. Actions which are stored in the database,
  but are missing from the request will be deleted from the database. Actions with id=null
  will be created.
  """
  updateCodeMonitor(
    """The input required to edit a monitor."""
    monitor: MonitorEditInput!

    """
    The input required to edit the trigger of a monitor. You can only edit triggers that are
    associated with the monitor (value of field monitor).
    """
    trigger: MonitorEditTriggerInput!

    """
    The input required to edit the actions of a monitor. You can only edit actions that are
    associated with the monitor (value of field monitor).
    """
    actions: [MonitorEditActionInput!]!
  ): Monitor!

  """
  Reset the timestamps of a trigger query. The query will be queued immediately and return
  all results without a limit on the timeframe. Only site admins may perform this mutation.
  """
  resetTriggerQueryTimestamps(
    """The id of the trigger query."""
    id: ID!
  ): EmptyResponse!

  """Triggers a test email for a code monitor action."""
  triggerTestEmailAction(namespace: ID!, description: String!, email: MonitorEmailInput!): EmptyResponse!

  """Triggers a test webhook call for a code monitor action."""
  triggerTestWebhookAction(namespace: ID!, description: String!, webhook: MonitorWebhookInput!): EmptyResponse!

  """Triggers a test Slack webhook message for a code monitor action."""
  triggerTestSlackWebhookAction(namespace: ID!, description: String!, slackWebhook: MonitorSlackWebhookInput!): EmptyResponse!

  """
  Delete a GitHub App. The GitHub App, along with all of its associated code host connections and
  authentication provider, will be deleted.
  """
  deleteGitHubApp(gitHubApp: ID!): EmptyResponse

  """
  Mutations that are only used on Sourcegraph.com.
  
  FOR INTERNAL USE ONLY.
  """
  dotcom: DotcomMutation!

  """Create search context."""
  createSearchContext(
    """Search context input."""
    searchContext: SearchContextInput!

    """List of search context repository revisions."""
    repositories: [SearchContextRepositoryRevisionsInput!]!
  ): SearchContext!

  """Delete search context."""
  deleteSearchContext(id: ID!): EmptyResponse!

  """Update search context."""
  updateSearchContext(
    """Search context ID."""
    id: ID!

    """Search context input."""
    searchContext: SearchContextEditInput!

    """List of search context repository revisions."""
    repositories: [SearchContextRepositoryRevisionsInput!]!
  ): SearchContext!

  """
  Add a star on a search context for the specified user.
  Only one star can be created per context and user pair.
  If the star already exists, this is a no-op.
  """
  createSearchContextStar(searchContextID: ID!, userID: ID!): EmptyResponse!

  """
  Delete a star on a search context for the specified user.
  If the star does not exist, this is a no-op.
  """
  deleteSearchContextStar(searchContextID: ID!, userID: ID!): EmptyResponse!

  """Set the default search context for the specified user."""
  setDefaultSearchContext(searchContextID: ID!, userID: ID!): EmptyResponse!

  """Create a notebook."""
  createNotebook(
    """Notebook input."""
    notebook: NotebookInput!
  ): Notebook!

  """Update a notebook. Only the owner can update it."""
  updateNotebook(
    """Notebook ID."""
    id: ID!

    """Notebook input."""
    notebook: NotebookInput!
  ): Notebook!

  """Delete a notebook. Only the owner can delete it."""
  deleteNotebook(id: ID!): EmptyResponse!

  """
  Create a notebook star for the current user.
  Only one star can be created per notebook and user pair.
  """
  createNotebookStar(notebookID: ID!): NotebookStar!

  """Delete the notebook star for the current user, if exists."""
  deleteNotebookStar(notebookID: ID!): EmptyResponse!

  """
  Experimental: Schedules a job to create an embedding search index for each
  listed repository. The indices are used for embeddings search.
  If force is set to true, then the repo will be re-embedded even if there's already an up-to-date embeddings index.
  """
  scheduleRepositoriesForEmbedding(repoNames: [String!]!, force: Boolean): EmptyResponse!

  """
  Experimental: Cancels the embedding job with the given ID. The job must exist
  and be in either 'processing' or 'queued' state.
  """
  cancelRepoEmbeddingJob(job: ID!): EmptyResponse!

  """
  Deletes a role. This mutation targets only non-system roles.
  Any users who were assigned to the role will be unassigned and lose any permissions associated with it.
  """
  deleteRole(role: ID!): EmptyResponse!

  """Creates a role."""
  createRole(name: String!, permissions: [ID!]!): Role!

  """
  Set permissions for role. This updates the permissions assigned to a role based on the `permissions` passed
  in the argument. Permissions already assigned to the role that aren't part of the arguments of this mutation
  will be revoked for the role.
  """
  setPermissions(role: ID!, permissions: [ID!]!): EmptyResponse!

  """
  Set roles for a user. Similar to `setPermissions`, this updates the roles assigned to a user based on the `roles`
  passed in the argument. Permissions already assigned to the role that aren't part of the arguments of this
  mutation will be revoked for the role.
  """
  setRoles(user: ID!, roles: [ID!]!): EmptyResponse!

  """
  addCodeownersFile creates a new Codeowners file for the given repository and file contents.
  """
  addCodeownersFile(input: CodeownersFileInput!): CodeownersIngestedFile!

  """
  updateCodeownersFile updates an existing Codeowners file for a repository.
  """
  updateCodeownersFile(input: CodeownersFileInput!): CodeownersIngestedFile!

  """
  deleteCodeownersFiles deletes any existing Codeowners file for the given repositories.
  """
  deleteCodeownersFiles(repositories: [DeleteCodeownersFilesInput!]!): EmptyResponse

  """
  updateOwnSignalConfigurations updates any configurations keyed by name. It will do nothing if the key doesn't exist.
  """
  updateOwnSignalConfigurations(input: UpdateSignalConfigurationsInput!): [OwnSignalConfiguration!]!

  """assignOwner creates a new assigned owner."""
  assignOwner(input: AssignOwnerOrTeamInput!): EmptyResponse

  """removeAssignedOwner removes an assigned owner."""
  removeAssignedOwner(input: AssignOwnerOrTeamInput!): EmptyResponse

  """assignTeam creates a new assigned team."""
  assignTeam(input: AssignOwnerOrTeamInput!): EmptyResponse

  """removeAssignedTeam removes an assigned owner."""
  removeAssignedTeam(input: AssignOwnerOrTeamInput!): EmptyResponse
}

"""
A namespace is a container for certain types of data and settings, such as a user or organization.
"""
interface Namespace {
  """The globally unique ID of this namespace."""
  id: ID!

  """
  The name of this namespace's component. For a user, this is the username. For an organization,
  this is the organization name.
  """
  namespaceName: String!

  """The URL to this namespace."""
  url: String!
}

"""
A list of repositories.

The old `RepositoryConnection` is deprecated and is replaced by
this new connection which support proper cursor based pagination.
The new connection does not include `precise` argument for totalCount.
"""
type NewRepositoryConnection {
  """A list of repositories."""
  nodes: [Repository!]!

  """The total count of repositories in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""A paginated connection for users."""
type NewUsersConnection implements Connection {
  """A list of users."""
  nodes: [User!]!

  """The total number of users in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""An object with an ID."""
interface Node {
  """The ID of the node."""
  id: ID!
}

"""Information regarding the results of an exhaustive search aggregation"""
type NonExhaustiveSearchAggregationResult {
  """A list of the first [LIMIT] aggregation groups in decreasing order"""
  groups: [AggregationGroup!]!

  """
  Boolean indicating if the search query support being persisted as an insight on a dashboard
  """
  supportsPersistence: Boolean

  """
  A count to capture the total number of results that are not included in the list of values returned.
  """
  otherResultCount: Int

  """
  An approximate count of the total number of aggregation groups that were not available in the values list
  """
  approximateOtherGroupCount: Int

  """The SearchAggregationMode the results relate to"""
  mode: SearchAggregationMode!
}

"""
FOR INTERNAL USE ONLY: A status message produced when there are no repositories and no sync jobs in process
"""
type NoRepositoriesDetected {
  """The message of this status message"""
  message: String!
}

"""
An enum to describe the reasons why search aggregations are not available
"""
enum NotAvailableReasonType {
  INVALID_QUERY
  INVALID_AGGREGATION_MODE_FOR_QUERY
  TIMEOUT_EXTENSION_AVAILABLE
  TIMEOUT_NO_EXTENSION_AVAILABLE
  OTHER_ERROR
}

"""A notebook with an array of blocks."""
type Notebook implements Node {
  """The unique id of the notebook."""
  id: ID!

  """The title of the notebook."""
  title: String!

  """Array of notebook blocks."""
  blocks: [NotebookBlock!]!

  """User that created the notebook or null if the user was removed."""
  creator: User

  """User that last updated the notebook or null if that user was removed."""
  updater: User

  """Notebook namespace or null if the namespace (user or org) was removed."""
  namespace: Namespace

  """
  Public property controls the visibility of the notebook. A public notebook is available to
  any user on the instance. Private notebooks are only available to their creators.
  """
  public: Boolean!

  """Date and time the notebook was last updated."""
  updatedAt: DateTime!

  """Date and time the notebook was created."""
  createdAt: DateTime!

  """If current viewer can manage (edit, delete) the notebook."""
  viewerCanManage: Boolean!

  """If current viewer has starred the notebook."""
  viewerHasStarred: Boolean!

  """Notebook stars."""
  stars(
    """Returns the first n notebook stars from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): NotebookStarConnection!
}

"""
Notebook blocks are a union of distinct block types: Markdown, Query, File, Symbol, and Compute.
"""
union NotebookBlock = MarkdownBlock | QueryBlock | FileBlock | SymbolBlock

"""Enum of possible block types."""
enum NotebookBlockType {
  MARKDOWN
  QUERY
  FILE
  SYMBOL
}

"""A paginated list of notebooks."""
type NotebookConnection {
  """A list of notebooks."""
  nodes: [Notebook!]!

  """The total number of notebooks in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Input for a new notebook."""
input NotebookInput {
  """The title of the notebook."""
  title: String!

  """Array of notebook blocks."""
  blocks: [CreateNotebookBlockInput!]!

  """
  Notebook namespace (user or org). Controls the visibility of the notebook
  and who can edit the notebook. Only the notebook creator can update the namespace.
  """
  namespace: ID!

  """
  Public property controls the visibility of the notebook. A public notebook is available to
  any user on the instance. Private notebooks are only available to their creators.
  """
  public: Boolean!
}

"""NotebooksOrderBy enumerates the ways notebooks can be ordered."""
enum NotebooksOrderBy {
  NOTEBOOK_UPDATED_AT
  NOTEBOOK_CREATED_AT
  NOTEBOOK_STAR_COUNT
}

"""A notebook star."""
type NotebookStar {
  """User that starred the notebook."""
  user: User!

  """Date and time the notebook star was created."""
  createdAt: DateTime!
}

"""A paginated list of notebook stars."""
type NotebookStarConnection {
  """A list of notebook stars."""
  nodes: [NotebookStar!]!

  """The total number of notebook stars in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""An organization, which is a group of users."""
type Org implements Node & SettingsSubject & Namespace {
  """The unique ID for the organization."""
  id: ID!

  """
  The organization's name. This is unique among all organizations on this Sourcegraph site.
  """
  name: String!

  """The organization's chosen display name."""
  displayName: String

  """The date when the organization was created."""
  createdAt: DateTime!

  """A list of users who are members of this organization."""
  members(
    """The limit argument for forward pagination."""
    first: Int

    """The limit argument for backward pagination."""
    last: Int

    """The cursor argument for forward pagination."""
    after: String

    """The cursor argument for backward pagination."""
    before: String

    """Return users whose usernames or display names match the query."""
    query: String
  ): NewUsersConnection!

  """
  The latest settings for the organization.
  Only organization members and site admins can access this field.
  """
  latestSettings: Settings

  """
  All settings for this organization, and the individual levels in the settings cascade (global > organization)
  that were merged to produce the final merged settings.
  Only organization members and site admins can access this field.
  """
  settingsCascade: SettingsCascade!

  """DEPRECATED"""
  configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")

  """
  DEPRECATED
  A pending invitation for the viewer to join this organization, if any.
  """
  viewerPendingInvitation: OrganizationInvitation @deprecated(reason: "Use invitationByToken operation instead. This field is deprecated and will be removed in a future release.")

  """
  Whether the viewer has admin privileges on this organization. Currently, all of an organization's members
  have admin privileges on the organization.
  """
  viewerCanAdminister: Boolean!

  """Whether the viewer is a member of this organization."""
  viewerIsMember: Boolean!

  """The URL to the organization."""
  url: String!

  """The URL to the organization's settings."""
  settingsURL: String

  """
  The name of this user namespace's component. For organizations, this is the organization's name.
  """
  namespaceName: String!

  """
  The list of all available executor secrets for execution in this orgs namespace.
  """
  executorSecrets(
    """The scope for which secrets shall be returned."""
    scope: ExecutorSecretScope!

    """Only return N records."""
    first: Int = 50

    """Opaque cursor for pagination."""
    after: String
  ): ExecutorSecretConnection!

  """A list of batch changes initially applied in this organization."""
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!
}

"""An invitation to join an organization as a member."""
type OrganizationInvitation implements Node {
  """The ID of the invitation."""
  id: ID!

  """The organization that the invitation is for."""
  organization: Org!

  """The user who sent the invitation."""
  sender: User!

  """The user who received the invitation."""
  recipient: User

  """The email address that the invitation was sent to."""
  recipientEmail: String

  """The date when this invitation was created."""
  createdAt: DateTime!

  """
  The most recent date when a notification was sent to the recipient about this invitation.
  """
  notifiedAt: DateTime

  """The date when this invitation was responded to by the recipient."""
  respondedAt: DateTime

  """The recipient's response to this invitation, or no response (null)."""
  responseType: OrganizationInvitationResponseType

  """
  The URL where the recipient can respond to the invitation when pending, or null if not pending.
  """
  respondURL: String

  """The date when this invitation was revoked."""
  revokedAt: DateTime

  """The date when this invitation is going to expire."""
  expiresAt: DateTime

  """
  Boolean flag which returns true if the email on the invite matches a verified email of the user
  """
  isVerifiedEmail: Boolean
}

"""
The recipient's possible responses to an invitation to join an organization as a member.
"""
enum OrganizationInvitationResponseType {
  """The invitation was accepted by the recipient."""
  ACCEPT

  """The invitation was rejected by the recipient."""
  REJECT
}

"""An organization membership."""
type OrganizationMembership {
  """The organization."""
  organization: Org!

  """The user."""
  user: User!

  """The time when this was created."""
  createdAt: DateTime!

  """The time when this was updated."""
  updatedAt: DateTime!
}

"""A list of organization memberships."""
type OrganizationMembershipConnection {
  """A list of organization memberships."""
  nodes: [OrganizationMembership!]!

  """
  The total count of organization memberships in the connection. This total count may be larger than the number
  of nodes in this object when the result is paginated.
  """
  totalCount: Int!
}

"""A list of organizations."""
type OrgConnection {
  """A list of organizations."""
  nodes: [Org!]!

  """
  The total count of organizations in the connection. This total count may be larger
  than the number of nodes in this object when the result is paginated.
  """
  totalCount: Int!
}

"""Result organization members count and pending invitations count."""
type OrgMembersSummary {
  """The unique ID for the Org."""
  id: ID!

  """Total number of members for the org."""
  membersCount: Int!

  """Total number of pending invites for the org."""
  invitesCount: Int!
}

"""A single outbound request."""
type OutboundRequest implements Node {
  """The request log item ID."""
  id: ID!

  """The time the request was sent at."""
  startedAt: DateTime!

  """The method used in the HTTP request. E.g. GET, POST, etc."""
  method: String!

  """The full URL the request was sent to."""
  url: String!

  """The headers sent with the HTTP request."""
  requestHeaders: [HTTPHeader!]!

  """The body content of the HTTP message."""
  requestBody: String!

  """The HTTP status code received."""
  statusCode: Int!

  """The headers received with the HTTP response."""
  responseHeaders: [HTTPHeader!]!

  """The total time the request took to complete, in milliseconds."""
  durationMs: Int!

  """
  Any error message got from the request Doer in case of an error, otherwise an empty string.
  """
  errorMessage: String!

  """
  Stack information to figure out where the ExternalClientFactory was created.
  """
  creationStackFrame: String!

  """
  Stack information to figure out where in the code base the request was initiated.
  """
  callStack: String!
}

"""A list of logged outbound requests."""
type OutboundRequestConnection {
  """A list of outbound requests."""
  nodes: [OutboundRequest!]!

  """The total number of outbound request log items in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""An outbound webhook registered within Sourcegraph."""
type OutboundWebhook implements Node {
  """The outbound webhook ID."""
  id: ID!

  """The outbound webhook URL."""
  url: String!

  """The event types that the outbound webhook will receive."""
  eventTypes: [OutboundWebhookScopedEventType]!

  """
  Stats on the payloads dispatched to this outbound webhook within the webhook
  log retention period.
  """
  stats: OutboundWebhookLogStats!

  """
  Logged payloads sent to this outbound webhook, optionally filtered by error
  state. Logs are considered "errored" when either a network error occurred
  while dispatching the payload, or when a HTTP response outside the range
  [100, 399].
  
  Logs will be returned in time order, from newest to oldest.
  """
  logs(first: Int = 50, after: String, onlyErrors: Boolean): OutboundWebhookLogConnection!
}

"""A list of outbound webhooks."""
type OutboundWebhookConnection {
  """The outbound webhooks in the current page."""
  nodes: [OutboundWebhook!]!

  """The total number of matching outbound webhooks."""
  totalCount: Int!

  """Connection page metadata."""
  pageInfo: PageInfo!
}

"""Input for the createOutboundWebhook mutation."""
input OutboundWebhookCreateInput {
  """The outbound webhook URL."""
  url: String!

  """The secret shared with the outbound webhook."""
  secret: String!

  """
  The event types the outbound webhook will receive.
  
  At least one event type must be provided.
  """
  eventTypes: [OutboundWebhookScopedEventTypeInput!]!
}

"""An event type that a webhook can be registered to be notified of."""
type OutboundWebhookEventType {
  """
  The event type key, as used when constructing
  OutboundWebhookScopedEventTypeInput instances and as returned in
  OutboundWebhook.eventTypes.
  """
  key: String!

  """A human readable description of the event type."""
  description: String!
}

"""
An outbound webhook job, which singularly represents an individual event that
may generate one or more webhook payloads.
"""
type OutboundWebhookJob {
  """The outbound webhook job ID."""
  id: ID!

  """The event type."""
  eventType: String!

  """The scope. Currently unused."""
  scope: String

  """
  The payload sent to each outbound webhook registered for this event type.
  """
  payload: String!
}

"""A single logged request sent to an outbound webhook."""
type OutboundWebhookLog {
  """The log ID."""
  id: ID!

  """The outbound webhook job that triggered the request."""
  job: OutboundWebhookJob!

  """When the request was sent."""
  sentAt: DateTime!

  """
  The status code returned from the outbound webhook, or 0 if a network error
  occurred.
  """
  statusCode: Int!

  """The request sent to the outbound webhook."""
  request: WebhookLogRequest!

  """
  The response received from the outbound webhook, or null if no response was
  received due to a network error.
  """
  response: WebhookLogResponse

  """The error message if a network error occurred."""
  error: String
}

"""A list of outbound webhook logs."""
type OutboundWebhookLogConnection {
  """The logs in the current page."""
  nodes: [OutboundWebhookLog!]!

  """The total number of matching outbound webhook logs."""
  totalCount: Int!

  """Connection page metadata."""
  pageInfo: PageInfo!
}

"""Stats on outbound webhook logs."""
type OutboundWebhookLogStats {
  """
  The total number of webhook payloads logged over the webhook log retention
  period.
  """
  total: Int!

  """
  The total number of webhook payloads logged over the webhook log retention
  period that resulted in errors from the webhook.
  """
  errored: Int!
}

"""An event type an outbound webhook has opted to receive."""
type OutboundWebhookScopedEventType {
  """
  The event type, which must match a key returned from
  outboundWebhookEventTypes.
  """
  eventType: String!

  """
  An optional scope for the event type.
  
  Currently unused.
  """
  scope: String
}

"""Event type input for the outbound webhook mutations."""
input OutboundWebhookScopedEventTypeInput {
  """
  The event type, which must match a key returned from
  outboundWebhookEventTypes.
  """
  eventType: String!

  """
  An optional scope for the event type.
  
  Currently unused.
  """
  scope: String
}

"""Input for the updateOutboundWebhook mutation."""
input OutboundWebhookUpdateInput {
  """The outbound webhook URL."""
  url: String!

  """
  The event types the outbound webhook will receive. This list replaces the
  event types previously registered on the webhook.
  
  At least one event type must be provided.
  """
  eventTypes: [OutboundWebhookScopedEventTypeInput!]!
}

"""
An out-of-band migration is a process that runs in the background of the instance that moves
data from one format into another format. Out-of-band migrations
"""
type OutOfBandMigration implements Node {
  """The unique identifier of this migration."""
  id: ID!

  """The team that owns this migration (e.g., code-intelligence)."""
  team: String!

  """
  The component this migration affects (e.g., codeintel-db.lsif_data_documents).
  """
  component: String!

  """A human-readable summary of the migration."""
  description: String!

  """
  The Sourcegraph version in which this migration was introduced. The format of this version
  includes only major and minor parts separated by a dot. The patch version can always be assumed
  to be zero as we'll never introduce or deprecate an out-of-band migration within a patch release.
  
  It is necessary to completely this migration in reverse (if destructive) before downgrading
  to or past this version. Otherwise, the previous instance version will not be aware of the
  new data format.
  """
  introduced: String!

  """
  The Sourcegraph version by which this migration is assumed to have completed. The format of
  this version mirrors introduced and includes only major and minor parts separated by a dot.
  
  It is necessary to have completed this migration before upgrading to or past this version.
  Otherwise, the next instance version will no longer be aware of the old data format.
  """
  deprecated: String

  """
  The progress of the migration (in the forward direction). In the range [0, 1].
  """
  progress: Float!

  """The time the migration record was inserted."""
  created: DateTime!

  """The last time the migration progress or error list was updated."""
  lastUpdated: DateTime

  """
  If false, the migration moves data destructively, and a previous version of Sourcegraph
  will encounter errors when interfacing with the target data unless the migration is first
  run in reverse prior to a downgrade.
  """
  nonDestructive: Boolean!

  """If true, the migration will run in reverse."""
  applyReverse: Boolean!

  """
  A list of errors that have occurred while performing this migration (in either direction).
  This list is bounded by a maximum size, and older errors will replaced by newer errors as
  the list capacity is reached.
  """
  errors: [OutOfBandMigrationError!]!
}

"""An error that occurred while performing an out-of-band migration."""
type OutOfBandMigrationError {
  """The error message."""
  message: String!

  """The time the error occurred."""
  created: DateTime!
}

"""Ownables are resources that can have ownership information attached."""
interface Ownable {
  """Ownership summary for this entity."""
  ownership(
    """Returns the first n ownership records from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Return only ownership for the given reasons."""
    reasons: [OwnershipReasonType!]
  ): OwnershipConnection!
}

"""An owner is any entity that can own other resources."""
union Owner = Person | Team

"""
Ownership is the collection of data points that make Sourcegraph suggest the contained
owner as owner of the Ownable this is attached to.
"""
type Ownership {
  """The owner this entry refers to. Can be a person or a team."""
  owner: Owner!

  """The reasons why Sourcegraph determined this entity as an owner."""
  reasons: [OwnershipReason!]!
}

"""A list of ownership entries."""
type OwnershipConnection {
  """The total count of items in the connection."""
  totalCount: Int!

  """
  The total number of owners in this connection.
  Here an owner is as opposed to an ownership inference signal.
  """
  totalOwners: Int!

  """The pagination info for the connection."""
  pageInfo: PageInfo!

  """The page set of Ownership entries in this connection."""
  nodes: [Ownership!]!
}

"""A union of all the different ownership reasons."""
union OwnershipReason = CodeownersFileEntry | RecentContributorOwnershipSignal | RecentViewOwnershipSignal | AssignedOwner

"""
The only way we can recognize ownership at this point is through CODEOWNERS file entry.
"""
enum OwnershipReasonType {
  CODEOWNERS_FILE_ENTRY
  ASSIGNED_OWNER
  RECENT_CONTRIBUTOR_OWNERSHIP_SIGNAL
  RECENT_VIEW_OWNERSHIP_SIGNAL
}

"""
Statistics about code ownership computed for given context (usually a repository or directory).
"""
type OwnershipStats {
  """Total files considered for ownership statistics (owned + unowned)."""
  totalFiles: Int!

  """Total files with ownership stemming from CODEOWNERS files."""
  totalCodeownedFiles: Int!

  """Total files with any ownership defined (both CODEOWNERS and assigned)."""
  totalOwnedFiles: Int!

  """Total files with assigned ownership."""
  totalAssignedOwnershipFiles: Int!
}

"""
OwnSignalConfiguration represents the configuration for an ownership signal.
"""
type OwnSignalConfiguration {
  """The name of the signal configuration, this serves as the primary key."""
  name: String!

  """The description of the signal configuration."""
  description: String!

  """Whether or not the signal configuration is enabled."""
  isEnabled: Boolean!

  """A list of repository name patterns to exclude from the signal."""
  excludedRepoPatterns: [String!]!
}

"""
OwnSignalConfigurationUpdate represents an update to an OwnSignalConfiguration.
"""
input OwnSignalConfigurationUpdate {
  """A list of repository name patterns to exclude from the signal."""
  excludedRepoPatterns: [String!]!

  """Whether or not the signal configuration should be enabled."""
  enabled: Boolean!

  """The new name for the signal configuration."""
  name: String!
}

"""
Filters package repo references of the matching scheme/kind, applying to either
references of matching names or versions of a specific package name.
One of either nameFilter or versionFilter must be provided.
"""
type PackageFilter {
  """Opaque ID string."""
  id: ID!

  """
  The behaviour of the filter when applied to a matching package repo reference or version.
  """
  behaviour: PackageMatchBehaviour!

  """
  The schemes/kinds of package repo references this filter should apply to only.
  """
  kind: PackageRepoReferenceKind!

  """Optional name-matching filter."""
  nameFilter: PackageNameFilter

  """Optional package-specific version-matching filter."""
  versionFilter: PackageVersionFilter
}

"""
Whether a package repo reference filter is part of the allowlist or blocklist
"""
enum PackageMatchBehaviour {
  """Blocks a package repo reference from syncing."""
  BLOCK

  """Allows a package repo reference to be synced."""
  ALLOW
}

"""A package repo reference filter that matches names."""
type PackageNameFilter {
  """Glob string to match names."""
  packageGlob: String!
}

"""A package repo reference filter that matches names."""
input PackageNameFilterInput {
  """Glob string to match names."""
  packageGlob: String!
}

"""
Connection resolver for either a list of package repo references or versions.
"""
union PackageRepoOrVersionConnection = PackageRepoReferenceConnection | PackageRepoReferenceVersionConnection

"""
A reference to a package repo, such as a maven artifact, rust crate etc.
"""
type PackageRepoReference {
  """A unique ID for the package repo reference."""
  id: ID!

  """
  The external service kind under which this package repo
  reference is uniquely identified.
  """
  kind: PackageRepoReferenceKind!

  """
  The name of the package, in a format relevant to the specific ecosystem e.g.
  maven artifact coordinates (com.sample:text), npm scoped packages (@monkeys/banana).
  """
  name: String!

  """The versions of this package known to the sourcegraph instance."""
  versions: [PackageRepoReferenceVersion!]!

  """
  Indicates whether a package repo reference has been blocked by a blocklist entry and/or
  no matching entry in a non-empty allowlist
  """
  blocked: Boolean!

  """
  The synthetic repository (aka the package repo) created to store the contents of the
  synced versions of the package repo reference. This type is subject to change once
  package repos and other non-git code hosts become first-class.
  """
  repository: Repository
}

"""List of package repo references."""
type PackageRepoReferenceConnection {
  """A list of package repo references."""
  nodes: [PackageRepoReference!]!

  """The total number of package repo references in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
A kind of package repo reference.
ExternalServiceKind, with a more specific set of values.
"""
enum PackageRepoReferenceKind {
  GOMODULES
  JVMPACKAGES
  NPMPACKAGES
  PYTHONPACKAGES
  RUSTPACKAGES
  RUBYPACKAGES
}

"""A version of a package repo reference."""
type PackageRepoReferenceVersion {
  """A unique ID for the package repo reference version."""
  id: ID!

  """The package repo reference that this ID is for."""
  packageRepoReferenceID: ID!

  """The version string. Not guaranteed to be semver or any other format."""
  version: String!
}

"""List of package repo reference versions."""
type PackageRepoReferenceVersionConnection {
  """A list of package repo versions."""
  nodes: [PackageRepoReferenceVersion!]!

  """The total number of package repo versions in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
A package repo reference filter that matches versions for a specific name.
"""
type PackageVersionFilter {
  """Exact package name to match."""
  packageName: String!

  """Glob string to match versions."""
  versionGlob: String!
}

"""
A package repo reference filter that matches versions for a specific name.
"""
input PackageVersionFilterInput {
  """Exact package name to match."""
  packageName: String!

  """Glob string to match versions."""
  versionGlob: String!
}

"""
A name or version matching filter for. One of either nameFilter or versionFilter must be provided.
"""
input PackageVersionOrNameFilterInput {
  """Optional name-matching filter."""
  nameFilter: PackageNameFilterInput

  """Optional package-specific version-matching filter."""
  versionFilter: PackageVersionFilterInput
}

"""
Pagination information for forward-only pagination. See
https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
}

"""Parent Sourcegraph instance"""
type ParentSourcegraphDetails {
  """Sourcegraph instance URL."""
  url: String!
}

"""EXPERIMENTAL: A Perforce changelist."""
type PerforceChangelist {
  """The changelist ID."""
  cid: String!

  """The canonical URL to this changelist."""
  canonicalURL: String!

  """The corresponding git commit of this changelist."""
  commit: GitCommit!
}

"""A permission"""
type Permission implements Node {
  """The globally unique identifier for this permission."""
  id: ID!

  """The namespace in which this permission belongs to."""
  namespace: PermissionNamespace!

  """The unique action which is granted to a bearer of this permission."""
  action: String!

  """
  A unique, human-readable string used to represent a permission, taking the
  form: <namespace>:<object_id>#<relation>@<user_id | user_group>
  """
  displayName: String!

  """The date and time when the permission was created."""
  createdAt: DateTime!
}

"""A list of permissions."""
type PermissionConnection {
  """A list of permissions."""
  nodes: [Permission!]!

  """The total count of permissions in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""
A namespace represents a distinct context within which permission policies
are defined and enforced.
"""
enum PermissionNamespace {
  """This represents the Batch Changes namespace."""
  BATCH_CHANGES

  """
  Code ownership namespace used for permitting to assign ownership
  within Sourcegraph.
  """
  OWNERSHIP

  """
  Repo Metadata namespace used for permitting to edit repository
  key-value pair metadata.
  """
  REPO_METADATA
}

"""Permissions information of a repository or a user."""
type PermissionsInfo {
  """The permission levels that a user has on the repository."""
  permissions: [RepositoryPermission!]!

  """
  The last complete synced time, the value is updated only after a user- or repo-
  centric sync of permissions. It is null when the complete sync never happened.
  """
  syncedAt: DateTime

  """
  The last updated time of permissions, the value is updated whenever there is a
  change to the database row (i.e. incremental update).
  """
  updatedAt: DateTime

  """
  If true for a repo, it indicates access to the repo is allowed for all users.
  It will always be false for users.
  """
  unrestricted: Boolean!

  """The connection for repository permissions accessible to the user."""
  repositories(
    """
    Number of nodes returned during forward pagination. Maximum number of
    returned nodes is 100. Up to 20 nodes are returned by default.
    """
    first: Int

    """
    Number of nodes returned during backward pagination. Maximum number of
    returned nodes is 100. Up to 20 nodes are returned by default.
    """
    last: Int

    """Opaque pagination cursor to be used when paginating forwards."""
    after: String

    """Opaque pagination cursor to be used when paginating backwards."""
    before: String

    """Search query to filter repositories based on name."""
    query: String
  ): PermissionsInfoRepositoriesConnection

  """The connection for users who have access to the repository."""
  users(
    """
    Number of nodes returned during forward pagination. Maximum number of returned nodes is 100.
    """
    first: Int

    """
    Number of nodes returned during backward pagination. Maximum number of returned nodes is 100.
    """
    last: Int

    """Opaque pagination cursor to be used when paginating forwards."""
    after: String

    """Opaque pagination cursor to be used when paginating backwards."""
    before: String

    """Search query to filter users based on username or display name."""
    query: String
  ): PermissionsInfoUsersConnection
}

"""Connection for repository permissions accessible to the user"""
type PermissionsInfoRepositoriesConnection implements Connection {
  """List of repository permission info nodes"""
  nodes: [PermissionsInfoRepositoryNode!]!

  """
  The total number of repository permission info nodes in the connection.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""
Repository permission node defining why the repository is accessible to the user
"""
type PermissionsInfoRepositoryNode {
  """The ID of the repository."""
  id: ID!

  """The repository corresponding to the permission."""
  repository: Repository

  """
  The reason why the current user has permission to access the repository.
  """
  reason: String!

  """The timestamp when the permission was last updated at."""
  updatedAt: DateTime
}

"""
Repository permission node defining why the repository is accessible to the user.
"""
type PermissionsInfoUserNode {
  """The ID of the User."""
  id: ID!

  """The user corresponding to the permission."""
  user: User

  """The reason why the user has access to the repository."""
  reason: String!

  """The timestamp when the permission was last updated at."""
  updatedAt: DateTime
}

"""Connection for user permission who has access to the repository."""
type PermissionsInfoUsersConnection implements Connection {
  """List of repository permission info nodes"""
  nodes: [PermissionsInfoUserNode!]!

  """
  The total number of repository permission info nodes in the connection.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""Various permissions syncing statistics."""
type PermissionsSyncingStats {
  """The number of permissions sync jobs in the queue."""
  queueSize: Int!

  """The number of users with latest permissions sync job failing."""
  usersWithLatestJobFailing: Int!

  """The number of repositories with latest permissions sync job failing."""
  reposWithLatestJobFailing: Int!

  """The number of users with no permissions."""
  usersWithNoPermissions: Int!

  """The number of repositories with no permissions."""
  reposWithNoPermissions: Int!

  """The number of users with old permissions."""
  usersWithStalePermissions: Int!

  """The number of repository with old permissions."""
  reposWithStalePermissions: Int!
}

"""State of a permission sync job."""
type PermissionsSyncJob implements Node {
  """Unique node ID."""
  id: ID!

  """State of a permission sync job."""
  state: PermissionsSyncJobState!

  """Failure message for failed sync job."""
  failureMessage: String

  """Reason for triggering a permission sync job."""
  reason: PermissionsSyncJobReasonWithGroup!

  """Reason for cancellation of a given permission sync job."""
  cancellationReason: String

  """User who triggered this permission sync job."""
  triggeredByUser: User

  """Time when permission sync job was queued."""
  queuedAt: DateTime!

  """Time when permission sync job processing was started."""
  startedAt: DateTime

  """Time when permission sync job processing finished."""
  finishedAt: DateTime

  """Time after which permission sync job processing should be started."""
  processAfter: DateTime

  """How long did it take for permission sync job to complete."""
  ranForMs: Int

  """Number of permission sync job processing resets."""
  numResets: Int

  """Number of permission sync job processing failures."""
  numFailures: Int

  """Time of last heartbeat of a permission sync job processing."""
  lastHeartbeatAt: DateTime

  """Hostname of a worker on which permission sync job is processing."""
  workerHostname: String!

  """
  Flag showing that given permission sync job should be canceled instead of being processed.
  """
  cancel: Boolean!

  """Subject of a permission sync job (repository or user)."""
  subject: PermissionsSyncJobSubject!

  """Priority of a permission sync job."""
  priority: PermissionsSyncJobPriority!

  """
  Flag showing that there are no permissions for a given repository/user.
  """
  noPerms: Boolean!

  """
  Flag showing that caches should be invalidated during permission sync job processing.
  """
  invalidateCaches: Boolean!

  """Number of added permissions during permission sync job processing."""
  permissionsAdded: Int!

  """Number of removed permissions during permission sync job processing."""
  permissionsRemoved: Int!

  """Number of found permissions during permission sync job processing."""
  permissionsFound: Int!

  """State of providers (code hosts) during permission sync job."""
  codeHostStates: [CodeHostState!]!

  """Show if the job has finished with a partially successful result."""
  partialSuccess: Boolean!

  """Rank of the permissions syncing job in processing queue."""
  placeInQueue: Int
}

"""Permission sync job priority."""
enum PermissionsSyncJobPriority {
  LOW
  MEDIUM
  HIGH
}

"""State types of permission sync jobs."""
enum PermissionsSyncJobReason {
  REASON_USER_OUTDATED_PERMS
  REASON_USER_NO_PERMS
  REASON_REPO_OUTDATED_PERMS
  REASON_REPO_NO_PERMS
  REASON_REPO_UPDATED_FROM_CODE_HOST
  REASON_USER_EMAIL_REMOVED
  REASON_USER_EMAIL_VERIFIED
  REASON_USER_ADDED_TO_ORG
  REASON_USER_REMOVED_FROM_ORG
  REASON_USER_ACCEPTED_ORG_INVITE
  REASON_GITHUB_USER_EVENT
  REASON_GITHUB_USER_ADDED_EVENT
  REASON_GITHUB_USER_REMOVED_EVENT
  REASON_GITHUB_USER_MEMBERSHIP_ADDED_EVENT
  REASON_GITHUB_USER_MEMBERSHIP_REMOVED_EVENT
  REASON_GITHUB_TEAM_ADDED_TO_REPO_EVENT
  REASON_GITHUB_TEAM_REMOVED_FROM_REPO_EVENT
  REASON_GITHUB_ORG_MEMBER_ADDED_EVENT
  REASON_GITHUB_ORG_MEMBER_REMOVED_EVENT
  REASON_GITHUB_REPO_EVENT
  REASON_GITHUB_REPO_MADE_PRIVATE_EVENT
  REASON_MANUAL_REPO_SYNC
  REASON_MANUAL_USER_SYNC
  REASON_EXTERNAL_ACCOUNT_ADDED
  REASON_EXTERNAL_ACCOUNT_DELETED
}

"""Sync reason groups of permission sync jobs."""
enum PermissionsSyncJobReasonGroup {
  MANUAL
  WEBHOOK
  SCHEDULE
  SOURCEGRAPH
  UNKNOWN
}

"""
Compound type for a permissions sync job trigger reason.
Consists of a reason group (PermissionsSyncJobReasonGroup) and a reason itself, providing details
about why/how the sync was triggered.
"""
type PermissionsSyncJobReasonWithGroup {
  """
  PermissionsSyncJobReasonGroup combines multiple permission sync job trigger reasons into groups with similar grounds.
  """
  group: PermissionsSyncJobReasonGroup!

  """Reason with details about why/how the sync was triggered."""
  reason: PermissionsSyncJobReason
}

"""Permissions sync jobs."""
type PermissionsSyncJobsConnection implements Connection {
  """Permissions sync jobs."""
  nodes: [PermissionsSyncJob!]!

  """The total number of jobs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""Type of search for permissions sync jobs: user or repository."""
enum PermissionsSyncJobsSearchType {
  USER
  REPOSITORY
}

"""State types of permissions sync jobs."""
enum PermissionsSyncJobState {
  QUEUED
  PROCESSING
  FAILED
  ERRORED
  COMPLETED
  CANCELED
}

"""
Union type for a subject of a permission sync job (repository or user).
"""
union PermissionsSyncJobSubject = User | Repository

"""A person."""
type Person {
  """The name."""
  name: String!

  """The email."""
  email: String!

  """The name if set; otherwise the email username."""
  displayName: String!

  """The avatar URL, if known."""
  avatarURL: String

  """The corresponding user account for this person, if one exists."""
  user: User
}

"""A Phabricator repository."""
type PhabricatorRepo {
  """The canonical repo name (e.g. "github.com/gorilla/mux")."""
  name: String!

  """An alias for name."""
  uri: String! @deprecated(reason: "use name instead")

  """
  The unique Phabricator identifier for the repo, like "MUX"
  """
  callsign: String!

  """
  The URL to the phabricator instance (e.g. http://phabricator.sgdev.org)
  """
  url: String!
}

"""View presentation for an insight pie chart."""
type PieChartInsightViewPresentation {
  """The title for the pie chart."""
  title: String!

  """
  The threshold for which groups fall into the "other category". Only categories with a percentage greater than
  this value will be separately rendered.
  """
  otherThreshold: Float!
}

"""Options for a pie chart"""
input PieChartOptionsInput {
  """The title for the pie chart."""
  title: String!

  """
  The threshold for which groups fall into the "other category". Only categories with a percentage greater than
  this value will be separately rendered.
  """
  otherThreshold: Float!
}

"""Input for a pie chart search insight"""
input PieChartSearchInsightInput {
  """The query string."""
  query: String!

  """The scope of repositories."""
  repositoryScope: RepositoryScopeInput!

  """Options for this pie chart."""
  presentationOptions: PieChartOptionsInput!

  """The dashboard IDs to associate this insight with once created."""
  dashboards: [ID!]
}

"""A zero-based position inside a file."""
type Position {
  """The line number (zero-based) of the position."""
  line: Int!

  """The character offset (zero-based) in the line of the position."""
  character: Int!
}

"""Metadata and status about a precise code intelligence index."""
type PreciseIndex implements Node {
  """The ID."""
  id: ID!

  """The project for which this index provides code intelligence."""
  projectRoot: CodeIntelGitTree

  """The original 40-character commit commit supplied at creation."""
  inputCommit: String!

  """The original root supplied at creation."""
  inputRoot: String!

  """The original indexer name supplied at creation."""
  inputIndexer: String!

  """The tags, if any, associated with this commit."""
  tags: [String!]!

  """The indexer used to produce this index."""
  indexer: CodeIntelIndexer

  """The current state."""
  state: PreciseIndexState!

  """The time the index was queued for indexing."""
  queuedAt: DateTime

  """The time the index job started running."""
  indexingStartedAt: DateTime

  """The time the index job stopped running."""
  indexingFinishedAt: DateTime

  """The time the index data file was uploaded."""
  uploadedAt: DateTime

  """The time the upload data file started being processed."""
  processingStartedAt: DateTime

  """The time the upload data file stopped being processed."""
  processingFinishedAt: DateTime

  """The indexing or processing error message."""
  failure: String

  """The rank of this index job or processing job in its respective queue."""
  placeInQueue: Int

  """
  The configuration and execution summary (if completed or errored) of this index job.
  """
  steps: IndexSteps

  """
  If set, this index has been marked as replaceable by a new auto-indexing job.
  """
  shouldReindex: Boolean!

  """
  Whether or not this index provides intelligence for the tip of the default branch. Find reference
  queries will return symbols from remote repositories only when this property is true. This property
  is updated asynchronously and is eventually consistent with the git data known by the instance.
  """
  isLatestForRepo: Boolean!

  """The list of retention policies associated with this index."""
  retentionPolicyOverview(matchesOnly: Boolean!, query: String, after: String, first: Int): CodeIntelligenceRetentionPolicyMatchesConnection!

  """
  Audit logs representing each state change of the upload in order from earliest to latest.
  """
  auditLogs: [LSIFUploadAuditLog!]
}

"""A list of precise code intelligence indexes."""
type PreciseIndexConnection {
  """The current page of indexes."""
  nodes: [PreciseIndex!]!

  """The total number of results (over all pages) in this list."""
  totalCount: Int

  """Metadata about the current page of results."""
  pageInfo: PageInfo!
}

"""Possible states for PreciseIndexes."""
enum PreciseIndexState {
  UPLOADING_INDEX
  QUEUED_FOR_PROCESSING
  PROCESSING
  PROCESSING_ERRORED
  COMPLETED
  DELETING
  DELETED
  QUEUED_FOR_INDEXING
  INDEXING
  INDEXING_ERRORED
  INDEXING_COMPLETED
}

"""
The configuration and execution summary of a step to be performed prior to indexing.
"""
type PreIndexStep {
  """The working directory relative to the cloned repository root."""
  root: String!

  """The name of the Docker image to run."""
  image: String!

  """The arguments to supply to the Docker container's entrypoint."""
  commands: [String!]!

  """The execution summary (if completed or errored) of the docker command."""
  logEntry: ExecutionLogEntry
}

"""A not-yet-committed preview of a diff on a repository."""
type PreviewRepositoryComparison {
  """The repository that is the base (left-hand side) of this comparison."""
  baseRepository: Repository!

  """The file diffs for each changed file."""
  fileDiffs(
    """Return the first n file diffs from the list."""
    first: Int

    """Return file diffs after the given cursor."""
    after: String

    """A list of paths or directories used to filter the diffs"""
    paths: [String!]
  ): FileDiffConnection!
}

"""
A product license that was created on Sourcegraph.com.
FOR INTERNAL USE ONLY.
"""
type ProductLicense implements Node {
  """The unique ID of this product license."""
  id: ID!

  """The product subscription associated with this product license."""
  subscription: ProductSubscription!

  """Information about this product license."""
  info: ProductLicenseInfo

  """The license key."""
  licenseKey: String!

  """Site ID of the instance that uses the license."""
  siteID: String

  """The date when this product license was created."""
  createdAt: DateTime!

  """The date when this product license was revoked."""
  revokedAt: DateTime

  """The reason for revoking product license."""
  revokeReason: String

  """The version of the license."""
  version: Int!
}

"""
A list of product licenses.
FOR INTERNAL USE ONLY.
"""
type ProductLicenseConnection {
  """A list of product licenses."""
  nodes: [ProductLicense!]!

  """
  The total count of product licenses in the connection. This total count may be larger than the number of
  nodes in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
Information about this site's product license (which activates certain Sourcegraph features).
"""
type ProductLicenseInfo {
  """
  The full name of the product that this license is for. To get the product name for the current
  Sourcegraph site, use ProductSubscriptionStatus.productNameWithBrand instead (to handle cases where there is
  no license).
  """
  productNameWithBrand: String!

  """
  Tags indicating the product plan and features activated by this license.
  """
  tags: [String!]!

  """The number of users allowed by this license."""
  userCount: Int!

  """The date when this license expires."""
  expiresAt: DateTime!

  """The Salesforce subscription ID associated with this license."""
  salesforceSubscriptionID: String

  """The Salesforce opportunity ID associated with this license."""
  salesforceOpportunityID: String
}

"""
An input type that describes a product license to be generated and signed.
FOR INTERNAL USE ONLY.
"""
input ProductLicenseInput {
  """The tags that indicate which features are activated by this license."""
  tags: [String!]!

  """The number of users for which this product subscription is valid."""
  userCount: Int!

  """
  The expiration date of this product license, expressed as the number of seconds since the epoch.
  """
  expiresAt: Int!

  """The Salesforce subscription ID associated with this product license."""
  salesforceSubscriptionID: String

  """The Salesforce opportunity ID associated with this product license."""
  salesforceOpportunityID: String
}

"""
A product subscription that was created on Sourcegraph.com.
FOR INTERNAL USE ONLY.
"""
type ProductSubscription implements Node {
  """The unique ID of this product subscription."""
  id: ID!

  """
  The unique UUID of this product subscription. Unlike ProductSubscription.id, this does not
  encode the type and is not a GraphQL node ID.
  """
  uuid: String!

  """
  A name for the product subscription derived from its ID. The name is not guaranteed to be unique.
  """
  name: String!

  """
  The user (i.e., customer) to whom this subscription is granted, or null if the account has been deleted.
  """
  account: User

  """
  The currently active product license associated with this product subscription, if any.
  """
  activeLicense: ProductLicense

  """
  A list of product licenses associated with this product subscription.
  Only Sourcegraph.com site admins may list inactive product licenses (other viewers should use
  ProductSubscription.activeLicense).
  """
  productLicenses(
    """Returns the first n product licenses from the list."""
    first: Int
  ): ProductLicenseConnection!

  """
  The most preferable Sourcegraph access token to use for authenticating as the
  subscription holder with managed Sourcegraph services.
  Null only if creating a token failed, for example when no active license exists.
  """
  currentSourcegraphAccessToken: String

  """
  Available access tokens for authenticating as the subscription holder with managed
  Sourcegraph services.
  """
  sourcegraphAccessTokens: [String!]!

  """
  Cody Gateway access granted to this subscription. Properties may be inferred
  from the active license, or be defined in overrides.
  """
  codyGatewayAccess: CodyGatewayAccess!

  """The date when this product subscription was created."""
  createdAt: DateTime!

  """Whether this product subscription was archived."""
  isArchived: Boolean!

  """The URL to view this product subscription."""
  url: String!

  """
  The URL to view this product subscription in the site admin area.
  Only Sourcegraph.com site admins may query this field.
  """
  urlForSiteAdmin: String
}

"""
A list of product subscriptions.
FOR INTERNAL USE ONLY.
"""
type ProductSubscriptionConnection {
  """A list of product subscriptions."""
  nodes: [ProductSubscription!]!

  """
  The total count of product subscriptions in the connection. This total count may be larger than the number of
  nodes in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
Information about this site's product subscription (which enables access to and renewals of a product license).
"""
type ProductSubscriptionStatus {
  """The full name of the product in use, such as "Sourcegraph Enterprise"."""
  productNameWithBrand: String!

  """
  The max number of user accounts that have been active on this Sourcegraph site for the current license.
  If no license is in use, returns zero.
  """
  actualUserCount: Int!

  """
  The date and time when the max number of user accounts that have been active on this Sourcegraph site for
  the current license was reached. If no license is in use, returns an empty string.
  """
  actualUserCountDate: String!

  """
  The number of users allowed. If there is a license, this is equal to ProductLicenseInfo.userCount. Otherwise,
  it is the user limit for instances without a license, or null if there is no limit.
  """
  maximumAllowedUserCount: Int

  """
  The number of free users allowed on a site without a license before a warning is shown to all users, or null
  if a valid license is in use.
  """
  noLicenseWarningUserCount: Int

  """The product license associated with this subscription, if any."""
  license: ProductLicenseInfo
}

"""Public provider-specific data about the external account."""
type PublicExternalAccountData {
  """The text name the user is using on the external account, if any."""
  displayName: String

  """
  The login or username the user is using on the external account, if any.
  """
  login: String

  """Link to the user profile page for the external account."""
  url: String
}

"""
A quadruple that represents all possible states of the published value: true, false, 'draft', or null.
"""
scalar PublishedValue

"""A query."""
type Query {
  """The root of the query."""
  root: Query! @deprecated(reason: "this will be removed.")

  """Looks up a node by ID."""
  node(id: ID!): Node

  """Looks up a repository by either name or cloneURL."""
  repository(
    """Query the repository by name, for example "github.com/gorilla/mux"."""
    name: String

    """
    Query the repository by a Git clone URL (format documented here:
    https://git-scm.com/docs/git-clone_git_urls_a_id_urls_a)
    by checking for a code host configuration that matches the clone URL.
    Will not actually check the code host to see if the repository actually exists.
    """
    cloneURL: String

    """An alias for name. DEPRECATED: use name instead."""
    uri: String
  ): Repository

  """
  Looks up a repository by either name or cloneURL or hashedName. When the repository does not exist on the server
  and "disablePublicRepoRedirects" is "false" in the site configuration, it returns a Redirect to
  an external Sourcegraph URL that may have this repository instead. Otherwise, this query returns
  null.
  """
  repositoryRedirect(
    """Query the repository by name, for example "github.com/gorilla/mux"."""
    name: String

    """
    Query the repository by a Git clone URL (format documented here:
    https://git-scm.com/docs/git-clone_git_urls_a_id_urls_a)
    by checking for a code host configuration that matches the clone URL.
    Will not actually check the code host to see if the repository actually exists.
    """
    cloneURL: String

    """
    Query the repository by hashed name.
    Hashed name is a SHA256 checksum of the absolute repo name in lower case,
    for example "github.com/sourcegraph/sourcegraph" -> "a6c905ceb7dec9a565945ceded8c7fa4154250df8b928fb40673b535d9a24c2f"
    """
    hashedName: String
  ): RepositoryRedirect

  """
  Lists external services under given namespace.
  If no namespace is given, it returns all external services.
  """
  externalServices(
    """Returns the first n external services from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String
  ): ExternalServiceConnection!

  """
  Lists all namespaces for a given external service connection.
  A namespace is an entity on the code host that repositories are assignable to.
  """
  externalServiceNamespaces(
    """
    The GraphQL ID of the external service whose configuration will be used to define the code host remote url to
    submit requests to and the token value to authenticate with.
    If no external service exists which provides the necessary request parameters then leave ID nil and
    provide kind, remote code host token and url.
    """
    id: ID

    """The kind of the external service."""
    kind: ExternalServiceKind!

    """The secret token value that is used to authenticate."""
    token: String!

    """The url of the external service."""
    url: String!
  ): ExternalServiceNamespaceConnection!

  """Lists all repositories for a given external service connection."""
  externalServiceRepositories(
    """
    The GraphQL ID of the external service whose configuration will be used to define the code host remote url to
    submit requests to and the token value to authenticate with.
    If no external service exists which provides the necessary request parameters then leave ID nil and
    provide kind, remote code host token and url.
    """
    id: ID

    """The kind of the external service."""
    kind: ExternalServiceKind!

    """The secret token value that is used to authenticate."""
    token: String!

    """The url of the external service."""
    url: String!

    """Repository query string."""
    query: String!

    """
    A list of repository names to exclude from results (in the form of owner/name).
    """
    excludeRepos: [String!]!

    """
    Returns the first n repositories matching the query and excludeRepos criteria.
    """
    first: Int
  ): ExternalServiceRepositoryConnection!

  """List all repositories."""
  repositories(
    """Returns the first n repositories from the list."""
    first: Int

    """Returns the last n repositories from the list."""
    last: Int

    """Return repositories whose names match the query."""
    query: String

    """An opaque cursor that is used for pagination."""
    after: String

    """An opaque cursor that is used for pagination."""
    before: String

    """Return repositories whose names are in the list."""
    names: [String!]

    """Include cloned repositories."""
    cloned: Boolean = true

    """Include only repositories of the given clone status."""
    cloneStatus: CloneStatus

    """
    Include repositories that are not yet cloned and for which cloning is not in progress.
    """
    notCloned: Boolean = true

    """Include repositories that have a text search index."""
    indexed: Boolean = true

    """Include repositories that do not have a text search index."""
    notIndexed: Boolean = true

    """
    Include only repositories that have encountered errors when cloning or fetching
    """
    failedFetch: Boolean = false

    """Include repositories that are corrupt"""
    corrupted: Boolean = false

    """
    Return repositories that are associated with the given external service.
    """
    externalService: ID

    """Sort field."""
    orderBy: RepositoryOrderBy = REPOSITORY_NAME

    """Sort direction."""
    descending: Boolean = false
  ): NewRepositoryConnection!

  """Query package repo references."""
  packageRepoReferences(
    """The exact package repo reference kind to filter by."""
    kind: PackageRepoReferenceKind

    """
    If supplied, only package repo references that match the given
    terms by their name will be returned.
    TODO: fuzzy vs exact?
    """
    name: String

    """Returns the first n package repo references from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String
  ): PackageRepoReferenceConnection!

  """Query package repo reference filters."""
  packageRepoFilters(
    """Whether the matcher should be for allowlisting or blocklisting."""
    behaviour: PackageMatchBehaviour

    """
    The ecosystem of the package repo reference this matcher should apply to.
    Maps to the external service whos config would be updated when used in the
    set query.
    """
    kind: PackageRepoReferenceKind
  ): [PackageFilter!]

  """
  Returns either a list of package repo references,
  or the versions of a single package repo reference,
  that match the provided matcher.
  """
  packageRepoReferencesMatchingFilter(
    """The kind of the package repo reference this matcher should apply to."""
    kind: PackageRepoReferenceKind!

    """The matcher for which to return matching results."""
    filter: PackageVersionOrNameFilterInput!

    """Returns the first n package/package version matches from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String
  ): PackageRepoOrVersionConnection!

  """Looks up a Phabricator repository by name."""
  phabricatorRepo(
    """The name, for example "github.com/gorilla/mux"."""
    name: String

    """An alias for name. DEPRECATED: use name instead."""
    uri: String
  ): PhabricatorRepo

  """The current user."""
  currentUser: User

  """Looks up a user by username or email address."""
  user(
    """Query the user by username."""
    username: String

    """Query the user by verified email address."""
    email: String
  ): User

  """List all users."""
  users(
    """Returns the first n users from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Return users whose usernames or display names match the query."""
    query: String

    """Returns users who have been active in a given period of time."""
    activePeriod: UserActivePeriod

    """Returns users who have NOT been active since a given point in time."""
    inactiveSince: DateTime
  ): UserConnection!

  """Looks up an organization by name."""
  organization(name: String!): Org

  """List all organizations."""
  organizations(
    """Returns the first n organizations from the list."""
    first: Int

    """Return organizations whose names or display names match the query."""
    query: String
  ): OrgConnection!

  """
  Renders Markdown to HTML. The returned HTML is already sanitized and
  escaped and thus is always safe to render.
  """
  renderMarkdown(markdown: String!, options: MarkdownOptions): String!

  """EXPERIMENTAL: Syntax highlights a code string."""
  highlightCode(code: String!, fuzzyLanguage: String!, disableTimeout: Boolean!, isLightTheme: Boolean): String!

  """
  Looks up an instance of a type that implements SettingsSubject (i.e., something that has settings). This can
  be a site (which has global settings), an organization, or a user.
  """
  settingsSubject(id: ID!): SettingsSubject

  """
  The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is
  global settings) or an authenticated user (in which case viewer settings are the user's settings).
  """
  viewerSettings: SettingsCascade!

  """DEPRECATED"""
  viewerConfiguration: ConfigurationCascade! @deprecated(reason: "use viewerSettings instead")

  """The configuration for clients."""
  clientConfiguration: ClientConfigurationDetails!

  """Runs a search."""
  search(
    """
    The version of the search syntax being used.
    All new clients should use the latest version.
    """
    version: SearchVersion = V1

    """
    PatternType controls the search pattern type, if and only if it is not specified in the query string using
    the patternType: field.
    """
    patternType: SearchPatternType

    """The search query (such as "foo" or "repo:myrepo foo")."""
    query: String = ""
  ): Search

  """List of saved searches based on namespace"""
  savedSearches(
    """The namespace to list the saved searches for."""
    namespace: ID!

    """The limit argument for forward pagination."""
    first: Int

    """The limit argument for backward pagination."""
    last: Int

    """The cursor argument for forward pagination."""
    after: String

    """The cursor argument for backward pagination."""
    before: String
  ): SavedSearchesConnection!

  """EXPERIMENTAL: Return the parse tree of a search query."""
  parseSearchQuery(
    """The search query (such as "repo:myrepo foo")."""
    query: String = ""

    """The parser to use for this query."""
    patternType: SearchPatternType = standard

    """The output corresponding to a phase in the parser pipeline."""
    outputPhase: SearchQueryOutputPhase = PARSE_TREE

    """The parser output format."""
    outputFormat: SearchQueryOutputFormat = JSON

    """The level of output format verbosity."""
    outputVerbosity: SearchQueryOutputVerbosity = BASIC
  ): String!

  """The current site."""
  site: Site!

  """Retrieve responses to surveys."""
  surveyResponses(
    """Returns the first n survey responses from the list."""
    first: Int
  ): SurveyResponseConnection!

  """FOR INTERNAL USE ONLY: Lists all status messages"""
  statusMessages: [StatusMessage!]!

  """FOR INTERNAL USE ONLY: Query repository statistics for the site."""
  repositoryStats: RepositoryStats!

  """Look up a namespace by ID."""
  namespace(id: ID!): Namespace

  """Look up a namespace by name, which is a username or organization name."""
  namespaceByName(
    """The name of the namespace."""
    name: String!
  ): Namespace

  """
  Returns true if any of the code hosts supplied are syncing now or within "seconds" from now.
  """
  codeHostSyncDue(ids: [ID!]!, seconds: Int!): Boolean!

  """Retrieve all registered out-of-band migrations."""
  outOfBandMigrations: [OutOfBandMigration!]!

  """Retrieve the list of defined feature flags"""
  featureFlags: [FeatureFlag!]!

  """Retrieve a feature flag"""
  featureFlag(name: String!): FeatureFlag!

  """
  Evaluates a feature flag for the current user
  Returns null if feature flag does not exist
  """
  evaluateFeatureFlag(flagName: String!): Boolean

  """Retrieve all evaluated feature flags for the current user"""
  evaluatedFeatureFlags: [EvaluatedFeatureFlag!]!

  """Retrieve the value of a feature flag for the organization"""
  organizationFeatureFlagValue(orgID: ID!, flagName: String!): Boolean!

  """Retrieve all organization feature flag overrides for the current user"""
  organizationFeatureFlagOverrides: [FeatureFlagOverride!]!

  """Retrieves the temporary settings for the current user."""
  temporarySettings: TemporarySettings!

  """
  Returns recently received webhooks across all external services, optionally
  limiting the returned values to only those that didn't match any external
  service.
  
  Only site admins can access this field.
  """
  webhookLogs(
    """Returns the first n webhook logs."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Only include webhook logs that resulted in errors."""
    onlyErrors: Boolean

    """
    Only include webhook logs that were not matched to an external service.
    """
    onlyUnmatched: Boolean

    """Only include webhook logs on or after this time."""
    since: DateTime

    """Only include webhook logs on or before this time."""
    until: DateTime

    """Only include webhook logs of given webhook ID."""
    webhookID: ID

    """Only include webhook logs that have no webhook ID set."""
    legacyOnly: Boolean
  ): WebhookLogConnection!

  """
  Get a log of the latest outbound external requests. Only available to site admins.
  """
  outboundRequests(
    """Returns the first n log items. If omitted then it returns all of them."""
    first: Int

    """Opaque pagination cursor."""
    after: String
  ): OutboundRequestConnection!

  """Get a list of background jobs that are currently known in the system."""
  backgroundJobs(
    """Returns the first n jobs. If omitted then it returns all of them."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """The maximum number of recent runs to return for each routine."""
    recentRunCount: Int
  ): BackgroundJobConnection!

  """EXPERIMENTAL: Get invitation based on the JWT in the invitation URL"""
  invitationByToken(
    """The token that uniquely identifies the invitation"""
    token: String!
  ): OrganizationInvitation!

  """Get pending invitations for the specific organization"""
  pendingInvitations(
    """The organization ID"""
    organization: ID!
  ): [OrganizationInvitation!]!

  """Search for users that opt-in to search autocomplete."""
  autocompleteMembersSearch(
    """The organization ID"""
    organization: ID!

    """Return users whose usernames or display names match the query."""
    query: String!
  ): [AutocompleteMemberSearchItem!]!

  """Get started organization summary"""
  orgMembersSummary(
    """The organization ID"""
    organization: ID!
  ): OrgMembersSummary!

  """
  Lists webhooks. Only available to site admins.
  If no kind is given, it returns all webhooks.
  If first is omitted, 20 items are returned
  """
  webhooks(
    """Returns the first n webhooks from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Optionally filter by kind."""
    kind: ExternalServiceKind
  ): WebhookConnection!

  """
  List slow GraphQL requests that were recently captured (requires site-admin permissions).
  """
  slowRequests(
    """Opaque pagnination cursor."""
    after: String
  ): SlowRequestConnection!

  """
  Roles returns all the roles in the database that matches the arguments.
  """
  roles(
    """The limit argument for forward pagination."""
    first: Int

    """The limit argument for backward pagination."""
    last: Int

    """The cursor argument for forward pagination."""
    after: String

    """The cursor argument for backward pagination."""
    before: String
  ): RoleConnection!

  """This returns all permissions in a paginated format."""
  permissions(
    """The limit argument for forward pagination."""
    first: Int

    """The limit argument for backward pagination."""
    last: Int

    """The cursor argument for forward pagination."""
    after: String

    """The cursor argument for backward pagination."""
    before: String
  ): PermissionConnection!

  """The list of all globally available executor secrets."""
  executorSecrets(
    """The scope for which secrets shall be returned."""
    scope: ExecutorSecretScope!

    """Only return N records."""
    first: Int = 50

    """Opaque cursor for pagination."""
    after: String
  ): ExecutorSecretConnection!

  """Retrieve active executor compute instances."""
  executors(
    """
    An (optional) search query that searches over the hostname, queue name, os, architecture, and
    version properties.
    """
    query: String

    """
    Whether to show only executors that have sent a heartbeat in the last fifteen minutes.
    """
    active: Boolean

    """Returns the first n executors."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): ExecutorConnection!

  """
  Returns true if executors have been configured on the Sourcegraph instance.
  This is based on heuristics and doesn't necessarily mean that they would be
  working.
  """
  areExecutorsConfigured: Boolean!

  """Get a single team by name. Returns null if not found."""
  team(name: String!): Team

  """Get the global list of all root teams. (Those without a parent team)."""
  teams(
    """Returns the first n teams from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Search can be used to do a text-search over the team names."""
    search: String

    """
    Do not include any teams that have this ancestor in parent-team relationship.
    This includes the team with the ID mentioned (that is a team is considered
    its own ancestor).
    """
    exceptAncestor: ID

    """
    If set to true, child teams (ones that have parent set) are also returned.
    If not specified, the default behavior is to only include top-level teams.
    """
    includeChildTeams: Boolean
  ): TeamConnection!

  """List access requests."""
  accessRequests(
    status: AccessRequestStatus

    """Returns the first n access requests from the list."""
    first: Int
    last: Int
    after: String
    before: String
  ): AccessRequestConnection!

  """Repository key-value pair metadata"""
  repoMeta: RepoMetadata

  """
  Returns the outbound webhooks registered within Sourcegraph, optionally filtered by
  event type and scope. To filter by scope, event type is also required. If the event
  type and scope are both omitted, all webhooks are returned.
  
  Only site admins have access to this query.
  """
  outboundWebhooks(first: Int = 50, after: String, eventType: String, scope: String): OutboundWebhookConnection!

  """
  Returns all possible outbound webhook event types.
  
  Only site admins have access to this query.
  """
  outboundWebhookEventTypes: [OutboundWebhookEventType!]!

  """A list of batch changes."""
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!

  """Looks up a batch change by namespace and name."""
  batchChange(
    """The namespace where the batch change lives."""
    namespace: ID!

    """The batch changes name."""
    name: String!
  ): BatchChange

  """Stats on all the changesets across the instance for Batch Changes."""
  globalChangesetsStats: GlobalChangesetsStats!

  """All globally configured code hosts usable with Batch Changes."""
  batchChangesCodeHosts(
    """Returns the first n code hosts from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): BatchChangesCodeHostConnection!

  """
  Returns a list of available bulk operations for changesets belonging to a batch change.
  """
  availableBulkOperations(
    """The batch change the selected changesets belong to."""
    batchChange: ID!

    """The changesets to query for bulk operations applicable to."""
    changesets: [ID!]!
  ): [BulkOperationType!]!

  """
  A list of batch specs.
  
  
  Site-admin only.
  
  Experimental: This API is likely to change in the future.
  """
  batchSpecs(
    """Returns the first n batch specs from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Include locally executed (i.e. with src-cli) batch specs in the list of specs returned.
    """
    includeLocallyExecutedSpecs: Boolean

    """
    Exclude the empty batch specs that are initially created and applied to draft batch changes.
    """
    excludeEmptySpecs: Boolean
  ): BatchSpecConnection!

  """Determines if a batch change credential is authorized for a code host."""
  checkBatchChangesCredential(batchChangesCredential: ID!): EmptyResponse!

  """
  Takes the batch spec as input and resolves the workspaces for it, without persisting them.
  This endpoint is used in src-cli to resolve workspaces.
  """
  resolveWorkspacesForBatchSpec(batchSpec: String!): [ResolvedBatchSpecWorkspace!]!

  """
  Returns the max number of changesets are allowed for License that does not have the batch change feature.
  """
  maxUnlicensedChangesets: Int!

  """Query precise code intelligence indexes."""
  preciseIndexes(
    """
    If supplied, only precise indexes for the given repository will be returned.
    """
    repo: ID

    """
    If supplied, only precise indexes that match the given terms by their state,
    repository name, commit, root, and indexer fields will be returned..
    """
    query: String

    """
    If supplied, only precise indexes in one of the provided states are returned.
    """
    states: [PreciseIndexState!]

    """
    If supplied, only precise indexes created by an indexer with the given key are returned.
    """
    indexerKey: String

    """
    If supplied, only precise indexes that are a dependency of the specified index are returned.
    """
    dependencyOf: ID

    """
    If supplied, only precise indexes that are a dependent of the specified index are returned.
    """
    dependentOf: ID

    """
    When specified, merges the list of existing uploads with data from
    uploads that have been deleted but for which audit logs still exist.
    Only makes sense when state filter is unset or equal to 'DELETED'.
    """
    includeDeleted: Boolean

    """If specified, this limits the number of results per request."""
    first: Int

    """
    If specified, this indicates that the request should be paginated and to fetch results starting
    at this cursor.
    
    A future request can be made for more results by passing in the 'PreciseIndexConnection.pageInfo.endCursor'
    that is returned.
    """
    after: String
  ): PreciseIndexConnection!

  """Provides a summary of code intelligence on the instance."""
  codeIntelSummary: CodeIntelSummary!

  """
  A list of unique indexer keys queryable via the `preciseIndexes.indexerKey` filter.
  """
  indexerKeys(
    """
    If supplied, only indexers associated with the given repository will be returned.
    """
    repo: ID
  ): [String!]!

  """
  Return the currently set auto-indexing job inference script. Does not return
  the value stored in the environment variable or the default shipped scripts,
  only the value set via UI/GraphQL.
  """
  codeIntelligenceInferenceScript: String!

  """
  Return (but do not enqueue) descriptions of auto indexing jobs at the current revision.
  """
  inferAutoIndexJobsForRepo(repository: ID!, rev: String, script: String): InferAutoIndexJobsResult!

  """
  Returns precise code intelligence configuration policies that control data retention
  and (if enabled) auto-indexing behavior.
  """
  codeIntelligenceConfigurationPolicies(
    """
    If repository is supplied, then only the configuration policies that apply to
    repository are returned. If repository is not supplied, then all policies are
    returned.
    """
    repository: ID

    """An (optional) search query that searches over the name property."""
    query: String

    """
    If set to true, then only configuration policies with SCIP data retention enabled are returned.
    If set to false, then configuration policies with SCIP data retention enabled are filtered out.
    """
    forDataRetention: Boolean

    """
    If set to true, then only configuration policies with indexing enabled are returned.
    If set to false, then configuration policies with indexing enabled are filtered out.
    """
    forIndexing: Boolean

    """
    If set to true, then only configuration policies with embeddings enabled are returned.
    If set to false, then configuration policies with embeddings enabled are filtered out.
    """
    forEmbeddings: Boolean

    """
    If set to true, then only protected configuration policies are returned.
    If set to false, then only un-protected configuration policies are returned.
    If unset, policies are returned regardless if they're protected or not.
    """
    protected: Boolean

    """
    When specified, indicates that this request should be paginated and
    the first N results (relative to the cursor) should be returned. i.e.
    how many results to return per page.
    """
    first: Int

    """
    When specified, indicates that this request should be paginated and
    to fetch results starting at this cursor.
    
    A future request can be made for more results by passing in the
    'CodeIntelligenceConfigurationPolicyConnection.pageInfo.endCursor'
    that is returned.
    """
    after: String
  ): CodeIntelligenceConfigurationPolicyConnection!

  """
  The set of repositories that match the given glob pattern. This resolver is used by the UI to
  preview what repositories match a code intelligence policy in a given repository.
  """
  previewRepositoryFilter(
    """A set of patterns matching the name of the matching repository."""
    patterns: [String!]!

    """
    When specified, indicates that this request should return the first N items.
    """
    first: Int
  ): RepositoryFilterPreview!

  """Gets the progress of the current and historic precise ranking jobs."""
  rankingSummary: GlobalRankingSummary!

  """Return known vulnerabilities."""
  vulnerabilities(
    """The maximum number of results to return."""
    first: Int

    """If supplied, indicates which results to skip over during pagination."""
    after: String
  ): VulnerabilityConnection!

  """Return known vulnerability matches."""
  vulnerabilityMatches(
    """The maximum number of results to return."""
    first: Int

    """If supplied, indicates which results to skip over during pagination."""
    after: String

    """Programming language of the vulnerability."""
    language: String

    """Severity of the vulnerability."""
    severity: String

    """The name of the repository to filter by."""
    repositoryName: String
  ): VulnerabilityMatchConnection!

  """Return known vulnerability matches grouped by repository."""
  vulnerabilityMatchesCountByRepository(
    """The maximum number of results to return."""
    first: Int

    """If supplied, indicates which results to skip over during pagination."""
    after: String

    """A string pattern that could match the name of a repository."""
    repositoryName: String
  ): VulnerabilityMatchCountByRepositoryConnection!

  """Returns a count of the vulnerability matches grouped by severity."""
  vulnerabilityMatchesSummaryCounts: VulnerabilityMatchesSummaryCount!

  """Return dashboards visible to the authenticated user."""
  insightsDashboards(first: Int, after: String, id: ID): InsightsDashboardConnection!

  """Return all insight views visible to the authenticated user."""
  insightViews(
    first: Int
    after: String
    id: ID

    """Allow you to exclude subset of insights by their ids."""
    excludeIds: [ID!]

    """
    Allow you to search insight views by their title or data series labels.
    """
    find: String
    isFrozen: Boolean
    filters: InsightViewFiltersInput
    seriesDisplayOptions: SeriesDisplayOptionsInput
  ): InsightViewConnection!

  """
  Generate an ephemeral time series for a Search based code insight, generally for the purposes of live preview.
  """
  searchInsightLivePreview(input: SearchInsightLivePreviewInput!): [SearchInsightLivePreviewSeries!]!

  """
  Generate an ephemeral set of time series for a code insight, generally for the purposes of live preview.
  """
  searchInsightPreview(input: SearchInsightPreviewInput!): [SearchInsightLivePreviewSeries!]!

  """
  Retrieve information about queued insights series and their breakout by status. Restricted to admins only.
  """
  insightSeriesQueryStatus: [InsightSeriesQueryStatus!]!

  """
  Retrieve information about an insight view and its status. Restricted to admins only.
  """
  insightViewDebug(id: ID!): InsightViewDebug

  """
  Validates a query for determining insight scope and returns the number of repositories it matches for the caller.
  """
  validateScopedInsightQuery(query: String!): ScopedInsightQueryPayload!

  """Returns the number of repositories matched given a valid query."""
  previewRepositoriesFromQuery(query: String!): RepositoryPreviewPayload!

  """Fetch information related to the queue of backfilling insights."""
  insightAdminBackfillQueue(
    """Returns the first n queue items from the list."""
    first: Int

    """Returns the last n queue items from the list."""
    last: Int

    """An opaque cursor that is used for pagination."""
    after: String

    """An opaque cursor that is used for pagination."""
    before: String

    """How to order the list."""
    orderBy: BackfillQueueOrderBy = STATE

    """Sort direction."""
    descending: Boolean = false

    """List of states to filter list by."""
    states: [InsightQueueItemState!]

    """Text to filter the list, checking the Insight Title and Series Label"""
    textSearch: String
  ): InsightBackfillQueueItemConnection!

  """
  The repositories a user is authorized to access with the given permission.
  This isn’t defined in the User type because we store permissions for users
  that don’t yet exist (i.e. late binding). Only one of "username" or "email"
  is required to identify a user.
  """
  authorizedUserRepositories(
    """The username."""
    username: String

    """One of the email addresses."""
    email: String

    """Permission that the user has on the repositories."""
    perm: RepositoryPermission = READ

    """Number of repositories to return after the given cursor."""
    first: Int!

    """Opaque pagination cursor."""
    after: String
  ): RepositoryConnection!

  """
  Returns a list of usernames or emails that have associated pending permissions.
  The returned list can be used to query authorizedUserRepositories for pending permissions.
  """
  usersWithPendingPermissions: [String!]!

  """
  INTERNAL ONLY: Returns a list of the types of authz providers that have been configured and will be used for
  determining which repositories the user has access to.
  """
  authzProviderTypes: [String!]!

  """
  Returns a list of recent permissions sync jobs for a given set of parameters.
  """
  permissionsSyncJobs(
    """
    Number of jobs returned. Maximum number of returned jobs is 500. Up to 100 jobs are returned by default.
    """
    first: Int

    """
    The number of nodes to return starting from the end (latest).
    Note: Use either last or first (see above) in the query. Setting both will
    return an error.
    """
    last: Int

    """
    Opaque pagination cursor to be used when paginating forwards that may be also used
    in conjunction with "first" to return the first N nodes.
    """
    after: String

    """
    Opaque pagination cursor to be used when paginating backwards that may be
    also used in conjunction with "last" to return the last N nodes.
    """
    before: String

    """Optional filter for PermissionsSyncJobReasonGroup."""
    reasonGroup: PermissionsSyncJobReasonGroup

    """Optional filter for PermissionsSyncJobState."""
    state: PermissionsSyncJobState

    """Type of search for permissions sync jobs: user or repository."""
    searchType: PermissionsSyncJobsSearchType

    """Term used to search for permissions sync jobs."""
    query: String

    """
    Optional filter to find permissions sync jobs for a user. Please provide either this or repoID, but not both.
    """
    userID: ID

    """
    Optional filter to find permissions sync jobs for a repository. Please provide either this or userID, but not both.
    """
    repoID: ID

    """Optional filter to filter only partially successful sync jobs."""
    partial: Boolean
  ): PermissionsSyncJobsConnection!

  """Returns various permissions syncing statistics."""
  permissionsSyncingStats: PermissionsSyncingStats!

  """
  Returns a list of Bitbucket Project permissions sync jobs for a given set of parameters.
  """
  bitbucketProjectPermissionJobs(
    """Bitbucket project keys which sync jobs are queried"""
    projectKeys: [String!]

    """
    Job status, one of the following: queued, processing, completed, errored, failed.
    """
    status: String

    """
    Number of jobs returned. Maximum number of returned jobs is 500. 100 jobs are returned by default.
    """
    count: Int
  ): BitbucketProjectPermissionJobs!

  """
  All configured GitHub Apps, optionally filtered by the domain in which they are used.
  """
  gitHubApps(domain: GitHubAppDomain): GitHubAppConnection!

  """Looks up a GitHub App by its ID."""
  gitHubApp(id: ID!): GitHubApp

  """Looks up a GitHub App by its AppID and BaseURL."""
  gitHubAppByAppID(appID: Int!, baseURL: String!): GitHubApp

  """Checks whether the given feature is enabled on Sourcegraph."""
  enterpriseLicenseHasFeature(feature: String!): Boolean!

  """
  Queries that are only used on Sourcegraph.com.
  
  FOR INTERNAL USE ONLY.
  """
  dotcom: DotcomQuery!

  """
  All available user-defined search contexts. Excludes auto-defined contexts.
  """
  searchContexts(
    """Returns the first n search contexts from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """Query to filter the search contexts by spec."""
    query: String

    """
    Include search contexts matching the provided namespaces. A union of all matching search contexts is returned.
    ID can either be a user ID, org ID, or nil to match instance-level contexts. Empty namespaces list
    defaults to returning all available search contexts.
    Example: `namespaces: [user1, org1, org2, nil]` will return search contexts created by user1 + contexts
    created by org1 + contexts created by org2 + all instance-level contexts.
    """
    namespaces: [ID] = []

    """
    Sort field.
    Despite the value, the results are always sorted with the global context first,
    user's default context next, followed by the user's starred contexts,
    followed by the rest of the contexts.
    This controls the order of these internal groups.
    """
    orderBy: SearchContextsOrderBy = SEARCH_CONTEXT_SPEC

    """Sort direction."""
    descending: Boolean = false
  ): SearchContextConnection!

  """Fetch search context by spec (global, @username, @username/ctx, etc.)."""
  searchContextBySpec(spec: String!): SearchContext

  """
  Determines whether the search context is within the set of search contexts available to the current user.
  The set consists of contexts created by the user, contexts created by the
  users' organizations, and instance-level contexts.
  """
  isSearchContextAvailable(spec: String!): Boolean!

  """
  Gets the default search context for the current user. This context is guaranteed to be available to the user.
  """
  defaultSearchContext: SearchContext

  """All available notebooks."""
  notebooks(
    """Returns the first n notebooks from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """Query to filter notebooks by title and blocks content."""
    query: String

    """Filter to notebooks made by a single creator."""
    creatorUserID: ID

    """Filter to notebooks that were starred by the user."""
    starredByUserID: ID

    """
    Filter to notebooks associated with a specific namespace (user or org).
    """
    namespace: ID

    """Sort field."""
    orderBy: NotebooksOrderBy = NOTEBOOK_UPDATED_AT

    """Sort direction."""
    descending: Boolean = false
  ): NotebookConnection!

  """Computes valus from search results."""
  compute(
    """The search query."""
    query: String = ""
  ): [ComputeResult!]!

  """
  Returns information about aggregating the potential results of a search query.
  """
  searchQueryAggregate(query: String!, patternType: SearchPatternType!): SearchQueryAggregate!

  """
  Experimental: Searches a repository for similar code and text results using embeddings.
  We separated code and text results because text results tended to always feature at the top of the combined results,
  and didn't leave room for the code.
  """
  embeddingsSearch(
    """The repository to search."""
    repo: ID!

    """The query used for embeddings search."""
    query: String!

    """The number of code results to return."""
    codeResultsCount: Int!

    """
    The number of text results to return. Text results contain Markdown files
    and similar file types primarily used for writing documentation.
    """
    textResultsCount: Int!
  ): EmbeddingsSearchResults!

  """
  Experimental: Searches a set of repositories for similar code and text results using embeddings.
  We separated code and text results because text results tended to always feature at the top of the combined results,
  and didn't leave room for the code.
  """
  embeddingsMultiSearch(
    """The repository to search."""
    repos: [ID!]!

    """The query used for embeddings search."""
    query: String!

    """The number of code results to return."""
    codeResultsCount: Int!

    """
    The number of text results to return. Text results contain Markdown files
    and similar file types primarily used for writing documentation.
    """
    textResultsCount: Int!
  ): EmbeddingsSearchResults!

  """
  Experimental: Determines whether the given query requires further context before it can be answered.
  For example:
    - "What are Sourcegraph Notebooks" requires additional information from the
  Sourcegraph repository (Notebooks Markdown docs, etc.).
    - "Translate the previous code to Typescript" does not need additional
  context since it is referring to the existing context (or conversation).
  """
  isContextRequiredForChatQuery(query: String!): Boolean!

  """Experimental: Repo embedding jobs list."""
  repoEmbeddingJobs(
    """Number of jobs returned. Up to 100 jobs are returned by default."""
    first: Int

    """
    The number of nodes to return starting from the end (latest).
    Note: Use either last or first (see above) in the query. Setting both will
    return an error.
    """
    last: Int

    """
    Opaque pagination cursor to be used when paginating forwards that may be also used
    in conjunction with "first" to return the first N nodes.
    """
    after: String

    """
    Opaque pagination cursor to be used when paginating backwards that may be
    also used in conjunction with "last" to return the last N nodes.
    """
    before: String

    """Filter by the name of the repository."""
    query: String

    """Filter by the state of the job."""
    state: String
  ): RepoEmbeddingJobsConnection!

  """
  EXPERIMENTAL: Get pieces of context related to the query from a set of repositories.
  """
  getCodyContext(
    """The repositories to search."""
    repos: [ID!]!

    """A natural language query string."""
    query: String!

    """The number of code results to return."""
    codeResultsCount: Int!

    """
    The number of text results to return. Text results contain Markdown files
    and similar file types primarily used for writing documentation.
    """
    textResultsCount: Int!
  ): [CodyContextResult!]!

  """
  codeownersIngestedFiles returns all existing manually ingested codeowners files.
  """
  codeownersIngestedFiles(first: Int, after: Int): CodeownersIngestedFileConnection!

  """List all ownership signal configurations"""
  ownSignalConfigurations: [OwnSignalConfiguration!]!

  """Returns ownership stats for the whole Sourcegraph instance"""
  instanceOwnershipStats: OwnershipStats!

  """Returns a string of completion responses"""
  completions(input: CompletionsInput!): String!

  """
  EXPERIMENTAL: Searches the instances indexed code for code matching snippet.
  """
  snippetAttribution(snippet: String!, first: Int): SnippetAttributionConnection!
}

"""Query block allows performing inline search queries within a notebook."""
type QueryBlock {
  """ID of the block."""
  id: String!

  """A Sourcegraph search query string."""
  queryInput: String!
}

"""The result for Mutation.randomizeUserPassword."""
type RandomizeUserPasswordResult {
  """
  The reset password URL that the user must visit to sign into their account again. If the builtin
  username-password authentication provider is not enabled, this field's value is null.
  
  If email sending (SMTP) is configured on this instance, an email containing this URL
  will also be sent to the primary email address associated with the user.
  """
  resetPasswordURL: String

  """
  If true, then an email with the password reset URL was sent to the primary email
  address associated with the user. If false, email sending (SMTP) might not be configured
  on this instance, or an error may have occurred - check the error logs with log scope
  'randomizeUserPassword' for more details.
  """
  emailSent: Boolean!
}

"""
A range inside a file. The start position is inclusive, and the end position is exclusive.
"""
type Range {
  """The start position of the range (inclusive)."""
  start: Position!

  """The end position of the range (exclusive)."""
  end: Position!
}

"""Summary of one precise ranking job."""
type RankingSummary {
  """
  Identifier of the current ranking job. Corresponds to values in the site configuration.
  """
  graphKey: String!

  """
  True if the output of this ranking job is currently visible to the Zoekt indexserver.
  """
  visibleToZoekt: Boolean!

  """Progress of the path mapping stage."""
  pathMapperProgress: RankingSummaryProgress!

  """Progress of the reference mapping stage."""
  referenceMapperProgress: RankingSummaryProgress!

  """Progress of the reducer stage."""
  reducerProgress: RankingSummaryProgress
}

"""Progress of one stage of a precise ranking job."""
type RankingSummaryProgress {
  """When the job started."""
  startedAt: DateTime!

  """When the job completed (if finished)."""
  completedAt: DateTime

  """How many records have been processed."""
  processed: Int!

  """How many total items will be processed."""
  total: Int!
}

"""A signal derived from recent code contributors."""
type RecentContributorOwnershipSignal {
  """Descriptive title to display in the UI for the determination."""
  title: String!

  """More detailed description to display in the UI for the determination."""
  description: String!
}

"""A signal derived from recent code file views."""
type RecentViewOwnershipSignal {
  """Descriptive title to display in the UI for the determination."""
  title: String!

  """More detailed description to display in the UI for the determination."""
  description: String!
}

"""A reference to another Sourcegraph instance."""
type Redirect {
  """The URL of the other Sourcegraph instance."""
  url: String!
}

"""Input object for adding insight view to dashboard."""
input RemoveInsightViewFromDashboardInput {
  """ID of the insight view to remove from the dashboard"""
  insightViewId: ID!

  """ID of the dashboard."""
  dashboardId: ID!
}

"""
Stats on all the changesets that have been applied to this repository by batch changes.
"""
type RepoChangesetsStats {
  """The count of unpublished changesets."""
  unpublished: Int!

  """The count of draft changesets."""
  draft: Int!

  """The count of open changesets."""
  open: Int!

  """The count of merged changesets."""
  merged: Int!

  """The count of closed changesets."""
  closed: Int!

  """The count of all changesets."""
  total: Int!
}

"""
A corruption log entry that that records the time of when corruption was detected and a reason why the repo is regarded
as corrupt
"""
type RepoCorruptionLog {
  """The time at which the repository was detected to be corrupt"""
  timestamp: DateTime!

  """The reason why this repository was regarded as corrupt"""
  reason: String!
}

"""A repo embedding job."""
type RepoEmbeddingJob implements Node {
  """Unique node ID."""
  id: ID!

  """State of a repo embedding job."""
  state: RepoEmbeddingJobState!

  """Failure message for failed job."""
  failureMessage: String

  """Time when repo embedding job was queued."""
  queuedAt: DateTime!

  """Time when repo embedding job processing was started."""
  startedAt: DateTime

  """Time when repo embedding job processing finished."""
  finishedAt: DateTime

  """Time after which repo embedding job processing should be started."""
  processAfter: DateTime

  """Number of repo embedding job processing resets."""
  numResets: Int!

  """Number of repo embedding job processing failures."""
  numFailures: Int!

  """Time of last heartbeat of a repo embedding job processing."""
  lastHeartbeatAt: DateTime

  """Hostname of a worker on which repo embedding job is processing."""
  workerHostname: String!

  """
  Flag showing that given repo embedding job should be canceled instead of being processed.
  """
  cancel: Boolean!

  """The embedded repository."""
  repo: Repository

  """The revision at which the repo was embedded."""
  revision: GitCommit

  """
  Statistics about the embeddings index job.
  This will be updated periodically while the embeddings job is processing.
  """
  stats: RepoEmbeddingsStats!
}

"""Repo embedding jobs."""
type RepoEmbeddingJobsConnection implements Connection {
  """Repo embedding jobs."""
  nodes: [RepoEmbeddingJob!]!

  """The total number of jobs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""State types of repo embedding sync jobs."""
enum RepoEmbeddingJobState {
  QUEUED
  PROCESSING
  FAILED
  ERRORED
  COMPLETED
  CANCELED
}

"""
Statistics about an embeddings index job.
This will be updated periodically while the embeddings job is processing.
"""
type RepoEmbeddingsStats {
  """The number of files scheduled to be embedded."""
  filesScheduled: Int!

  """
  The number of files we generated embeddings for.
  This will be updated periodically while the embeddings job is processing.
  """
  filesEmbedded: Int!

  """
  The number of files skipped.
  This will be updated periodically while the embeddings job is processing.
  """
  filesSkipped: Int!
}

"""Repo key-value pair metadata"""
type RepoMetadata {
  """Returns paginated list of repo metadata distinct keys matching a query"""
  keys(
    query: String

    """Pagination paramters"""
    first: Int
    last: Int
    after: String
    before: String
  ): RepoMetadataKeyOrValueConnection!

  """Repo metadata key"""
  key(key: String!): RepoMetadataKeyResult
}

"""Repo metadata key or value connection result`"""
type RepoMetadataKeyOrValueConnection {
  """Total count of repo key-value pair metadata"""
  totalCount: Int!

  """A list of repo key-value pair metadata"""
  nodes: [String!]!

  """Pagination information."""
  pageInfo: BidirectionalPageInfo!
}

"""Repo metadata key result"""
type RepoMetadataKeyResult {
  """
  Returns paginated list of repo metadata distinct values matching a query
  """
  values(
    query: String

    """Pagination paramters"""
    first: Int
    last: Int
    after: String
    before: String
  ): RepoMetadataKeyOrValueConnection!
}

"""
A repository is a Git source control repository that is mirrored from some origin code host.
"""
type Repository implements Node & GenericSearchResultInterface {
  """The repository's unique ID."""
  id: ID!

  """
  The repository's name, as a path with one or more components. It conventionally consists of
  the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
  Examples:
  - github.com/foo/bar
  - my-code-host.example.com/myrepo
  - myrepo
  """
  name: String!

  """DEPRECATED: Use name."""
  uri: String! @deprecated(reason: "Use name.")

  """The source of this repository from where it was imported / converted."""
  sourceType: RepositoryType!

  """The repository's description."""
  description: String!

  """The primary programming language in the repository."""
  language: String!

  """
  DEPRECATED: This field is unused in known clients.
  The date when this repository was created on Sourcegraph.
  """
  createdAt: DateTime!

  """
  DEPRECATED: This field is unused in known clients.
  The date when this repository's metadata was last updated on Sourcegraph.
  """
  updatedAt: DateTime

  """
  Returns information about the given commit in the repository, or null if no commit exists with the given rev.
  """
  commit(
    """The Git revision specifier (revspec) for the commit."""
    rev: String!

    """
    Optional input revspec used to construct non-canonical URLs and other "friendly" field values. Used by
    clients that must ensure consistency of revision resolution within a session/request (so they use full
    SHAs) but also preserve the user input rev (for user friendliness).
    """
    inputRevspec: String
  ): GitCommit

  """
  EXPERIMENTAL: Returns infomration about the given changelist of the perforce depot, or null if
  no changelist exists with the given cid or it is not a perforce depot.
  """
  changelist(cid: String!): PerforceChangelist

  """The first commit inside the repo"""
  firstEverCommit: GitCommit

  """
  Information and status related to mirroring, if this repository is a mirror of another repository (e.g., on
  some code host). In this case, the remote source repository is external to Sourcegraph and the mirror is
  maintained by the Sourcegraph site (not the other way around).
  """
  mirrorInfo: MirrorRepositoryInfo!

  """
  Information about this repository from the external service that it originates from (such as GitHub, GitLab,
  Phabricator, etc.).
  """
  externalRepository: ExternalRepository!

  """Whether the repository is a fork."""
  isFork: Boolean!

  """Whether the repository has been archived."""
  isArchived: Boolean!

  """Whether the repository is private."""
  isPrivate: Boolean!

  """Lists all external services which yield this repository."""
  externalServices(
    """Returns the first n external services from the list."""
    first: Int
  ): ExternalServiceConnection!

  """Whether the repository is currently being cloned."""
  cloneInProgress: Boolean! @deprecated(reason: "use Repository.mirrorInfo.cloneInProgress instead")

  """
  Information about the text search index for this repository, or null if text search indexing
  is not enabled or supported for this repository.
  """
  textSearchIndex: RepositoryTextSearchIndex

  """The URL to this repository."""
  url: String!

  """The URLs to this repository on external services associated with it."""
  externalURLs: [ExternalLink!]!

  """
  The repository's default Git branch (HEAD symbolic ref). If the repository is currently being cloned or is
  empty, this field will be null.
  """
  defaultBranch: GitRef

  """The repository's Git refs."""
  gitRefs(
    """Returns the first n Git refs from the list."""
    first: Int

    """Return Git refs whose names match the query."""
    query: String

    """
    Return only Git refs of the given type.
    Known issue: It is only supported to retrieve Git branch and tag refs, not
    other Git refs.
    """
    type: GitRefType

    """Ordering for Git refs in the list."""
    orderBy: GitRefOrder

    """
    Ordering is an expensive operation that doesn't scale for lots of
    references. If this is true we fallback on not ordering. This should
    never be false in interactive API requests.
    """
    interactive: Boolean = true
  ): GitRefConnection!

  """The repository's Git branches."""
  branches(
    """Returns the first n Git branches from the list."""
    first: Int

    """Return Git branches whose names match the query."""
    query: String

    """Ordering for Git branches in the list."""
    orderBy: GitRefOrder

    """
    Ordering is an expensive operation that doesn't scale for lots of
    references. If this is true we fallback on not ordering. This should
    never be false in interactive API requests.
    """
    interactive: Boolean = true
  ): GitRefConnection!

  """The repository's Git tags."""
  tags(
    """Returns the first n Git tags from the list."""
    first: Int

    """Return Git tags whose names match the query."""
    query: String
  ): GitRefConnection!

  """A Git comparison in this repository between a base and head commit."""
  comparison(
    """
    The base of the diff ("old" or "left-hand side"), or "HEAD" if not specified.
    """
    base: String

    """
    The head of the diff ("new" or "right-hand side"), or "HEAD" if not specified.
    """
    head: String

    """Attempt to fetch missing revisions from remote if they are not found"""
    fetchMissing: Boolean = true
  ): RepositoryComparison!

  """The repository's contributors."""
  contributors(
    """The Git revision range to compute contributors in."""
    revisionRange: String

    """The date after which to count contributions."""
    afterDate: String

    """Return contributors to files in this path."""
    path: String

    """Returns the first n contributors from the list."""
    first: Int
    last: Int
    after: String
    before: String
  ): RepositoryContributorConnection!

  """Whether the viewer has admin privileges on this repository."""
  viewerCanAdminister: Boolean!

  """A markdown string that is rendered prominently."""
  label: Markdown!

  """A markdown string of that is rendered less prominently."""
  detail: Markdown!

  """The result previews of the result."""
  matches: [SearchResultMatch!]!

  """
  Information and status related to the commit graph of this repository calculated
  for use by code intelligence features.
  """
  codeIntelligenceCommitGraph: CodeIntelligenceCommitGraph!

  """The star count the repository has in the code host."""
  stars: Int!

  """A set of user-defined key-value pairs associated with the repo."""
  keyValuePairs: [KeyValuePair!]! @deprecated(reason: "Use repo.metadata instead. This field is a deprecated and will be removed in a future release.")

  """
  A set of user-defined key-value pairs metadata associated with the repo.
  """
  metadata: [KeyValuePair!]!

  """The size of repo when cloned on disk"""
  diskSizeBytes: BigInt

  """Returns true if embeddings for the repo are generated."""
  embeddingExists: Boolean!

  """
  Stats on all the changesets that have been created in this repository by batch
  changes.
  """
  changesetsStats: RepoChangesetsStats!

  """
  A list of batch changes that have applied a changeset to this repository.
  """
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!

  """
  A diff stat for all the changesets that have been applied to this repository
  by batch changes.
  """
  batchChangesDiffStat: DiffStat!

  """Gets the indexing configuration associated with the repository."""
  indexConfiguration: IndexConfiguration

  """Provides a summary of the most recent upload and index status."""
  codeIntelSummary: CodeIntelRepositorySummary!

  """
  The set of git objects that match the given git object type and glob pattern.
  This resolver is used by the UI to preview what names match a code intelligence
  policy in a given repository.
  """
  previewGitObjectFilter(
    """The type of Git object described by the configuration policy."""
    type: GitObjectType!

    """A pattern matching the name of the matching Git object."""
    pattern: String!

    """
    When specified, indicates that this request should return the first N items.
    """
    first: Int

    """
    When specified, the total number of matching Git objects younger than this value
    will be returned along with the total number of matching objects. This does not
    affect the set of objects returned as items.
    """
    countObjectsYoungerThanHours: Int
  ): GitObjectFilterPreview!

  """
  A list of authorized users to access this repository with the given permission.
  This API currently only returns permissions from the Sourcegraph provider, i.e.
  "permissions.userMapping" in site configuration.
  """
  authorizedUsers(
    """Permission that the user has on this repository."""
    permission: RepositoryPermission = READ

    """Number of users to return after the given cursor."""
    first: Int!

    """Opaque pagination cursor."""
    after: String
  ): UserConnection!

  """
  The permissions information of the repository for the authenticated user.
  It is null when there is no permissions data stored for the repository.
  """
  permissionsInfo: PermissionsInfo

  """Returns all embedding jobs for the repo."""
  embeddingJobs(
    """Number of jobs returned. Up to 100 jobs are returned by default."""
    first: Int

    """
    The number of nodes to return starting from the end (latest).
    Note: Use either last or first (see above) in the query. Setting both will
    return an error.
    """
    last: Int

    """
    Opaque pagination cursor to be used when paginating forwards that may be also used
    in conjunction with "first" to return the first N nodes.
    """
    after: String

    """
    Opaque pagination cursor to be used when paginating backwards that may be
    also used in conjunction with "last" to return the last N nodes.
    """
    before: String

    """Filter by the state of the job."""
    state: String
  ): RepoEmbeddingJobsConnection!

  """
  A file containing manually ingested codeowners data, if any. Null if no data has been uploaded.
  """
  ingestedCodeowners: CodeownersIngestedFile
}

"""The differences between two concrete Git commits in a repository."""
type RepositoryComparison {
  """The repository that is the base (left-hand side) of this comparison."""
  baseRepository: Repository!

  """
  The repository that is the head (right-hand side) of this comparison. Cross-repository
  comparisons are not yet supported, so this is always equal to
  RepositoryComparison.baseRepository.
  """
  headRepository: Repository!

  """The range that this comparison represents."""
  range: GitRevisionRange!

  """
  The commits in the comparison range, excluding the base and including the head.
  """
  commits(
    """Return the first n commits from the list."""
    first: Int

    """
    Filter to only the commits that modify files that match path.
    Path can be either a file or a containing directory.
    """
    path: String
  ): GitCommitConnection!

  """The file diffs for each changed file."""
  fileDiffs(
    """Return the first n file diffs from the list."""
    first: Int

    """Return file diffs after the given cursor."""
    after: String

    """A list of paths or directories used to filter the diffs"""
    paths: [String!]
  ): FileDiffConnection!
}

"""Either a preview or an actual repository comparison."""
union RepositoryComparisonInterface = RepositoryComparison | PreviewRepositoryComparison

"""Deprecated! A list of repositories."""
type RepositoryConnection {
  """A list of repositories."""
  nodes: [Repository!]!

  """
  The total count of repositories in the connection. This total count may be larger
  than the number of nodes in this object when the result is paginated.
  This requires admin permissions and will return null for all non-admin users.
  In some cases, the total count can't be computed quickly; if so, it is null. Pass
  precise: true to always compute total counts even if it takes a while.
  """
  totalCount(precise: Boolean = false): Int

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A contributor to a repository."""
type RepositoryContributor {
  """The personal information for the contributor."""
  person: Person!

  """The number of contributions made by this contributor."""
  count: Int!

  """The repository in which the contributions occurred."""
  repository: Repository!

  """Commits by the contributor."""
  commits(
    """Return the first n commits."""
    first: Int
  ): GitCommitConnection!
}

"""A list of contributors to a repository."""
type RepositoryContributorConnection {
  """A list of contributors to a repository."""
  nodes: [RepositoryContributor!]!

  """
  The total count of contributors in the connection, if available. This total count may be larger than the
  number of nodes in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: BidirectionalPageInfo!
}

"""
A decorated connection of repositories resulting from 'previewRepositoryFilter'.
"""
type RepositoryFilterPreview {
  """A list of repositories composing the current page."""
  nodes: [CodeIntelRepository!]!

  """The total number of repositories in this result set."""
  totalCount: Int!

  """
  If every repository currently on the instance is matched by this filter.
  """
  matchesAllRepos: Boolean!

  """The maximum number of repository matches a single policy can make."""
  limit: Int

  """
  The number of repositories matching the given filter. This value exceeds the
  value of totalCount of the result when totalMatches > limit.
  """
  totalMatches: Int!
}

"""Information about the indexserver that hosts the repo's index."""
type repositoryIndexserverHost {
  """The hostname of the indexserver."""
  name: String!
}

"""
RepositoryOrderBy enumerates the ways a repositories list can be ordered.
"""
enum RepositoryOrderBy {
  REPOSITORY_NAME
  REPO_CREATED_AT

  """deprecated (use the equivalent REPOSITORY_CREATED_AT)"""
  REPOSITORY_CREATED_AT
  SIZE
}

"""Different repository permission levels."""
enum RepositoryPermission {
  READ
}

"""Information about the number of repositories matched from a query"""
type RepositoryPreviewPayload {
  """The query used to find number of repository matches."""
  query: String!

  """The number of repositories matched."""
  numberOfRepositories: Int
}

"""
A repository or a link to another Sourcegraph instance location where this repository may be located.
"""
union RepositoryRedirect = Repository | Redirect

"""A custom repository scope for an insight data series."""
input RepositoryScopeInput {
  """The list of repositories included in this scope."""
  repositories: [String!]!

  """A search query to select repositories for this scope."""
  repositoryCriteria: String
}

"""
Describes a scope of repositories, this type is used for both the search based scopes and all repositories
"""
type RepositorySearchScope {
  """
  The user provided search used to generate the list of repositories the insight runs over.
  """
  search: String!

  """Indicates if this search scope represents all repositories"""
  allRepositories: Boolean!
}

"""FOR INTERNAL USE ONLY: A repository statistic"""
type RepositoryStats {
  """The amount of bytes stored in .git directories"""
  gitDirBytes: BigInt!

  """The number of lines indexed"""
  indexedLinesCount: BigInt!

  """
  The number of all repositories in the instance, without soft-deleted or blocked repositories.
  """
  total: Int!

  """
  The number of cloned repositories in the instance. This number might be
  higher than 'total', if soft-deleted repositories haven't been cleaned up
  yet.
  """
  cloned: Int!

  """
  The number of repositories in the instance that are currently being cloned.
  """
  cloning: Int!

  """The number of repositories in the instance that not cloned yet."""
  notCloned: Int!

  """
  The number of repositories where initial cloning or subsequent fetching resulted in an error.
  """
  failedFetch: Int!

  """The number of indexed repositories"""
  indexed: Int!

  """The number of repositories that are currently corrupt"""
  corrupted: Int!
}

"""Information about a repository's text search index."""
type RepositoryTextSearchIndex {
  """The indexed repository."""
  repository: Repository!

  """The status of the text search index, if available."""
  status: RepositoryTextSearchIndexStatus

  """
  Git refs in the repository that are configured for text search indexing.
  """
  refs: [RepositoryTextSearchIndexedRef!]!

  """Information about the indexserver that hosts the repo's index."""
  host: repositoryIndexserverHost
}

"""
A Git ref (usually a branch) in a repository that is configured to be indexed for text search.
"""
type RepositoryTextSearchIndexedRef {
  """
  The Git ref (usually a branch) that is configured to be indexed for text search. To find the specific commit
  SHA that was indexed, use RepositoryTextSearchIndexedRef.indexedCommit; this field's ref target resolves to
  the current target, not the target at the time of indexing.
  """
  ref: GitRef!

  """Whether a text search index exists for this ref."""
  indexed: Boolean!

  """
  Whether the text search index is of the current commit for the Git ref. If false, the index is stale.
  """
  current: Boolean!

  """
  The indexed Git commit (which may differ from the ref's current target if the index is out of date). If
  indexed is false, this field's value is null.
  """
  indexedCommit: GitObject

  """EXPERIMENTAL: Information about the files that were not indexed."""
  skippedIndexed: SkippedIndexed
}

"""The status of a repository's text search index."""
type RepositoryTextSearchIndexStatus {
  """The date that the index was last updated."""
  updatedAt: DateTime!

  """The byte size of the original content."""
  contentByteSize: BigInt!

  """The number of files in the original content."""
  contentFilesCount: Int!

  """The byte size of the index."""
  indexByteSize: Int!

  """The number of index shards."""
  indexShardsCount: Int!

  """EXPERIMENTAL: The number of newlines appearing in the index."""
  newLinesCount: Int!

  """EXPERIMENTAL: The number of newlines in the default branch."""
  defaultBranchNewLinesCount: Int!

  """EXPERIMENTAL: The number of newlines in the other branches."""
  otherBranchesNewLinesCount: Int!
}

"""
All possible types of currently supported repositories, even though they may be stored
as a git repository on disk.
"""
enum RepositoryType {
  GIT_REPOSITORY
  PERFORCE_DEPOT
}

"""
A not persisted resolved workspace, returned from resolveWorkspacesForBatchSpec.
"""
type ResolvedBatchSpecWorkspace {
  """The repository to run over."""
  repository: Repository!

  """The branch to run over."""
  branch: GitRef!

  """The path to run in."""
  path: String!

  """If true, only the files within the workspace will be fetched."""
  onlyFetchWorkspace: Boolean!

  """
  If true, this workspace has been skipped, because some rule forced this.
  For now, the only one is a .batchignore file existing in the repository.
  """
  ignored: Boolean!

  """
  If true, this workspace has been skipped, because the code host on which
  the repository is hosted is not supported.
  """
  unsupported: Boolean!

  """
  If this workspace was resolved based on a search, this is the list of paths
  to files that have been included in the search results.
  """
  searchResultPaths: [String!]!
}

"""A role"""
type Role implements Node {
  """The globally unique identifier for this role."""
  id: ID!

  """The human readable name for this role."""
  name: String!

  """
  Indicates whether a role is a default system role, which cannot be modified or
  deleted, or a custom role added by a site admin.
  """
  system: Boolean!

  """
  The list of permissions that will be granted to any user with this role.
  """
  permissions(
    """The limit argument for forward pagination."""
    first: Int

    """The limit argument for backward pagination."""
    last: Int

    """The cursor argument for forward pagination."""
    after: String

    """The cursor argument for backward pagination."""
    before: String
  ): PermissionConnection!

  """The date and time when the role was created."""
  createdAt: DateTime!
}

"""A list of roles."""
type RoleConnection {
  """A list of roles."""
  nodes: [Role!]!

  """The total count of roles in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""
Pairs a root directory with comparison key used to match index configurations for the same repository "project".
"""
type RootWithKey {
  """The root."""
  root: String!

  """
  A hash of the root and indexer values.
  
  This value can be used to quickly compare whether or not explicit configuration and inferred configuration
  refer to the same "project" in a given repository. See `AutoIndexJobDescription.comparisonKey`.
  """
  comparisonKey: String!
}

"""A saved search query, defined in settings."""
type SavedSearch implements Node {
  """The unique ID of this saved query."""
  id: ID!

  """The description."""
  description: String!

  """The query."""
  query: String!

  """
  Whether or not to notify the owner of the saved search via email. This owner is either
  a single user, or every member of an organization that owns the saved search.
  """
  notify: Boolean!

  """Whether or not to notify on Slack."""
  notifySlack: Boolean!

  """The user or org that owns this saved search."""
  namespace: Namespace!

  """The Slack webhook URL associated with this saved search, if any."""
  slackWebhookURL: String
}

"""A paginated connection for saved search queries, defined in settings."""
type SavedSearchesConnection implements Connection {
  """A list of saved searches."""
  nodes: [SavedSearch!]!

  """The total number of saved searches in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""Input for saving a new view on an insight."""
input SaveInsightAsNewViewInput {
  """The insight view ID we are creating a new view from."""
  insightViewId: ID!

  """The options for this line chart."""
  options: LineChartOptionsInput!

  """The dashboard ID to associate this insight with once created."""
  dashboard: ID

  """The default values for filters and aggregates for this line chart."""
  viewControls: InsightViewControlsInput
}

"""A summary of a schema drift."""
type SchemaDriftSummary {
  """Name of the table that contains the drift"""
  name: String!

  """The problem that was found"""
  problem: String!

  """The suggested solution to the problem"""
  solution: String!

  """The diff of the schema drift"""
  diff: String

  """The SQL to fix the schema drift"""
  statements: [String!]

  """The Sourcegraph URL that contains the potential fix"""
  urlHint: String
}

"""Information about scope query validity"""
type ScopedInsightQueryPayload {
  """The original query."""
  query: String!

  """Whether the query is valid."""
  isValid: Boolean!

  """The reason why the query is invalid."""
  invalidReason: String
}

"""A search."""
type Search {
  """The results."""
  results: SearchResults!

  """
  A subset of results (excluding actual search results) which are heavily
  cached and thus quicker to query. Useful for e.g. querying sparkline
  data.
  """
  stats: SearchResultsStats!
}

"""Supported aggregation modes for search aggregations"""
enum SearchAggregationMode {
  REPO
  PATH
  AUTHOR
  CAPTURE_GROUP
  REPO_METADATA
}

"""Indicates that a search aggregation is not available"""
type SearchAggregationNotAvailable {
  """The specific reason a search aggregation is not available"""
  reason: String!

  """The general reason a search aggregation is not available"""
  reasonType: NotAvailableReasonType!

  """The SearchAggregationMode that is unavailable"""
  mode: SearchAggregationMode!
}

"""Defines how the data series is generated."""
union SearchAggregationResult = ExhaustiveSearchAggregationResult | NonExhaustiveSearchAggregationResult | SearchAggregationNotAvailable

"""A search-related alert message."""
type SearchAlert {
  """The title."""
  title: String!

  """The description."""
  description: String

  """An identifier indicating the kind of alert"""
  kind: String

  """"Did you mean: ____" query proposals"""
  proposedQueries: [SearchQueryDescription!]
}

"""A search context. Specifies a set of repositories to be searched."""
type SearchContext implements Node {
  """The unique id of the search context."""
  id: ID!

  """The name of the search context."""
  name: String!

  """
  The owner (user or org) of the search context. If nil, search context is considered instance-level.
  """
  namespace: Namespace

  """The description of the search context."""
  description: String!

  """
  Fully-qualified search context spec for use when querying.
  Examples: global, @username, @username/ctx, and @org/ctx.
  """
  spec: String!

  """
  Whether the search context is autodefined by Sourcegraph.
  The only autodefined context currently is the global search context ("global").
  """
  autoDefined: Boolean!

  """
  Sourcegraph search query that defines the search context.
  e.g. "r:^github\.com/org (rev:bar or rev:HEAD) file:^sub/dir"
  """
  query: String!

  """Repositories and their revisions that will be searched when querying."""
  repositories: [SearchContextRepositoryRevisions!]!

  """
  Public property controls the visibility of the search context. Public search context is available to
  any user on the instance. If a public search context contains private repositories, those are filtered out
  for unauthorized users. Private search contexts are only available to their owners. Private user search context
  is available only to the user, private org search context is available only to the members of the org, and private
  instance-level search contexts are available only to site-admins.
  """
  public: Boolean!

  """Date and time the search context was last updated."""
  updatedAt: DateTime!

  """If current viewer can manage (edit, delete) the search context."""
  viewerCanManage: Boolean!

  """If the viewer has set this context as default."""
  viewerHasAsDefault: Boolean!

  """If the viewer has starred this context."""
  viewerHasStarred: Boolean!
}

"""A list of search contexts"""
type SearchContextConnection {
  """A list of search contexts."""
  nodes: [SearchContext!]!

  """The total number of search contexts in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Input for editing an existing search context."""
input SearchContextEditInput {
  """
  Search context name. Not the same as the search context spec. Search context namespace and search context name
  are used to construct the fully-qualified search context spec.
  Example mappings from search context spec to search context name: global -> global, @user -> user, @org -> org,
  @user/ctx1 -> ctx1, @org/ctxs/ctx -> ctxs/ctx.
  """
  name: String!

  """Search context description."""
  description: String!

  """
  Public property controls the visibility of the search context. Public search context is available to
  any user on the instance. If a public search context contains private repositories, those are filtered out
  for unauthorized users. Private search contexts are only available to their owners. Private user search context
  is available only to the user, private org search context is available only to the members of the org, and private
  instance-level search contexts are available only to site-admins.
  """
  public: Boolean!

  """
  Sourcegraph search query that defines the search context.
  e.g. "r:^github\.com/org (rev:bar or rev:HEAD) file:^sub/dir"
  """
  query: String!
}

"""Input for a new search context."""
input SearchContextInput {
  """
  Search context name. Not the same as the search context spec. Search context namespace and search context name
  are used to construct the fully-qualified search context spec.
  Example mappings from search context spec to search context name: global -> global, @user -> user, @org -> org,
  @user/ctx1 -> ctx1, @org/ctxs/ctx -> ctxs/ctx.
  """
  name: String!

  """Search context description."""
  description: String!

  """
  Public property controls the visibility of the search context. Public search context is available to
  any user on the instance. If a public search context contains private repositories, those are filtered out
  for unauthorized users. Private search contexts are only available to their owners. Private user search context
  is available only to the user, private org search context is available only to the members of the org, and private
  instance-level search contexts are available only to site-admins.
  """
  public: Boolean!

  """
  Namespace of the search context (user or org). If not set, search context is considered instance-level.
  """
  namespace: ID

  """
  Sourcegraph search query that defines the search context.
  e.g. "r:^github\.com/org (rev:bar or rev:HEAD) file:^sub/dir"
  """
  query: String!
}

"""Specifies a set of revisions to be searched within a repository."""
type SearchContextRepositoryRevisions {
  """The repository to be searched."""
  repository: Repository!

  """The set of revisions to be searched."""
  revisions: [String!]!
}

"""Input for a set of revisions to be searched within a repository."""
input SearchContextRepositoryRevisionsInput {
  """ID of the repository to be searched."""
  repositoryID: ID!

  """Revisions in the repository to be searched."""
  revisions: [String!]!
}

"""
SearchContextsOrderBy enumerates the ways a search contexts list can be ordered.
"""
enum SearchContextsOrderBy {
  SEARCH_CONTEXT_SPEC
  SEARCH_CONTEXT_UPDATED_AT
}

"""A search filter."""
type SearchFilter {
  """The value."""
  value: String!

  """The string to be displayed in the UI."""
  label: String!

  """Number of matches for a given filter."""
  count: Int!

  """Whether the results returned are incomplete."""
  limitHit: Boolean!

  """The kind of filter. Should be "file" or "repo"."""
  kind: String!
}

"""
Defines an insight data series that is constructed from a Sourcegraph search query.
"""
type SearchInsightDataSeriesDefinition {
  """Unique ID for the series."""
  seriesId: String!

  """The query string."""
  query: String!

  """
  A scope of repositories defined for this series. Series with repository scopes
  defined by a search query are not identifiable via this field
  """
  repositoryScope: InsightRepositoryScope! @deprecated(reason: "use repositoryDefinition instead")

  """A definition of Repositories this series will operate over."""
  repositoryDefinition: InsightRepositoryDefinition!

  """The scope of time for which the insight data is generated."""
  timeScope: InsightTimeScope!

  """
  Whether or not the the time series are derived from the captured groups of the search results.
  """
  generatedFromCaptureGroups: Boolean!

  """
  Whether or not the series has been pre-calculated, or still needs to be resolved. This field is largely only used
  for the code insights webapp, and should be considered unstable (planned to be deprecated in a future release).
  """
  isCalculated: Boolean!

  """
  The field to group results by. (For compute powered insights only.) This field
  is experimental and should be considered unstable in the API.
  """
  groupBy: GroupByField
}

"""
Required input to generate a time series for a search insight using live preview.
"""
input SearchInsightLivePreviewInput {
  """The query string."""
  query: String!

  """
  The desired label for the series. Will be overwritten when series are dynamically generated.
  """
  label: String!

  """The scope of repositories."""
  repositoryScope: RepositoryScopeInput!

  """The scope of time."""
  timeScope: TimeScopeInput!

  """
  Whether or not to generate the timeseries results from the query capture groups.
  """
  generatedFromCaptureGroups: Boolean!

  """
  Use this field to specify a compute insight. Note: this is experimental and should be considered unstable
  """
  groupBy: GroupByField
}

"""Input object for a live preview search based code insight."""
type SearchInsightLivePreviewSeries {
  """The data points for the time series."""
  points: [InsightDataPoint!]!

  """The label for the data series."""
  label: String!
}

"""Required input to generate a live preview for an insight."""
input SearchInsightPreviewInput {
  """The scope of repositories."""
  repositoryScope: RepositoryScopeInput!

  """The scope of time."""
  timeScope: TimeScopeInput!

  """The series to generate previews for"""
  series: [SearchSeriesPreviewInput!]!
}

"""The search pattern type."""
enum SearchPatternType {
  standard
  literal
  regexp
  structural
  lucky
  keyword
}

"""Information about search aggregations"""
type SearchQueryAggregate {
  """A list of the possible aggregation modes and if they are available"""
  modeAvailability: [AggregationModeAvailability!]!

  """
  A result of aggregating a search query for the specified aggregation mode.
  mode - the requested aggregation mode, if null a default will be selected based on the search query
  limit - is the maximum number of aggregation groups to return, this limit will not override any internal limits.
  extendedTimeout - indicates of the aggregation request should use an extended timeout.
  """
  aggregations(mode: SearchAggregationMode, limit: Int = 50, extendedTimeout: Boolean = false): SearchAggregationResult!
}

"""Additional information describing attributes of a query."""
type SearchQueryAnnotation {
  """A name for this query annotation label."""
  name: String!

  """An opaque value for this query annotation."""
  value: String!
}

"""A search query description."""
type SearchQueryDescription {
  """The description."""
  description: String

  """The query."""
  query: String!

  """Additional optional information describing attributes of this query."""
  annotations: [SearchQueryAnnotation!]
}

"""The output format to emit for a parsed query."""
enum SearchQueryOutputFormat {
  """JSON format."""
  JSON

  """S-expression format."""
  SEXP

  """Mermaid flowchart format."""
  MERMAID
}

"""
Represents phases in query parsing. The parse tree corresponds closely to the
input query syntax. A subsequent processing phase on the parse tree generates a
job tree. The job tree is an internal representation analogous to a database
query plan. The job tree discards information about query syntax and corresponds
closely to backend services (text search, git commit search, etc.).
"""
enum SearchQueryOutputPhase {
  PARSE_TREE
  JOB_TREE
}

"""The output format to emit for a parsed query."""
enum SearchQueryOutputVerbosity {
  """Minimal verbosity outputs only nodes."""
  MINIMAL

  """
  Basic verbosity outputs nodes and essential fields associated with nodes.
  """
  BASIC

  """
  Maximal verbosity outputs nodes and all information associated with nodes.
  """
  MAXIMAL
}

"""A search result."""
union SearchResult = FileMatch | CommitSearchResult | Repository

"""
A match in a search result. Matches make up the body content of a search result.
"""
type SearchResultMatch {
  """URL for the individual result match."""
  url: String!

  """A markdown string containing the preview contents of the result match."""
  body: Markdown!

  """
  A list of highlights that specify locations of matches of the query in the body. Each highlight is
  a line number, character offset, and length. Currently, highlights are only displayed on match bodies
  that are code blocks. If the result body is a code block, exclude the markdown code fence lines in
  the line and character count. Leave as an empty list if no highlights are available.
  """
  highlights: [Highlight!]!
}

"""Search results."""
type SearchResults {
  """
  The results. Inside each SearchResult there may be multiple matches, e.g.
  a FileMatch may contain multiple line matches.
  """
  results: [SearchResult!]!

  """
  The total number of matches returned by this search. This is different
  than the length of the results array in that e.g. a single results array
  entry may contain multiple matches. For example, the results array may
  contain two file matches and this field would report 6 ("3 line matches
  per file") while the length of the results array would report 3
  ("3 FileMatch results").
  Typically, 'approximateResultCount', not this field, is shown to users.
  """
  matchCount: Int!

  """DEPRECATED: Renamed to 'matchCount' for less ambiguity."""
  resultCount: Int! @deprecated(reason: "renamed to matchCount for less ambiguity")

  """
  The approximate number of results. This is like the length of the results
  array, except it can indicate the number of results regardless of whether
  or not the limit was hit. Currently, this is represented as e.g. "5+"
  results.
  This string is typically shown to users to indicate the true result count.
  """
  approximateResultCount: String!

  """
  Whether or not the results limit was hit.
  In paginated requests, this field is always false. Use 'pageInfo.hasNextPage' instead.
  """
  limitHit: Boolean!

  """Integers representing the sparkline for the search results."""
  sparkline: [Int!]!

  """Repositories from results."""
  repositories: [Repository!]!

  """
  The number of repositories that had results (for clients
  that just wish to know how many without querying the, sometimes extremely
  large, list).
  """
  repositoriesCount: Int!

  """
  Repositories that are busy cloning onto gitserver.
  In paginated search requests, some repositories may be cloning. These are reported here
  and you may choose to retry the paginated request with the same cursor after they have
  cloned OR you may simply continue making further paginated requests and choose to skip
  the cloning repositories.
  """
  cloning: [Repository!]!

  """
  Repositories or commits that do not exist.
  In paginated search requests, some repositories may be missing (e.g. if Sourcegraph is
  aware of them but is temporarily unable to serve them). These are reported here and you
  may choose to retry the paginated request with the same cursor and they may no longer be
  missing OR you may simply continue making further paginated requests and choose to skip
  the missing repositories.
  """
  missing: [Repository!]!

  """
  Repositories or commits which we did not manage to search in time. Trying
  again usually will work.
  In paginated search requests, this field is not relevant.
  """
  timedout: [Repository!]!

  """
  DEPRECATED: This field is not used in known clients, and will always return `false`.
  True if indexed search is enabled but was not available during this search.
  """
  indexUnavailable: Boolean!

  """An alert message that should be displayed before any results."""
  alert: SearchAlert

  """The time it took to generate these results."""
  elapsedMilliseconds: Int!

  """Dynamic filters generated by the search results"""
  dynamicFilters: [SearchFilter!]!
}

"""Statistics about search results."""
type SearchResultsStats {
  """The approximate number of results returned."""
  approximateResultCount: String!

  """The sparkline."""
  sparkline: [Int!]!

  """
  Statistics about the languages represented in the search results.
  Known issue: The LanguageStatistics.totalBytes field values are incorrect in the result.
  """
  languages: [LanguageStatistics!]!
}

"""Required input to generate a live preview for a series."""
input SearchSeriesPreviewInput {
  """The query string."""
  query: String!

  """
  The desired label for the series. Will be overwritten when series are dynamically generated.
  """
  label: String!

  """
  Whether or not to generate the timeseries results from the query capture groups.
  """
  generatedFromCaptureGroups: Boolean!

  """
  Use this field to specify a compute insight. Note: this is experimental and should be considered unstable
  """
  groupBy: GroupByField
}

"""The version of the search syntax."""
enum SearchVersion {
  """Search syntax that defaults to regexp search."""
  V1

  """Search syntax that defaults to literal-only search."""
  V2

  """Search syntax that defaults to standard search."""
  V3
}

"""Options that affect which series to display for an insight."""
type SeriesDisplayOptions {
  """Sort options for the series."""
  sortOptions: SeriesSortOptions!

  """Max number of series to return."""
  limit: Int

  """Max number of samples to return for all the series on the view."""
  numSamples: Int
}

"""Input type for series display options."""
input SeriesDisplayOptionsInput {
  """Sort options for the series."""
  sortOptions: SeriesSortOptionsInput

  """Max number of series to return."""
  limit: Int

  """Max number of samples to return."""
  numSamples: Int
}

"""Sort direction for series."""
enum SeriesSortDirection {
  ASC
  DESC
}

"""Sort mode for series."""
enum SeriesSortMode {
  RESULT_COUNT
  LEXICOGRAPHICAL
  DATE_ADDED
}

"""Series sort options."""
type SeriesSortOptions {
  """Sort mode for series."""
  mode: SeriesSortMode

  """Sort direction for series."""
  direction: SeriesSortDirection
}

"""Input type for series sort options."""
input SeriesSortOptionsInput {
  """Sort mode for series."""
  mode: SeriesSortMode!

  """Sort direction for series."""
  direction: SeriesSortDirection!
}

"""An active user session."""
type Session {
  """Whether the user can sign out of this session on Sourcegraph."""
  canSignOut: Boolean!
}

"""Settings is a version of a configuration settings file."""
type Settings {
  """The ID."""
  id: Int!

  """The subject that these settings are for."""
  subject: SettingsSubject!

  """
  The author, or null if there is no author or the authoring user was deleted.
  """
  author: User

  """The time when this was created."""
  createdAt: DateTime!

  """
  The stringified JSON contents of the settings. The contents may include "//"-style comments and trailing
  commas in the JSON.
  """
  contents: JSONCString!

  """
  DEPRECATED: This field will be removed in a future release.
  The configuration.
  """
  configuration: Configuration! @deprecated(reason: "use the contents field instead")
}

"""
The configurations for all of the relevant settings subjects, plus the merged settings.
"""
type SettingsCascade {
  """
  The other settings subjects that are applied with lower precedence than this subject to
  form the final merged settings. For example, a user in 2 organizations would have the following
  settings subjects: site (global settings), org 1, org 2, and the user.
  """
  subjects: [SettingsSubject!]!

  """
  The effective final merged settings as (stringified) JSON, merged from all of the subjects.
  """
  final: String!

  """
  DEPRECATED: This field will be removed in a future release.
  The effective final merged settings, merged from all of the subjects.
  """
  merged: Configuration! @deprecated(reason: "use final instead")
}

"""
An edit to a JSON property in a settings JSON object. The JSON property to edit can be nested.
"""
input SettingsEdit {
  """
  The key path of the property to update.
  
  Inserting into an existing array is not yet supported.
  """
  keyPath: [KeyPathSegment!]!

  """
  The new JSON-encoded value to insert. If the field's value is not set, the property is removed. (This is
  different from the field's value being the JSON null value.)
  
  When the value is a non-primitive type, it must be specified using a GraphQL variable, not an inline literal,
  or else the GraphQL parser will return an error.
  """
  value: JSONValue

  """
  Whether to treat the value as a JSONC-encoded string, which makes it possible to perform an edit that
  preserves (or adds/removes) comments.
  """
  valueIsJSONCEncodedString: Boolean = false
}

"""
Mutations that update settings (global, organization, or user settings). These mutations are grouped together
because they:
- are all versioned to avoid race conditions with concurrent editors
- all apply to a specific settings subject (i.e., a user, an organization, or the whole site)

Grouping them lets us extract those common parameters to the Mutation.settingsMutation field.
"""
type SettingsMutation {
  """Edit a single property in the settings object."""
  editSettings(
    """The edit to apply to the settings."""
    edit: SettingsEdit!
  ): UpdateSettingsPayload

  """DEPRECATED"""
  editConfiguration(edit: ConfigurationEdit!): UpdateSettingsPayload @deprecated(reason: "Use editSettings instead. This field is a deprecated alias for it and will be removed in a future release.")

  """Overwrite the existing settings with the new settings."""
  overwriteSettings(
    """
    A JSON object (stringified) of the settings. Trailing commas and "//"-style comments are supported. The
    entire previous settings value will be overwritten by this new value.
    """
    contents: String!
  ): UpdateSettingsPayload
}

"""
Input for Mutation.settingsMutation, which contains fields that all settings (global, organization, and user
settings) mutations need.
"""
input SettingsMutationGroupInput {
  """The subject whose settings to mutate (organization, user, etc.)."""
  subject: ID!

  """
  The ID of the last-known settings known to the client, or null if there is none. This field is used to
  prevent race conditions when there are concurrent editors.
  """
  lastID: Int
}

"""
SettingsSubject is something that can have settings: a site ("global settings", which is different from "site
configuration"), an organization, or a user.
"""
interface SettingsSubject {
  """The ID."""
  id: ID!

  """The latest settings."""
  latestSettings: Settings

  """The URL to the settings."""
  settingsURL: String

  """Whether the viewer can modify the subject's settings."""
  viewerCanAdminister: Boolean!

  """
  All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
  that were merged to produce the final merged settings.
  """
  settingsCascade: SettingsCascade!

  """DEPRECATED"""
  configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
}

"""A signature."""
type Signature {
  """The person."""
  person: Person!

  """The date."""
  date: String!
}

"""
A site is an installation of Sourcegraph that consists of one or more
servers that share the same configuration and database.
The site is a singleton; the API only ever returns the single global site.
"""
type Site implements SettingsSubject {
  """
  The site's opaque GraphQL ID. This is NOT the "site ID" as it is referred to elsewhere;
  use the siteID field for that. (GraphQL node types conventionally have an id field of type
  ID! that globally identifies the node.)
  """
  id: ID!

  """The site ID."""
  siteID: String!

  """The site's configuration. Only visible to site admins."""
  configuration: SiteConfiguration!

  """
  The site's latest site-wide settings (which are the second-lowest-precedence
  in the configuration cascade for a user).
  """
  latestSettings: Settings

  """
  The global settings for this site, and the final merged settings.
  All viewers can access this field.
  """
  settingsCascade: SettingsCascade!

  """DEPRECATED"""
  configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")

  """The URL to the site's settings."""
  settingsURL: String

  """Whether the viewer can reload the site (with the reloadSite mutation)."""
  canReloadSite: Boolean!

  """Whether the viewer can modify the subject's settings."""
  viewerCanAdminister: Boolean!

  """A list of all access tokens on this site."""
  accessTokens(
    """Returns the first n access tokens from the list."""
    first: Int
  ): AccessTokenConnection!

  """
  A list of all authentication providers. This information is visible to all viewers and does not contain any
  secret information.
  """
  authProviders: AuthProviderConnection!

  """A list of all user external accounts on this site."""
  externalAccounts(
    """Returns the first n external accounts from the list."""
    first: Int

    """Include only external accounts associated with this user."""
    user: ID

    """Include only external accounts with this service type."""
    serviceType: String

    """Include only external accounts with this service ID."""
    serviceID: String

    """Include only external accounts with this client ID."""
    clientID: String
  ): ExternalAccountConnection!

  """
  The build version of the Sourcegraph software that is running on this site (of the form
  NNNNN_YYYY-MM-DD_XXXXX, like 12345_2018-01-01_abcdef).
  """
  buildVersion: String!

  """
  The product version of the Sourcegraph software that is running on this site.
  """
  productVersion: String!

  """
  Information about software updates for the version of Sourcegraph that this site is running.
  """
  updateCheck: UpdateCheck!

  """Whether the site needs to be configured to add repositories."""
  needsRepositoryConfiguration: Boolean!

  """
  Whether the external services haven been created from a configuration file
  specified in the EXTSVC_CONFIG_FILE.
  """
  externalServicesFromFile: Boolean!

  """
  Whether the external services can be updated even if `externalServicesFromFile` is
  true. All changes made while `externalServicesFromFile` is true will be discarded once
  Sourcegraph restarts.
  """
  allowEditExternalServicesWithFile: Boolean!

  """
  The number of external services distinguished by local repositories and remote repositories.
  Local repository code host connections are only supported in Sourcegraph App.
  """
  externalServicesCounts: ExternalServicesCounts!

  """
  Whether the site is over the limit for free user accounts, and a warning needs to be shown to all users.
  Only applies if the site does not have a valid license.
  """
  freeUsersExceeded: Boolean!

  """Alerts to display to the viewer."""
  alerts: [Alert!]!

  """BACKCOMPAT: Always returns true."""
  hasCodeIntelligence: Boolean!

  """
  Whether the server sends emails to users to verify email addresses. If false, then site admins must manually
  verify users' email addresses.
  """
  sendsEmailVerificationEmails: Boolean!

  """Information about this site's product subscription status."""
  productSubscription: ProductSubscriptionStatus!

  """Usage statistics for this site."""
  usageStatistics(
    """Days of history (based on current UTC time)."""
    days: Int

    """Weeks of history (based on current UTC time)."""
    weeks: Int

    """Months of history (based on current UTC time)."""
    months: Int
  ): SiteUsageStatistics!

  """New usage statistics/analytics for this site."""
  analytics: Analytics!

  """List all users."""
  users(
    """Return users whose usernames or display names match the query."""
    query: String

    """Returns users who have been active in a given period of time."""
    siteAdmin: Boolean

    """Returns users that contain filter in the username field."""
    username: String

    """Returns users that contain filter in the email field."""
    email: String

    """
    Returns users for the given lastActive enum period.
    When omitted does NOT apply and returns for all period available.
    """
    lastActiveAt: SiteUsersDateRangeInput

    """
    Returns either deleted or not deleted users. Returns all users when omitted.
    """
    deletedAt: SiteUsersDateRangeInput

    """Returns users who where created within a given date time range."""
    createdAt: SiteUsersDateRangeInput

    """Returns users whose events count within a given range."""
    eventsCount: SiteUsersNumberRangeInput
  ): SiteUsers!

  """
  Monitoring overview for this site.
  Note: This is primarily used for displaying recently-fired alerts in the web app. If your intent
  is to monitor Sourcegraph, it is better to configure alerting or query Prometheus directly in
  order to ensure that if the frontend goes down you still receive alerts:
  Configure alerting: https://docs.sourcegraph.com/admin/observability/alerting
  Query Prometheus directly: https://docs.sourcegraph.com/admin/observability/alerting_custom_consumption
  """
  monitoringStatistics(
    """Days of history (based on current UTC time)."""
    days: Int
  ): MonitoringStatistics!

  """
  Whether changes can be made to site settings through the API. When global settings are configured through
  the GLOBAL_SETTINGS_FILE environment variable, site settings edits cannot be made through the API.
  """
  allowSiteSettingsEdits: Boolean!

  """
  FOR INTERNAL USE ONLY: Returns information about instance upgrade readiness.
  """
  upgradeReadiness: UpgradeReadiness!

  """
  FOR INTERNAL USE ONLY: The state of readiness to auto upgrade the Sourcegraph instance via migrator commands.
  """
  autoUpgradeEnabled: Boolean!

  """
  Wether the current App installation has a connected Sourcegraph.com account.
  """
  appHasConnectedDotComAccount: Boolean!

  """
  The quota of completions requests allowed per user in a day. Null, if unlimited.
  """
  perUserCompletionsQuota: Int

  """
  The quota of code completions requests allowed per user in a day. Null, if unlimited.
  """
  perUserCodeCompletionsQuota: Int

  """
  Whether users are required to have a verified email in order to access Cody.
  """
  requiresVerifiedEmailForCody: Boolean!

  """Whether Cody is enabled for this site."""
  isCodyEnabled: Boolean!
}

"""The configuration for a site."""
type SiteConfiguration {
  """The unique identifier of this site configuration version."""
  id: Int!

  """The effective configuration JSON."""
  effectiveContents: JSONCString!

  """
  Messages describing validation problems or usage of deprecated configuration in the configuration JSON.
  This includes both JSON Schema validation problems and other messages that perform more advanced checks
  on the configuration (that can't be expressed in the JSON Schema).
  """
  validationMessages: [String!]!

  """
  EXPERIMENTAL: A list of diffs to depict what changed since the previous version of this
  configuration.
  Only site admins may perform this query.
  """
  history(
    """
    The number of nodes to return starting from the beginning (oldest).
    Note: Use either first or last (see below) in the query. Setting both will
    return an error.
    """
    first: Int

    """
    The number of nodes to return starting from the end (latest).
    Note: Use either last or first (see above) in the query. Setting both will
    return an error.
    """
    last: Int

    """
    Opaque pagination cursor to be used when paginating forwards that may be also used
    in conjunction with "first" to return the first N nodes.
    """
    after: String

    """
    Opaque pagination cursor to be used when paginating backwards that may be
    also used in conjunction with "last" to return the last N nodes.
    """
    before: String
  ): SiteConfigurationChangeConnection
}

"""
A diff representing the change in the site config compared to the previous version.
"""
type SiteConfigurationChange implements Node {
  """The ID of the site config in the history."""
  id: ID!

  """
  The user who made this change. If empty, it indicates that either the
  author's information is not available or the change in the site config was applied
  via an internal process (example: site startup or SITE_CONFIG_FILE being reloaded).
  """
  author: User

  """The diff string when diffed against the previous site config."""
  diff: String!

  """The timestamp when this change in the site config was applied."""
  createdAt: DateTime!

  """
  The timestamp when this change in the site config was modified. Usually
  this should be the same as createdAt as entries in the site config history are
  considered immutable.
  """
  updatedAt: DateTime!
}

"""
A list of site config diffs. Diff generation may not be available from the very
start depending on when the value of redacted_contents is available in the
database.
"""
type SiteConfigurationChangeConnection implements Connection {
  """A list of diffs in the site config"""
  nodes: [SiteConfigurationChange!]!

  """The total number of diffs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: ConnectionPageInfo!
}

"""
SiteUsagePeriod describes a site's usage statistics for a given timespan.
This information is visible to all viewers.
"""
type SiteUsagePeriod {
  """The time when this started."""
  startTime: String!

  """The user count."""
  userCount: Int!

  """The registered user count."""
  registeredUserCount: Int!

  """The anonymous user count."""
  anonymousUserCount: Int!

  """
  The count of registered users that have been active on a code host integration.
  Excludes anonymous users.
  """
  integrationUserCount: Int!
}

"""
SiteUsageStatistics describes a site's aggregate usage statistics.
This information is visible to all viewers.
"""
type SiteUsageStatistics {
  """Recent daily active users."""
  daus: [SiteUsagePeriod!]!

  """Recent weekly active users."""
  waus: [SiteUsagePeriod!]!

  """Recent monthly active users."""
  maus: [SiteUsagePeriod!]!
}

"""Site user."""
type SiteUser {
  """The unique ID for the user."""
  id: ID!

  """User's username."""
  username: String!

  """User's primary email."""
  email: String

  """User's display name"""
  displayName: String

  """The datetime when user was created in the system."""
  createdAt: String!

  """The datetime when user was last active."""
  lastActiveAt: String

  """The datetime when user was deleted."""
  deletedAt: String

  """Whether user is site admin or not."""
  siteAdmin: Boolean!

  """Whether the user is controlled through SCIM."""
  scimControlled: Boolean!

  """Total number of user's event_logs."""
  eventsCount: Float!

  """Whether or not the user account is locked."""
  locked: Boolean!
}

"""SiteUserOrderBy enumerates the ways a users list can be ordered."""
enum SiteUserOrderBy {
  USERNAME

  """User's primary email."""
  EMAIL

  """The total number of user's event_logs."""
  EVENTS_COUNT

  """The last event_log datetime."""
  LAST_ACTIVE_AT

  """The datetime when user was added to the system."""
  CREATED_AT

  """The datetime when user was soft deleted."""
  DELETED_AT

  """Whether the user is site admin or not."""
  SITE_ADMIN
}

"""Site users."""
type SiteUsers {
  """User total count."""
  totalCount: Float!

  """List of users."""
  nodes(
    """Returns the "limit" number users from the list."""
    limit: Int

    """Skips initial "offset" number of users."""
    offset: Int

    """Returns users ordered by a given column."""
    orderBy: SiteUserOrderBy

    """Returns ordered users in descending order provided by orderBy field."""
    descending: Boolean
  ): [SiteUser!]!
}

"""
SiteUsersDateRangeInput argument to filter based on date range or date equals to null
"""
input SiteUsersDateRangeInput {
  """Less than or equal to"""
  lte: DateTime

  """Greater than or equal to"""
  gte: DateTime

  """Negation"""
  not: Boolean

  """Equal to Null"""
  empty: Boolean
}

"""SiteUsersNumberRangeInput argument to filter based on the number range"""
input SiteUsersNumberRangeInput {
  """Less than or equal to"""
  gte: Float

  """Greater than or equal to"""
  lte: Float
}

"""EXPERIMENTAL: Information about the files that were not indexed."""
type SkippedIndexed {
  """The count of files that were not indexed."""
  count: BigInt!

  """The query to retrieve the list of files that were not indexed."""
  query: String!
}

"""A logged slow GraphQL request, captured by the backend."""
type SlowRequest {
  """The index of this request."""
  index: String!

  """The date at which this request was started."""
  start: DateTime!

  """The duration of the request."""
  duration: Float!

  """The user associated with that request, if any."""
  user: User

  """The name of the GraphQL request."""
  name: String!

  """The source from which the request originated."""
  source: String!

  """The repository referenced by the request, if any."""
  repository: Repository

  """The variables used to build the GraphQL request."""
  variables: String!

  """The errors returned if the request failed."""
  errors: [String!]!

  """The GraphQL query."""
  query: String!

  """The file path referenced by the request, if any."""
  filepath: String
}

"""The result for Query.slowRequests."""
type SlowRequestConnection {
  """A list of slow graphql requests logs."""
  nodes: [SlowRequest!]!

  """The total number of slow graphql logs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""The SCIP snapshot decoration for a single SCIP Occurrence."""
type SnapshotData {
  """
  The byte offset in the document immediately after the line the occurrence is on.
  """
  offset: Int!

  """The formatted SCIP symbol string."""
  data: String!
}

"""EXPERIMENTAL: Attribution result from snippetAttribution."""
type SnippetAttribution {
  """
  The name of the repository containing the snippet.
  
  Note: we do not return a type Repository since repositoryName may
  represent a repository not on this instance. eg a match from the
  sourcegraph.com open source corpus.
  """
  repositoryName: String!
}

"""EXPERIMENTAL: A list of snippet attributions."""
type SnippetAttributionConnection {
  """
  totalCount is the total number of repository attributions we found before
  stopping the search.
  
  Note: if we didn't finish searching the full corpus then limitHit will be
  true. For filtering use case this means if limitHit is true you need to be
  conservative with TotalCount and assume it could be higher.
  """
  totalCount: Int!

  """
  limitHit is true if we stopped searching before looking into the full
  corpus. If limitHit is true then it is possible there are more than
  totalCount attributions.
  """
  limitHit: Boolean!

  """The pagination info for the connection."""
  pageInfo: PageInfo!

  """The page set of SnippetAttribution entries in this connection."""
  nodes: [SnippetAttribution!]!
}

"""Speaker type, human or assistant"""
enum SpeakerType {
  HUMAN
  ASSISTANT
}

"""FOR INTERNAL USE ONLY: A status message"""
union StatusMessage = GitUpdatesDisabled | NoRepositoriesDetected | CloningProgress | ExternalServiceSyncError | SyncError | IndexingProgress

"""A Git submodule"""
type Submodule {
  """The remote repository URL of the submodule."""
  url: String!

  """The commit of the submodule."""
  commit: String!

  """The path to which the submodule is checked out."""
  path: String!
}

"""An individual response to a user satisfaction (NPS) survey."""
type SurveyResponse {
  """The unique ID of the survey response"""
  id: ID!

  """
  The user who submitted the survey (if they were authenticated at the time).
  """
  user: User

  """
  The email that the user manually entered (if they were NOT authenticated at the time).
  """
  email: String

  """User's likelihood of recommending Sourcegraph to a friend, from 0-10."""
  score: Int!

  """
  The answer to "What is the most important reason for the score you gave".
  """
  reason: String

  """
  The answer to "What can Sourcegraph do to provide a better product"
  """
  better: String

  """The answer to "What do you use Sourcegraph for?"."""
  otherUseCase: String

  """The time when this response was created."""
  createdAt: DateTime!
}

"""A list of survey responses"""
type SurveyResponseConnection {
  """A list of survey responses."""
  nodes: [SurveyResponse!]!

  """
  The total count of survey responses in the connection. This total count may be larger
  than the number of nodes in this object when the result is paginated.
  """
  totalCount: Int!

  """
  The count of survey responses submitted since 30 calendar days ago at 00:00 UTC.
  """
  last30DaysCount: Int!

  """
  The average score of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
  """
  averageScore: Float!

  """
  The net promoter score (NPS) of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
  Return value is a signed integer, scaled from -100 (all detractors) to +100 (all promoters).
  See https://en.wikipedia.org/wiki/Net_Promoter for explanation.
  """
  netPromoterScore: Int!
}

"""Input for a user satisfaction (NPS) survey submission."""
input SurveySubmissionInput {
  """
  User-provided email address, if there is no currently authenticated user. If there is, this value
  will not be used.
  """
  email: String

  """User's likelihood of recommending Sourcegraph to a friend, from 0-10."""
  score: Int!

  """The answer to "What do you use Sourcegraph for?"."""
  otherUseCase: String

  """
  The answer to "What would make Sourcegraph better?"
  """
  better: String
}

"""Possible answers to "You use Sourcegraph to..." in the NPS Survey."""
enum SurveyUseCase {
  UNDERSTAND_NEW_CODE
  FIX_SECURITY_VULNERABILITIES
  REUSE_CODE
  RESPOND_TO_INCIDENTS
  IMPROVE_CODE_QUALITY
}

"""
A code symbol (e.g., a function, variable, type, class, etc.).
It is derived from DocumentSymbol as defined in the Language Server Protocol (see https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentSymbol).
"""
type Symbol {
  """The name of the symbol."""
  name: String!

  """
  The name of the symbol that contains this symbol, if any. This field's value is not guaranteed to be
  structured in such a way that callers can infer a hierarchy of symbols.
  """
  containerName: String

  """The kind of the symbol."""
  kind: SymbolKind!

  """The programming language of the symbol."""
  language: String!

  """The location where this symbol is defined."""
  location: Location!

  """
  The URL to this symbol (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this symbol (using an immutable revision specifier).
  """
  canonicalURL: String!

  """Whether or not the symbol is local to the file it's defined in."""
  fileLocal: Boolean!
}

"""FileBlock specifies a symbol to display within the block."""
type SymbolBlock {
  """ID of the block."""
  id: String!

  """Symbol block input."""
  symbolInput: SymbolBlockInput!
}

"""
SymbolBlockInput contains the information necessary to find the symbol.
"""
type SymbolBlockInput {
  """Name of the repository, e.g. "github.com/sourcegraph/sourcegraph"."""
  repositoryName: String!

  """Path within the repository, e.g. "client/web/file.tsx"."""
  filePath: String!

  """
  An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
  If omitted, we use the latest revision (HEAD).
  """
  revision: String

  """Number of lines to show before and after the matched symbol line."""
  lineContext: Int!

  """The symbol name."""
  symbolName: String!

  """Name of the symbol container."""
  symbolContainerName: String!

  """The symbol kind."""
  symbolKind: SymbolKind!
}

"""A list of symbols."""
type SymbolConnection {
  """A list of symbols."""
  nodes: [Symbol!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""
SymbolInfo contains hover and definition methods. It's returned by GitBlob.symbolInfo(line, character).
"""
type SymbolInfo {
  """The definition of the symbol."""
  definition: SymbolLocation

  """The hover for the symbol."""
  hover: String
}

"""
All possible kinds of symbols. This set matches that of the Language Server Protocol
(https://microsoft.github.io/language-server-protocol/specification#workspace_symbol).
"""
enum SymbolKind {
  UNKNOWN
  FILE
  MODULE
  NAMESPACE
  PACKAGE
  CLASS
  METHOD
  PROPERTY
  FIELD
  CONSTRUCTOR
  ENUM
  INTERFACE
  FUNCTION
  VARIABLE
  CONSTANT
  STRING
  NUMBER
  BOOLEAN
  ARRAY
  OBJECT
  KEY
  NULL
  ENUMMEMBER
  STRUCT
  EVENT
  OPERATOR
  TYPEPARAMETER
}

"""
SymbolLocation is a single-line range within a repository. It's returned by SymbolInfo.definition.
"""
type SymbolLocation {
  """The repo."""
  repo: String!

  """The commit."""
  commit: String!

  """The path."""
  path: String!

  """The range."""
  range: LineRange

  """The line."""
  line: Int! @deprecated(reason: "use range.line instead")

  """The character."""
  character: Int! @deprecated(reason: "use range.character instead")

  """The length."""
  length: Int! @deprecated(reason: "use range.length instead")
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories could not
be synced
"""
type SyncError {
  """The message of this status message"""
  message: String!
}

"""
A team is a grouping of users/persons into a common handle. Teams are commonly used to define
codeowners.
"""
type Team implements Node {
  """The unique ID of the team."""
  id: ID!

  """
  The name of the team. Needs to be globally unique across usernames, organization
  names, and team names. Team names can use alphanumeric characters, - dash
  and / forward slash.
  """
  name: String!

  """URL to link to the teams profile page."""
  url: String!

  """URL to an avatar of this team."""
  avatarURL: String

  """A human readable name substitute for the name. Null, if not defined."""
  displayName: String

  """
  A team can be made read-only from the CLI instructing the UI to show a warning
  banner that this is managed externally, and management features will only be
  available to site-admins. It can also still be manipulated from the CLI.
  """
  readonly: Boolean!

  """
  The teams direct members. That is members that are strictly part of this team,
  but not members of child teams. Team membership is NOT inherited.
  """
  members(
    """Returns the first n team members from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Optionally apply a text search filter over the results."""
    search: String
  ): TeamMemberConnection!

  """Parent team can be null, if this is a root team."""
  parentTeam: Team

  """The list of direct child teams."""
  childTeams(
    """Returns the first n teams from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Optionally apply a text search filter over the results."""
    search: String
  ): TeamConnection!

  """True, if the current user can modify this team."""
  viewerCanAdminister: Boolean!

  """The creator of this team. Null, if the user was deleted."""
  creator: User

  """
  True, if the team is external, i.e. not found in our database.
  Example: CODEOWNERS files can contain references to GitHub teams which are not the part of Sourcegraph teams.
  """
  external: Boolean!
}

"""A list of teams."""
type TeamConnection {
  """The total count of items in the connection."""
  totalCount: Int!

  """The pagination info for the connection."""
  pageInfo: PageInfo!

  """The current page of teams in this connection."""
  nodes: [Team!]!
}

"""
A team member is an entity that can be associated to a team.

For now, this will be User, and will be expanded to User | Person later.
"""
interface TeamMember {
  """All the teams this TeamMember is a direct member of."""
  teams(
    """Returns the first n teams from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Optionally apply a text search filter over the results."""
    search: String
  ): TeamConnection!
}

"""A list of team members."""
type TeamMemberConnection {
  """The total count of items in the connection."""
  totalCount: Int!

  """The pagination info for the connection."""
  pageInfo: PageInfo!

  """The current page of team members in this connection."""
  nodes: [TeamMember!]!
}

"""
Options to specify a user for team membership. Multiple options can be provided,
with the following precedence order: (Other mismatches will be discarded)
- UserID
- Username
- Email
- External Account fields

Examples:
- If ID is set and no match, return.
- If ID and username is set, and ID matches but username doesn't, match.
"""
input TeamMemberInput {
  """Explicitly define a user by ID."""
  userID: ID

  """Explicitly define a user by username in Sourcegraph."""
  username: String

  """
  If the email is associated to a user and verified, the user account will be matched.
  """
  email: String

  """
  If the user has an associated external account, use this.
  externalAccountServiceID and externalAccountServiceType must be set and
  either of externalAccountAccountID externalAccountLogin are required as well.
  Service ID for the GitHub OAuth provider, for example, is https://github.com/.
  """
  externalAccountServiceID: String

  """
  If the user has an associated external account, use this.
  externalAccountServiceID and externalAccountServiceType must be set and
  either of externalAccountAccountID externalAccountLogin are required as well.
  Service Type for the GitHub OAuth provider, for example, is github.
  """
  externalAccountServiceType: String

  """
  If the user has an associated external account, use this.
  externalAccountServiceID and externalAccountServiceType must be set and
  either of externalAccountAccountID externalAccountLogin are required as well.
  Account ID is the unique identifier on the external account platform.
  """
  externalAccountAccountID: String

  """
  If the user has an associated external account, use this.
  externalAccountServiceID and externalAccountServiceType must be set and
  either of externalAccountAccountID externalAccountLogin are required as well.
  Account Login is usually the username on the external account platform.
  """
  externalAccountLogin: String
}

"""Temporary settings for a user."""
type TemporarySettings {
  """A JSON string representing the temporary settings."""
  contents: String!
}

"""A time scope defined using a time interval (ex. 5 days)"""
input TimeIntervalStepInput {
  """The time unit for the interval."""
  unit: TimeIntervalStepUnit!

  """The value for the interval."""
  value: Int!
}

"""Time interval units."""
enum TimeIntervalStepUnit {
  HOUR
  DAY
  WEEK
  MONTH
  YEAR
}

"""
Represents a terminally incomplete data point at a specific time, and optionally for a specific repository.
"""
type TimeoutDatapointAlert implements IncompleteDatapointAlert {
  """The data point that is incomplete."""
  time: DateTime!
}

"""A custom time scope for an insight data series."""
input TimeScopeInput {
  """Sets a time scope using a step interval (intervals of time)."""
  stepInterval: TimeIntervalStepInput
}

"""A file, directory, or other tree entry."""
interface TreeEntry {
  """The full path (relative to the repository root) of this tree entry."""
  path: String!

  """The base name (i.e., file name only) of this tree entry."""
  name: String!

  """Whether this tree entry is a directory."""
  isDirectory: Boolean!

  """
  The URL to this tree entry (using the input revision specifier, which may not be immutable).
  """
  url: String!

  """
  The canonical URL to this tree entry (using an immutable revision specifier).
  """
  canonicalURL: String!

  """The URLs to this tree entry on external services."""
  externalURLs: [ExternalLink!]!

  """Symbols defined in this file or directory."""
  symbols(
    """Returns the first n symbols from the list."""
    first: Int

    """Return symbols matching the query."""
    query: String
  ): SymbolConnection!

  """Submodule metadata if this tree points to a submodule"""
  submodule: Submodule

  """Whether this tree entry is a single child"""
  isSingleChild(
    """Returns the first n files in the tree."""
    first: Int

    """Recurse into sub-trees."""
    recursive: Boolean = false

    """Recurse into sub-trees of single-child directories"""
    recursiveSingleChild: Boolean = false
  ): Boolean!

  """LSIF data for this tree entry."""
  lsif(
    """
    An optional filter for the name of the tool that produced the upload data.
    """
    toolName: String
  ): TreeEntryLSIFData
}

"""
LSIF data available for a tree entry (file OR directory, see GitBlobLSIFData for file-specific
resolvers and GitTreeLSIFData for directory-specific resolvers.)
"""
interface TreeEntryLSIFData {
  """Code diagnostics provided through LSIF."""
  diagnostics(first: Int): DiagnosticConnection!
}

"""Information about software updates for Sourcegraph."""
type UpdateCheck {
  """Whether an update check is currently in progress."""
  pending: Boolean!

  """
  When the last update check was completed, or null if no update check has
  been completed (or performed) yet.
  """
  checkedAt: DateTime

  """
  If an error occurred during the last update check, this message describes
  the error.
  """
  errorMessage: String

  """If an update is available, the version string of the updated version."""
  updateVersionAvailable: String
}

"""
Partial update to apply to a subscription's Cody Gateway access. Omitted fields are not applied.
"""
input UpdateCodyGatewayAccessInput {
  """Enable or disable Cody Gateway access."""
  enabled: Boolean

  """
  Override default requests per time interval.
  
  Set to 0 to remove the override.
  """
  chatCompletionsRateLimit: BigInt

  """
  Override default interval for rate limiting.
  
  Set to 0 to remove the override.
  """
  chatCompletionsRateLimitIntervalSeconds: Int

  """
  Override the set of allowed models for chat completions
  for this subscription.
  """
  chatCompletionsAllowedModels: [String!]

  """
  Override default requests per time interval.
  
  Set to 0 to remove the override.
  """
  codeCompletionsRateLimit: BigInt

  """
  Override default interval for rate limiting.
  
  Set to 0 to remove the override.
  """
  codeCompletionsRateLimitIntervalSeconds: Int

  """
  Override the set of allowed models for chat completions
  for this subscription.
  """
  codeCompletionsAllowedModels: [String!]

  """
  Override default requests per time interval for embeddings generation.
  
  Set to 0 to remove the override.
  """
  embeddingsRateLimit: BigInt

  """
  Override default interval for rate limiting for embeddings generation.
  
  Set to 0 to remove the override.
  """
  embeddingsRateLimitIntervalSeconds: Int

  """
  Override the set of allowed models for embeddings generation for this subscription.
  """
  embeddingsAllowedModels: [String!]
}

"""Fields to update for an existing external service."""
input UpdateExternalServiceInput {
  """The id of the external service to update."""
  id: ID!

  """The updated display name, if provided."""
  displayName: String

  """The updated config, if provided."""
  config: String
}

"""Input object for updating a dashboard."""
input UpdateInsightsDashboardInput {
  """Dashboard title."""
  title: String

  """Permissions to grant to the dashboard."""
  grants: InsightsPermissionGrantsInput
}

"""Input object for update insight series mutation."""
input UpdateInsightSeriesInput {
  """Unique ID for the series."""
  seriesId: String!

  """The desired activity state (enabled or disabled) for the series."""
  enabled: Boolean
}

"""Input for updating a line chart search insight."""
input UpdateLineChartSearchInsightInput {
  """
  The complete list of data series on this line chart. Note: excluding a data series will remove it.
  """
  dataSeries: [LineChartSearchInsightDataSeriesInput!]!

  """
  The scope of repositories for the insight, this scope will apply to all
  dataSeries unless another scope is provided by a series.
  """
  repositoryScope: RepositoryScopeInput

  """
  The time scope for this insight, this scope will apply to all dataSeries unless another scope is provided by a series.
  """
  timeScope: TimeScopeInput

  """The presentation options for this line chart."""
  presentationOptions: LineChartOptionsInput!

  """The default values for filters and aggregates for this line chart."""
  viewControls: InsightViewControlsInput!
}

"""Input for updating a pie chart search insight"""
input UpdatePieChartSearchInsightInput {
  """The query string."""
  query: String!

  """The scope of repositories."""
  repositoryScope: RepositoryScopeInput!

  """Options for this pie chart."""
  presentationOptions: PieChartOptionsInput!
}

"""
Partial update to apply to a subscription. Omitted fields are not applied.
"""
input UpdateProductSubscriptionInput {
  """Partial update to Cody Gateway access granted to this subscription."""
  codyGatewayAccess: UpdateCodyGatewayAccessInput
}

"""The state of a repository in the update queue."""
type UpdateQueue {
  """
  The index of the repo in the update queue.
  Updating repos are placed at the end of the queue until they finish updating
  so don't display this if updating is true.
  """
  index: Int!

  """True if the repo is currently updating."""
  updating: Boolean!

  """
  The total number of repos in the update queue (including updating repos).
  """
  total: Int!
}

"""The state of a repository in the update schedule."""
type UpdateSchedule {
  """The interval that was used when scheduling the current due time."""
  intervalSeconds: Int!

  """The next time that the repo will be inserted into the update queue."""
  due: DateTime!

  """The index of the repo in the schedule."""
  index: Int!

  """The total number of repos in the schedule."""
  total: Int!
}

"""The payload for SettingsMutation.updateConfiguration."""
type UpdateSettingsPayload {
  """An empty response."""
  empty: EmptyResponse
}

"""
UpdateSignalConfigurationsInput represents the input for updating multiple signal configurations.
"""
input UpdateSignalConfigurationsInput {
  """The signal configuration updates."""
  configs: [OwnSignalConfigurationUpdate!]!
}

"""
Instance upgrade readiness information includes schema drifts and deprecated-but-unfinished out-of-band migrations.
"""
type UpgradeReadiness {
  """The schema drift details."""
  schemaDrift: [SchemaDriftSummary!]!

  """The list of deprecated-but-unfinished out-of-band migrations."""
  requiredOutOfBandMigrations: [OutOfBandMigration!]!
}

"""A user."""
type User implements Node & SettingsSubject & Namespace & TeamMember {
  """The unique ID for the user."""
  id: ID!

  """The user's username."""
  username: String!

  """
  The user's primary email address.
  Only the user and site admins can access this field.
  """
  email: String! @deprecated(reason: "use emails instead")

  """The display name chosen by the user."""
  displayName: String

  """The URL of the user's avatar image."""
  avatarURL: String

  """The URL to the user's profile on Sourcegraph."""
  url: String!

  """The URL to the user's settings."""
  settingsURL: String

  """The date when the user account was created on Sourcegraph."""
  createdAt: DateTime!

  """The date when the user account was last updated on Sourcegraph."""
  updatedAt: DateTime

  """
  Whether the user is a site admin.
  Only the user and site admins can access this field.
  """
  siteAdmin: Boolean!

  """Whether the user account uses built in auth."""
  builtinAuth: Boolean!

  """
  The latest settings for the user.
  Only the user and site admins can access this field.
  """
  latestSettings: Settings

  """
  All settings for this user, and the individual levels in the settings cascade (global > organization > user)
  that were merged to produce the final merged settings.
  Only the user and site admins can access this field.
  """
  settingsCascade: SettingsCascade!

  """DEPRECATED"""
  configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")

  """The organizations that this user is a member of."""
  organizations: OrgConnection!

  """This user's organization memberships."""
  organizationMemberships: OrganizationMembershipConnection!

  """Whether the user has already accepted the terms of service or not."""
  tosAccepted: Boolean!

  """Whether the user accepted to be searched in the users picker or not."""
  searchable: Boolean!

  """The user's usage statistics on Sourcegraph."""
  usageStatistics: UserUsageStatistics!

  """The user's events on Sourcegraph."""
  eventLogs(
    """Returns the first n event logs from the list."""
    first: Int

    """Only return events matching this event name"""
    eventName: String
  ): EventLogsConnection!

  """
  The user's email addresses.
  Only the user and site admins can access this field.
  """
  emails: [UserEmail!]!

  """
  Whether the user has a verified email or not.
  Only the user and site admins can access this field.
  """
  hasVerifiedEmail: Boolean!

  """
  The user's verified primary email address (if any).
  On dotcom only the user and site admins can access this field.
  """
  primaryEmail: UserEmail

  """
  The user's access tokens (which grant to the holder the privileges of the user). This consists
  of all access tokens whose subject is this user.
  Only the user and site admins can access this field.
  """
  accessTokens(
    """Returns the first n access tokens from the list."""
    first: Int
  ): AccessTokenConnection!

  """A list of external accounts that are associated with the user."""
  externalAccounts(
    """Returns the first n external accounts from the list."""
    first: Int
  ): ExternalAccountConnection!

  """
  The user's currently active session.
  Only the currently authenticated user can access this field. Site admins are not able to access sessions for
  other users.
  """
  session: Session!

  """
  Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and
  site admins have admin privileges on all users.
  """
  viewerCanAdminister: Boolean!

  """
  Whether the viewer can change the username of this user.
  The user can change their username unless auth.disableUsernameChanges is set.
  Site admins can always change the username of any user.
  """
  viewerCanChangeUsername: Boolean!

  """
  The user's survey responses.
  Only the user and site admins can access this field.
  """
  surveyResponses: [SurveyResponse!]!

  """
  The unique numeric ID for the user.
  FOR INTERNAL USE ONLY.
  """
  databaseID: Int!

  """
  The name of this user namespace's component. For users, this is the username.
  """
  namespaceName: String!

  """Whether the user is controlled externally through SCIM."""
  scimControlled: Boolean!

  """
  EXPERIMENTAL: Collaborators who can be invited to Sourcegraph. This typically comes from a few
  repositories this user has access to, and is derived from recent commit history of those.
  """
  invitableCollaborators: [Person!]!

  """The list of all roles assigned to this user."""
  roles(
    """The limit argument for forward pagination."""
    first: Int

    """The limit argument for backward pagination."""
    last: Int

    """The cursor argument for forward pagination."""
    after: String

    """The cursor argument for backward pagination."""
    before: String
  ): RoleConnection!

  """The list of permissions granted to this user based on their roles."""
  permissions: PermissionConnection!

  """
  The configured override for the user to the completions request quota per day.
  Null, if not overwritten.
  """
  completionsQuotaOverride: Int

  """
  The configured override for the user to the code completions request quota
  per day.
  Null, if not overwritten.
  """
  codeCompletionsQuotaOverride: Int

  """
  The list of all available executor secrets for execution in this users namespace.
  """
  executorSecrets(
    """The scope for which secrets shall be returned."""
    scope: ExecutorSecretScope!

    """Only return N records."""
    first: Int = 50

    """Opaque cursor for pagination."""
    after: String
  ): ExecutorSecretConnection!

  """All the teams this user is a direct member of."""
  teams(
    """Returns the first n teams from the list."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Optionally apply a text search filter over the results."""
    search: String
  ): TeamConnection!

  """A list of batch changes applied under this user's namespace."""
  batchChanges(
    """Returns the first n batch changes from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String

    """
    Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`.
    """
    state: BatchChangeState

    """
    Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it.
    """
    states: [BatchChangeState!]

    """Only include batch changes that the viewer can administer."""
    viewerCanAdminister: Boolean
  ): BatchChangeConnection!

  """
  Returns a connection of configured external services accessible by this user, for usage with batch changes.
  These are all code hosts configured on the Sourcegraph instance that are supported by batch changes. They are
  connected to BatchChangesCredential resources, if one has been created for the code host connection before.
  """
  batchChangesCodeHosts(
    """Returns the first n code hosts from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): BatchChangesCodeHostConnection!

  """
  The permissions information of the user over repositories.
  It is null when there is no permissions data stored for the user.
  """
  permissionsInfo: PermissionsInfo

  """A list of monitors owned by the user or her organization."""
  monitors(
    """Returns the first n monitors from the list."""
    first: Int = 50

    """Opaque pagination cursor."""
    after: String
  ): MonitorConnection!
}

"""A period of time in which a set of users have been active."""
enum UserActivePeriod {
  """Since today at 00:00 UTC."""
  TODAY

  """Since the latest Monday at 00:00 UTC."""
  THIS_WEEK

  """Since the first day of the current month at 00:00 UTC."""
  THIS_MONTH

  """All time."""
  ALL_TIME
}

"""A list of users."""
type UserConnection {
  """A list of users."""
  nodes: [User!]!

  """
  The total count of users in the connection. This total count may be larger
  than the number of nodes in this object when the result is paginated.
  """
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A user's email address."""
type UserEmail {
  """The email address."""
  email: String!

  """
  Whether the email address is the user's primary email address. Currently this is defined as the earliest
  email address associated with the user, preferring verified emails to unverified emails.
  """
  isPrimary: Boolean!

  """Whether the email address has been verified by the user."""
  verified: Boolean!

  """Whether the email address is pending verification."""
  verificationPending: Boolean!

  """The user associated with this email address."""
  user: User!

  """
  Whether the viewer has privileges to manually mark this email address as verified (without the user going
  through the normal verification process). Only site admins have this privilege.
  """
  viewerCanManuallyVerify: Boolean!
}

"""A user event."""
enum UserEvent {
  PAGEVIEW
  SEARCHQUERY
  CODEINTEL
  CODEINTELREFS
  CODEINTELINTEGRATION
  CODEINTELINTEGRATIONREFS

  """Product stages"""
  STAGEMANAGE
  STAGEPLAN
  STAGECODE
  STAGEREVIEW
  STAGEVERIFY
  STAGEPACKAGE
  STAGEDEPLOY
  STAGECONFIGURE
  STAGEMONITOR
  STAGESECURE
  STAGEAUTOMATE
}

"""
A user (identified either by username or email address) with its repository permission.
"""
type UserPermission {
  """
  Depending on the bindID option in the permissions.userMapping site configuration property,
  the elements of the list are either all usernames (bindID of "username") or all email
  addresses (bindID of "email").
  """
  bindID: String!

  """The highest level of repository permission."""
  permission: RepositoryPermission!
}

"""
Input type of a user (identified either by username or email address) with its repository permission.
"""
input UserPermissionInput {
  """
  Depending on the bindID option in the permissions.userMapping site configuration property,
  the elements of the list are either all usernames (bindID of "username") or all email
  addresses (bindID of "email").
  """
  bindID: String!

  """The highest level of repository permission."""
  permission: RepositoryPermission = READ
}

"""
A user (identified either by username or email address) with its sub-repository permissions.
"""
input UserSubRepoPermission {
  """
  Depending on the bindID option in the permissions.userMapping site configuration property,
  the elements of the list are either all usernames (bindID of "username") or all email
  addresses (bindID of "email").
  """
  bindID: String!

  """
  DEPRECATED
  An array of paths that the user is allowed to access, in glob format.
  """
  pathIncludes: [String!]

  """
  DEPRECATED
  An array of paths that the user is not allowed to access, in glob format.
  """
  pathExcludes: [String!]

  """
  An array of paths in glob format. Paths starting with a minus (-)
  (i.e. "-/dev/private") prevent access, otherwise paths grant access.
  The last applicable path takes precedence.
  When paths is set, pathIncludes and pathExcludes are ignored.
  """
  paths: [String!]
}

"""
UserUsageStatistics describes a user's usage statistics.
This information is visible to all viewers.
"""
type UserUsageStatistics {
  """The number of search queries that the user has performed."""
  searchQueries: Int!

  """The number of page views that the user has performed."""
  pageViews: Int!

  """The number of code intelligence actions that the user has performed."""
  codeIntelligenceActions: Int!

  """The number of find-refs actions that the user has performed."""
  findReferencesActions: Int!

  """The last time the user was active (any action, any platform)."""
  lastActiveTime: String

  """The last time the user was active on a code host integration."""
  lastActiveCodeHostIntegrationTime: String
}

"""A virtual file is an arbitrary file that is generated in memory."""
type VirtualFile implements File2 {
  """The full path (relative to the root) of this file."""
  path: String!

  """The base name (i.e., file name only) of this file."""
  name: String!

  """False because this is a file, not a directory."""
  isDirectory: Boolean!

  """The content of this file."""
  content(
    """
    Return file content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return file content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """The file size in bytes."""
  byteSize: Int!

  """Total line count for the file. Returns 0 for binary files."""
  totalLines: Int!

  """Whether or not it is binary."""
  binary: Boolean!

  """
  The file rendered as rich HTML, or an empty string if it is not a supported
  rich file type.
  This HTML string is already escaped and thus is always safe to render.
  """
  richHTML(
    """
    Return richHTML content starting at line "startLine". A value <= 0 will be the start of the file.
    """
    startLine: Int

    """
    Return richHTML content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    """
    endLine: Int
  ): String!

  """Not implemented."""
  url: String!

  """Not implemented."""
  canonicalURL: String!

  """Not implemented."""
  externalURLs: [ExternalLink!]!

  """Highlight the file."""
  highlight(
    disableTimeout: Boolean!
    isLightTheme: Boolean

    """
    If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
    2000 bytes is enabled. This may produce a significant amount of HTML
    which some browsers (such as Chrome, but not Firefox) may have trouble
    rendering efficiently.
    """
    highlightLongLines: Boolean = false

    """Specifies which format/highlighting technique to use."""
    format: HighlightResponseFormat = HTML_HIGHLIGHT

    """
    Return highlight content starting at line "startLine". A value <= 0 will be the start of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    startLine: Int

    """
    Return highlight content ending at line "endLine". A value < 0 or > totalLines will set endLine to the end of the file.
    Warning: Pagination only works with the HTML_PLAINTEXT format type at the moment.
    """
    endLine: Int
  ): HighlightedFile!
}

"""A preview entry to a repository to which the user has access."""
union VisibleApplyPreviewTargets = VisibleApplyPreviewTargetsAttach | VisibleApplyPreviewTargetsUpdate | VisibleApplyPreviewTargetsDetach

"""
A preview entry where no changeset existed before matching the changeset spec.
"""
type VisibleApplyPreviewTargetsAttach {
  """The changeset spec from this entry."""
  changesetSpec: VisibleChangesetSpec!
}

"""
A preview entry where no changeset spec exists for the changeset currently in
the target batch change.
"""
type VisibleApplyPreviewTargetsDetach {
  """The changeset from this entry."""
  changeset: ExternalChangeset!
}

"""A preview entry where a changeset matches the changeset spec."""
type VisibleApplyPreviewTargetsUpdate {
  """The changeset spec from this entry."""
  changesetSpec: VisibleChangesetSpec!

  """The changeset from this entry."""
  changeset: ExternalChangeset!
}

"""A workspace to which the requesting user has access."""
type VisibleBatchSpecWorkspace implements BatchSpecWorkspace & Node {
  """The unique ID for the workspace."""
  id: ID!

  """The repository to run over."""
  repository: Repository!

  """Used for reverse querying."""
  batchSpec: BatchSpec!

  """The branch to run over."""
  branch: GitRef!

  """The path to run in."""
  path: String!

  """If true, only the files within the workspace will be fetched."""
  onlyFetchWorkspace: Boolean!

  """
  If true, this workspace has been skipped, because some rule forced this.
  For now, the only one is a .batchignore file existing in the repository.
  """
  ignored: Boolean!

  """
  If true, this workspace has been skipped, because the code host on which
  the repository is hosted is not supported.
  """
  unsupported: Boolean!

  """Whether we found a task cache result."""
  cachedResultFound: Boolean!

  """How many steps had a cached result."""
  stepCacheResultCount: Int!

  """
  Executor stages of running in this workspace. Null, if the execution hasn't
  started yet.
  """
  stages: BatchSpecWorkspaceStages

  """List of steps that will need to run over this workspace."""
  steps: [BatchSpecWorkspaceStep!]!

  """Get a specific step by its index. Index is 1-based."""
  step(index: Int!): BatchSpecWorkspaceStep

  """
  If this workspace was resolved based on a search, this is the list of paths
  to files that have been included in the search results.
  """
  searchResultPaths: [String!]!

  """
  The time when the workspace was enqueued for processing. Null, if not yet enqueued.
  """
  queuedAt: DateTime

  """
  The time when the workspace started processing. Null, if not yet started.
  """
  startedAt: DateTime

  """
  The time when the workspace finished processing. Null, if not yet finished.
  """
  finishedAt: DateTime

  """Optional failure message, set when the execution failed."""
  failureMessage: String

  """The current state the workspace is in."""
  state: BatchSpecWorkspaceState!

  """
  Populated, when the execution is finished. This is where you get the combined
  diffs.
  """
  changesetSpecs: [VisibleChangesetSpec!]

  """
  The rank of this execution in the queue of the user. The value of this field is null if the
  execution has started.
  """
  placeInQueue: Int

  """
  The rank of this execution in the global queue. The value of this field is null if the
  execution has started.
  """
  placeInGlobalQueue: Int

  """
  The diff stat over all created changeset specs. Null, if not yet finished or
  failed.
  """
  diffStat: DiffStat

  """
  The executor that picked up this job. Null, if the executor has been pruned
  from the data set or if the job has not started yet.
  Only available to site-admins.
  """
  executor: Executor
}

"""
One preview entry in the list of all previews against a batch spec. Each mapping
between changeset specs and current changesets yields one of these. It describes
which operations are taken against which changeset spec and changeset to ensure the
desired state is met.
"""
type VisibleChangesetApplyPreview {
  """The operations to take to achieve the desired state."""
  operations: [ChangesetSpecOperation!]!

  """
  The delta between the current changeset state and what the new changeset spec
  envisions the changeset to look like.
  """
  delta: ChangesetSpecDelta!

  """The target entities in this preview entry."""
  targets: VisibleApplyPreviewTargets!
}

"""
A changeset spec is an immutable description of the desired state of a changeset in a batch change. To
create a changeset spec, use the createChangesetSpec mutation.
"""
type VisibleChangesetSpec implements ChangesetSpec & Node {
  """
  The unique ID for a changeset spec.
  
  The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
  even though repository permissions also apply to viewers of changeset specs, because being
  allowed to view a repository should not entitle a person to view all not-yet-published
  changesets for that repository. Consider a batch change to fix a security vulnerability: the
  batch change author may prefer to prepare all of the changesets in private so that the window
  between revealing the problem and merging the fixes is as short as possible.
  """
  id: ID!

  """The type of changeset spec."""
  type: ChangesetSpecType!

  """The description of the changeset."""
  description: ChangesetDescription!

  """
  The date, if any, when this changeset spec expires and is automatically purged. A changeset
  spec never expires (and this field is null) if its batch spec has been applied.
  """
  expiresAt: DateTime

  """The fork the changeset will be pushed to, if any."""
  forkTarget: ForkTarget

  """The workspace this resulted from. Null, if not run server-side."""
  workspace: BatchSpecWorkspace
}

"""Vulnerabilities synced from the GitHub Advisory Database."""
type Vulnerability implements Node {
  """The ID of the vulnerability."""
  id: ID!

  """The CVE identifier of the vulnerability (e.g., CVE-2023-123)."""
  sourceID: String!

  """A short summary of the vulnerability."""
  summary: String!

  """A longer description of the vulnerability."""
  details: String!

  """Common Platform Enumeration identifiers related to this vulnerability."""
  cpes: [String!]!

  """Common Weakness Enumeration identifiers related to this vulnerability."""
  cwes: [String!]!

  """Other names this vulnerability is known by."""
  aliases: [String!]!

  """Names of related vulnerabilities."""
  related: [String!]!

  """The data source of this vulnerability."""
  dataSource: String!

  """URLs indicating the source of this vulnerability."""
  urls: [String!]!

  """A human-readable severity string."""
  severity: String!

  """The Common Vulnerability Scoring System severity vector."""
  cvssVector: String!

  """The Common Vulnerability Scoring System severity score."""
  cvssScore: String!

  """The time this vulnerability was published."""
  published: DateTime!

  """The last time this vulnerability was modified."""
  modified: DateTime

  """The time this vulnerability was withdrawn."""
  withdrawn: DateTime

  """A list of packages that are affected by this vulnerability."""
  affectedPackages: [VulnerabilityAffectedPackage!]!
}

"""A package affected by a vulnerability."""
type VulnerabilityAffectedPackage {
  """The name of the package."""
  packageName: String!

  """The language ecosystem."""
  language: String!

  """A package namespace."""
  namespace: String!

  """A list of constraints that identify affected versions of the package."""
  versionConstraint: [String!]!

  """Whether or not there is a known fix."""
  fixed: Boolean!

  """The version in which the fix was applied."""
  fixedIn: String

  """A list of specific symbols affected by the vulnerability."""
  affectedSymbols: [VulnerabilityAffectedSymbol!]!
}

"""A specific symbol affected by a vulnerability."""
type VulnerabilityAffectedSymbol {
  """A path to the document within the package source."""
  path: String!

  """A list of symbols defined in that path."""
  symbols: [String!]!
}

"""A page of vulnerabilities."""
type VulnerabilityConnection {
  """The vulnerabilities on the page."""
  nodes: [Vulnerability!]!

  """The total number of vulnerabilities across all pages."""
  totalCount: Int

  """Information on how to fetch the next page."""
  pageInfo: PageInfo!
}

"""A use of a known vulnerable-affected package.e"""
type VulnerabilityMatch implements Node {
  """The match ID."""
  id: ID!

  """The vulnerability."""
  vulnerability: Vulnerability!

  """The affected package that is used by the associated index."""
  affectedPackage: VulnerabilityAffectedPackage!

  """The index record that contains a direct use of the affected package."""
  preciseIndex: PreciseIndex!
}

"""A page of vulnerability matches."""
type VulnerabilityMatchConnection {
  """The vulnerability matches on the page."""
  nodes: [VulnerabilityMatch!]!

  """The total number of vulnerability matches across all pages."""
  totalCount: Int

  """Information on how to fetch the next page."""
  pageInfo: PageInfo!
}

"""Vulnerability matches count group by repository."""
type VulnerabilityMatchCountByRepository {
  """The id of the grouping."""
  id: ID!

  """The repository name."""
  repositoryName: String!

  """The vulnerability matches count."""
  matchCount: Int!
}

"""A page of vulnerability matches grouped by repository."""
type VulnerabilityMatchCountByRepositoryConnection {
  """The vulnerability matches on the page."""
  nodes: [VulnerabilityMatchCountByRepository!]!

  """The total number of vulnerability matches across all pages."""
  totalCount: Int

  """Information on how to fetch the next page."""
  pageInfo: PageInfo!
}

"""A count of the severities of vulnerability matches."""
type VulnerabilityMatchesSummaryCount {
  """The number of matches with a severity of "CRITICAL"."""
  critical: Int!

  """The number of matches with a severity of "HIGH"."""
  high: Int!

  """The number of matches with a severity of "MEDIUM"."""
  medium: Int!

  """The number of matches with a severity of "LOW"."""
  low: Int!

  """The number of repos with a severity"""
  repository: Int!
}

"""Represents an incoming webhook from a code host."""
type Webhook implements Node {
  """The unique ID of the webhook."""
  id: ID!

  """The user facing UUID of the webhook."""
  uuid: String!

  """
  The URL of the webhook in the instance. This is the location where we expect to receive payloads.
  """
  url: String!

  """Descriptive webhook name."""
  name: String!

  """The kind of code host sending payloads. (eg. GitHub, GitLab)"""
  codeHostKind: ExternalServiceKind!

  """The URN of the code host instance. (eg. https://gitlab.com)"""
  codeHostURN: String!

  """Optional secret."""
  secret: String

  """The last time this webhook was updated."""
  updatedAt: DateTime!

  """
  The user who last updated this webhook.
  Null if the user was deleted or if the webhook hasn't been updated yet.
  """
  updatedBy: User

  """When the webhook was created."""
  createdAt: DateTime!

  """
  The user who created this webhook.
  Null if the user was deleted.
  """
  createdBy: User

  """The logs related to this webhook."""
  webhookLogs(
    """Returns the first n webhook logs."""
    first: Int

    """Opaque pagination cursor."""
    after: String

    """Only include webhook logs that resulted in errors."""
    onlyErrors: Boolean

    """Only include webhook logs on or after this time."""
    since: DateTime

    """Only include webhook logs on or before this time."""
    until: DateTime
  ): WebhookLogConnection!
}

"""A list of webhooks"""
type WebhookConnection {
  """A list of webhooks."""
  nodes: [Webhook!]!

  """The total number of webhooks in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A single logged webhook delivery."""
type WebhookLog implements Node {
  """The webhook log ID."""
  id: ID!

  """The time the webhook was received at."""
  receivedAt: DateTime!

  """The external service the webhook was matched to, if any."""
  externalService: ExternalService

  """The HTTP status code returned from the webhook handler."""
  statusCode: Int!

  """The received webhook request."""
  request: WebhookLogRequest!

  """The response sent by the webhook handler."""
  response: WebhookLogResponse!
}

"""A list of logged webhook deliveries."""
type WebhookLogConnection {
  """A list of webhook logs."""
  nodes: [WebhookLog!]!

  """The total number of webhook logs in the connection."""
  totalCount: Int!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""A HTTP message (request or response) within a webhook log."""
interface WebhookLogMessage {
  """The headers in the HTTP message."""
  headers: [HTTPHeader!]!

  """The body content of the HTTP message."""
  body: String!
}

"""A HTTP request within a webhook log."""
type WebhookLogRequest implements WebhookLogMessage {
  """The headers in the HTTP message."""
  headers: [HTTPHeader!]!

  """The body content of the HTTP message."""
  body: String!

  """The method used in the HTTP request."""
  method: String!

  """The requested URL."""
  url: String!

  """The HTTP version in use."""
  version: String!
}

"""A HTTP response within a webhook log."""
type WebhookLogResponse implements WebhookLogMessage {
  """The headers in the HTTP message."""
  headers: [HTTPHeader!]!

  """The body content of the HTTP message."""
  body: String!
}

"""Possible sort orderings for a workspace connection."""
enum WorkspacesSortOrder {
  """Sort by repository name in ascending order."""
  REPO_NAME_ASC

  """Sort by repository name in descending order."""
  REPO_NAME_DESC
}

